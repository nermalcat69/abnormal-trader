import { NuxtOptions, Component, NuxtPage, NuxtLayout, NuxtApp } from 'nuxt/schema';
import { StorageMounts } from 'nitropack';
import { StorageValue } from 'unstorage';
import { VNode } from 'vue';
import { RouteRecordNormalized } from 'vue-router';
import { Import, UnimportMeta } from 'unimport';
import { Options } from 'execa';

type TabCategory = 'app' | 'analyze' | 'server' | 'modules' | 'documentation' | 'advanced';

interface ModuleCustomTab {
    /**
     * The name of the tab, must be unique
     */
    name: string;
    /**
     * Icon of the tab, support any Iconify icons, or a url to an image
     */
    icon?: string;
    /**
     * Title of the tab
     */
    title: string;
    /**
     * Main view of the tab
     */
    view: ModuleView;
    /**
     * Category of the tab
     * @default 'app'
     */
    category?: TabCategory;
    /**
     * Insert static vnode to the tab entry
     *
     * Advanced options. You don't usually need this.
     */
    extraTabVNode?: VNode;
}
interface ModuleLaunchView {
    /**
     * A view for module to lazy launch some actions
     */
    type: 'launch';
    title?: string;
    icon?: string;
    description: string;
    /**
     * Action buttons
     */
    actions: ModuleLaunchAction[];
}
interface ModuleIframeView {
    /**
     * Iframe view
     */
    type: 'iframe';
    /**
     * Url of the iframe
     */
    src: string;
    /**
     * Persist the iframe instance even if the tab is not active
     *
     * @default true
     */
    persistent?: boolean;
}
interface ModuleVNodeView {
    /**
     * Vue's VNode view
     */
    type: 'vnode';
    /**
     * Send vnode to the client, they must be static and serializable
     *
     * Call `nuxt.hook('devtools:customTabs:refresh')` to trigger manual refresh
     */
    vnode: VNode;
}
interface ModuleLaunchAction {
    /**
     * Label of the action button
     */
    label: string;
    /**
     * Additional HTML attributes to the action button
     */
    attrs?: Record<string, string>;
    /**
     * Indicate if the action is pending, will show a loading indicator and disable the button
     */
    pending?: boolean;
    /**
     * Function to handle the action, this is executed on the server side.
     * Will automatically refresh the tabs after the action is resolved.
     */
    handle?: () => void | Promise<void>;
    /**
     * Treat the action as a link, will open the link in a new tab
     */
    src?: string;
}
type ModuleView = ModuleIframeView | ModuleLaunchView | ModuleVNodeView;
interface ModuleIframeTabLazyOptions {
    description?: string;
    onLoad?: () => Promise<void>;
}
interface ModuleBuiltinTab {
    name: string;
    icon?: string;
    title?: string;
    path?: string;
    category?: TabCategory;
    show?: () => any;
    badge?: () => number | string | undefined;
}
type ModuleTabInfo = ModuleCustomTab | ModuleBuiltinTab;

interface HookInfo {
    name: string;
    start: number;
    end?: number;
    duration?: number;
    listeners: number;
    executions: number[];
}
interface ImageMeta {
    width: number;
    height: number;
    orientation?: number;
    type?: string;
    mimeType?: string;
}
interface PackageUpdateInfo {
    name: string;
    current: string;
    latest: string;
    needsUpdate: boolean;
}
type PackageManagerName = 'npm' | 'yarn' | 'pnpm';
type NpmCommandType = 'install' | 'uninstall' | 'update';
interface NpmCommandOptions {
    dev?: boolean;
    global?: boolean;
}
interface AutoImportsWithMetadata {
    imports: Import[];
    metadata?: UnimportMeta;
    dirs: string[];
}
interface RouteInfo extends Pick<RouteRecordNormalized, 'name' | 'path' | 'meta' | 'props' | 'children'> {
    file?: string;
}
interface ServerRouteInfo {
    route: string;
    filepath: string;
    path: string;
    method?: string;
    type: 'api' | 'route';
}
interface Payload {
    url: string;
    time: number;
    data?: Record<string, any>;
    state?: Record<string, any>;
    functions?: Record<string, any>;
}
interface PluginInfoWithMetic {
    src: string;
    mode?: 'client' | 'server' | 'all';
    ssr?: boolean;
    metric?: PluginMetric;
}
interface PluginMetric {
    src: string;
    start: number;
    end: number;
    duration: number;
}
interface BasicModuleInfo {
    entryPath?: string;
    meta?: {
        name?: string;
    };
}
interface ModuleMetric {
    name: string;
    description: string;
    repo: string;
    npm: string;
    icon?: string;
    github: string;
    website: string;
    learn_more: string;
    category: string;
    type: ModuleType;
    maintainers: MaintainerInfo[];
    contributors: GitHubContributor[];
    compatibility: ModuleCompatibility;
}
interface ModuleCompatibility {
    nuxt: string;
    requires: {
        bridge?: boolean | 'optional';
    };
}
type CompatibilityStatus = 'working' | 'wip' | 'unknown' | 'not-working';
type ModuleType = 'community' | 'official' | '3rd-party';
interface MaintainerInfo {
    name: string;
    github: string;
    twitter?: string;
}
interface GitHubContributor {
    login: string;
    name?: string;
    avatar_url?: string;
}
interface VueInspectorClient {
    enabled: boolean;
    position: {
        x: number;
        y: number;
    };
    linkParams: {
        file: string;
        line: number;
        column: number;
    };
    enable: () => void;
    disable: () => void;
    toggleEnabled: () => void;
    openInEditor: (baseUrl: string, file: string, line: number, column: number) => void;
    onUpdated: () => void;
}
type VueInspectorData = VueInspectorClient['linkParams'] & VueInspectorClient['position'];
type AssetType = 'image' | 'font' | 'video' | 'audio' | 'text' | 'json' | 'other';
interface AssetInfo {
    path: string;
    type: AssetType;
    publicPath: string;
    filePath: string;
    size: number;
    mtime: number;
}
interface CodeSnippet {
    code: string;
    lang: string;
    name: string;
    docs?: string;
}
interface ComponentRelationship {
    id: string;
    deps: string[];
}

interface TerminalBase {
    id: string;
    name: string;
    description?: string;
    icon?: string;
}
type TerminalAction = 'restart' | 'terminate' | 'clear' | 'remove';
interface SubprocessOptions extends Options {
    command: string;
    args?: string[];
}
interface TerminalInfo extends TerminalBase {
    /**
     * Whether the terminal can be restarted
     */
    restartable?: boolean;
    /**
     * Whether the terminal can be terminated
     */
    terminatable?: boolean;
    /**
     * Whether the terminal is terminated
     */
    isTerminated?: boolean;
    /**
     * Content buffer
     */
    buffer?: string;
}
interface TerminalState extends TerminalInfo {
    /**
     * User action to restart the terminal, when not provided, this action will be disabled
     */
    onActionRestart?: () => Promise<void> | void;
    /**
     * User action to terminate the terminal, when not provided, this action will be disabled
     */
    onActionTerminate?: () => Promise<void> | void;
}

interface WizardFunctions {
    enablePages: (nuxt: any) => Promise<void>;
}
type WizardActions = keyof WizardFunctions;
type GetWizardArgs<T extends WizardActions> = WizardFunctions[T] extends (nuxt: any, ...args: infer A) => any ? A : never;

interface ServerFunctions {
    getServerConfig(): NuxtOptions;
    getComponents(): Component[];
    getComponentsRelationships(): Promise<ComponentRelationship[]>;
    getAutoImports(): AutoImportsWithMetadata;
    getServerPages(): NuxtPage[];
    getCustomTabs(): ModuleCustomTab[];
    getServerHooks(): HookInfo[];
    getServerLayouts(): NuxtLayout[];
    getStaticAssets(): Promise<AssetInfo[]>;
    getServerRoutes(): Promise<ServerRouteInfo[]>;
    getServerApp(): NuxtApp | undefined;
    checkForUpdateFor(name: string): Promise<PackageUpdateInfo | undefined>;
    getPackageManager(): Promise<PackageManagerName>;
    getNpmCommand(command: NpmCommandType, packageName: string, options?: NpmCommandOptions): Promise<string[] | undefined>;
    runNpmCommand(command: NpmCommandType, packageName: string, options?: NpmCommandOptions): Promise<{
        processId: string;
    } | undefined>;
    getTerminals(): TerminalInfo[];
    getTerminalDetail(id: string): TerminalInfo | undefined;
    runTerminalAction(id: string, action: TerminalAction): Promise<boolean>;
    getStorageMounts(): Promise<StorageMounts>;
    getStorageKeys(base?: string): Promise<string[]>;
    getStorageItem(key: string): Promise<StorageValue>;
    setStorageItem(key: string, value: StorageValue): Promise<void>;
    removeStorageItem(key: string): Promise<void>;
    getImageMeta(filepath: string): Promise<ImageMeta | undefined>;
    getTextAssetContent(filepath: string, limit?: number): Promise<string | undefined>;
    writeStaticAssets(file: {
        name: string;
        data: string;
    }[], path: string): Promise<string[]>;
    customTabAction(name: string, action: number): Promise<boolean>;
    runWizard<T extends WizardActions>(name: T, ...args: GetWizardArgs<T>): Promise<void>;
    openInEditor(filepath: string): Promise<boolean>;
    restartNuxt(hard?: boolean): Promise<void>;
}
interface ClientFunctions {
    refresh(event: ClientUpdateEvent): void;
    callHook(hook: string, ...args: any[]): Promise<void>;
    navigateTo(path: string): void;
    onTerminalData(_: {
        id: string;
        data: string;
    }): void;
    onTerminalExit(_: {
        id: string;
        code?: number;
    }): void;
}
type ClientUpdateEvent = keyof ServerFunctions;

export { AutoImportsWithMetadata as A, BasicModuleInfo as B, CompatibilityStatus as C, WizardActions as D, GetWizardArgs as E, ServerFunctions as F, GitHubContributor as G, HookInfo as H, ImageMeta as I, ClientFunctions as J, ClientUpdateEvent as K, TabCategory as L, ModuleCustomTab as M, NpmCommandType as N, PackageUpdateInfo as P, RouteInfo as R, SubprocessOptions as S, TerminalState as T, VueInspectorClient as V, WizardFunctions as W, ModuleLaunchView as a, ModuleIframeView as b, ModuleVNodeView as c, ModuleLaunchAction as d, ModuleView as e, ModuleIframeTabLazyOptions as f, ModuleBuiltinTab as g, ModuleTabInfo as h, TerminalBase as i, TerminalAction as j, TerminalInfo as k, PackageManagerName as l, NpmCommandOptions as m, ServerRouteInfo as n, Payload as o, PluginInfoWithMetic as p, PluginMetric as q, ModuleMetric as r, ModuleCompatibility as s, ModuleType as t, MaintainerInfo as u, VueInspectorData as v, AssetType as w, AssetInfo as x, CodeSnippet as y, ComponentRelationship as z };
