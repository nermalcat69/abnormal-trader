import { join as join$1 } from 'node:path';
import fs$1, { existsSync } from 'node:fs';
import { useNuxt, logger, addPlugin } from '@nuxt/kit';
import { tinyws } from 'tinyws';
import { searchForWorkspaceRoot } from 'vite';
import sirv from 'sirv';
import c from 'picocolors';
import { createBirpcGroup } from 'birpc';
import fs from 'node:fs/promises';
import { resolve, join, dirname } from 'pathe';
import { imageMeta } from 'image-meta';
import fg from 'fast-glob';
import { startSubprocess } from '@nuxt/devtools-kit';
import isInstalledGlobally from 'is-installed-globally';
import { detectPackageManager } from 'nypm';
import { createRequire } from 'node:module';
import 'pkg-types';
import semver from 'semver';
import { getPackageInfo } from 'local-pkg';
import { resolveBuiltinPresets } from 'unimport';
import { debounce } from 'perfect-debounce';
import { runtimeDir, clientDir, packageDir, isGlobalInstall } from '../dirs.mjs';
import { R as ROUTE_ENTRY, a as ROUTE_CLIENT } from '../shared/devtools.23768dcf.mjs';

const version = "0.4.6";

/*! (c) 2020 Andrea Giammarchi */

const {parse: $parse, stringify: $stringify} = JSON;
const {keys} = Object;

const Primitive = String;   // it could be Number
const primitive = 'string'; // it could be 'number'

const ignore = {};
const object = 'object';

const noop = (_, value) => value;

const primitives = value => (
  value instanceof Primitive ? Primitive(value) : value
);

const Primitives = (_, value) => (
  typeof value === primitive ? new Primitive(value) : value
);

const revive = (input, parsed, output, $) => {
  const lazy = [];
  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {
    const k = ke[y];
    const value = output[k];
    if (value instanceof Primitive) {
      const tmp = input[value];
      if (typeof tmp === object && !parsed.has(tmp)) {
        parsed.add(tmp);
        output[k] = ignore;
        lazy.push({k, a: [input, parsed, tmp, $]});
      }
      else
        output[k] = $.call(output, k, tmp);
    }
    else if (output[k] !== ignore)
      output[k] = $.call(output, k, value);
  }
  for (let {length} = lazy, i = 0; i < length; i++) {
    const {k, a} = lazy[i];
    output[k] = $.call(output, k, revive.apply(null, a));
  }
  return output;
};

const set = (known, input, value) => {
  const index = Primitive(input.push(value) - 1);
  known.set(value, index);
  return index;
};

const parse = (text, reviver) => {
  const input = $parse(text, Primitives).map(primitives);
  const value = input[0];
  const $ = reviver || noop;
  const tmp = typeof value === object && value ?
              revive(input, new Set, value, $) :
              value;
  return $.call({'': tmp}, '', tmp);
};

const stringify = (value, replacer, space) => {
  const $ = replacer && typeof replacer === object ?
            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :
            (replacer || noop);
  const known = new Map;
  const input = [];
  const output = [];
  let i = +set(known, input, $.call({'': value}, '', value));
  let firstRun = !i;
  while (i < input.length) {
    firstRun = true;
    output[i] = $stringify(input[i++], replace, space);
  }
  return '[' + output.join(',') + ']';
  function replace(key, value) {
    if (firstRun) {
      firstRun = !firstRun;
      return value;
    }
    const after = $.call(this, key, value);
    switch (typeof after) {
      case object:
        if (after === null) return after;
      case primitive:
        return known.get(after) || set(known, input, after);
    }
    return after;
  }
};

const IGNORE_STORAGE_MOUNTS = ["root", "build", "src", "cache"];
function shouldIgnoreStorageKey(key) {
  return IGNORE_STORAGE_MOUNTS.includes(key.split(":")[0]);
}
function setupStorageRPC({
  nuxt,
  rpc
}) {
  const storageMounts = {};
  let storage;
  nuxt.hook("nitro:init", (nitro) => {
    storage = nitro.storage;
    nuxt.hook("ready", () => {
      storage.watch((event, key) => {
        if (shouldIgnoreStorageKey(key))
          return;
        rpc.broadcast.callHook.asEvent("storage:key:update", key, event);
      });
    });
    const mounts = {
      ...nitro.options.storage,
      ...nitro.options.devStorage
    };
    for (const name of Object.keys(mounts)) {
      if (shouldIgnoreStorageKey(name))
        continue;
      storageMounts[name] = mounts[name];
    }
  });
  return {
    async getStorageMounts() {
      return storageMounts;
    },
    async getStorageKeys(base) {
      if (!storage)
        return [];
      try {
        const keys = await storage.getKeys(base);
        return keys.filter((key) => !shouldIgnoreStorageKey(key));
      } catch (err) {
        console.error(`Cloud not fetch storage keys for ${base}:`, err);
        return [];
      }
    },
    async getStorageItem(key) {
      if (!storage)
        return null;
      return await storage.getItem(key);
    },
    async setStorageItem(key, value) {
      if (!storage)
        return;
      return await storage.setItem(key, value);
    },
    async removeStorageItem(key) {
      if (!storage)
        return;
      return await storage.removeItem(key);
    }
  };
}

function setupAssetsRPC({ nuxt }) {
  const _imageMetaCache = /* @__PURE__ */ new Map();
  return {
    async getStaticAssets() {
      const dir = resolve(nuxt.options.srcDir, nuxt.options.dir.public);
      const baseURL = nuxt.options.app.baseURL;
      const files = await fg(["**/*"], {
        cwd: dir,
        onlyFiles: true
      });
      function guessType(path) {
        if (/\.(png|jpe?g|gif|svg|webp|avif|ico|bmp|tiff?)$/i.test(path))
          return "image";
        if (/\.(mp4|webm|ogv|mov|avi|flv|wmv|mpg|mpeg|mkv|3gp|3g2|ts|mts|m2ts|vob|ogm|ogx|rm|rmvb|asf|amv|divx|m4v|svi|viv|f4v|f4p|f4a|f4b)$/i.test(path))
          return "video";
        if (/\.(mp3|wav|ogg|flac|aac|wma|alac|ape|ac3|dts|tta|opus|amr|aiff|au|mid|midi|ra|rm|wv|weba|dss|spx|vox|tak|dsf|dff|dsd|cda)$/i.test(path))
          return "audio";
        if (/\.(woff2?|eot|ttf|otf|ttc|pfa|pfb|pfm|afm)/i.test(path))
          return "font";
        if (/\.(json[5c]?|te?xt|[mc]?[jt]sx?|md[cx]?|markdown)/i.test(path))
          return "text";
        return "other";
      }
      return await Promise.all(files.map(async (path) => {
        const filePath = resolve(dir, path);
        const stat = await fs.lstat(filePath);
        return {
          path,
          publicPath: join(baseURL, path),
          filePath,
          type: guessType(path),
          size: stat.size,
          mtime: stat.mtimeMs
        };
      }));
    },
    async getImageMeta(filepath) {
      if (_imageMetaCache.has(filepath))
        return _imageMetaCache.get(filepath);
      try {
        const meta = imageMeta(await fs.readFile(filepath));
        _imageMetaCache.set(filepath, meta);
        return meta;
      } catch (e) {
        _imageMetaCache.set(filepath, void 0);
        console.error(e);
        return void 0;
      }
    },
    async getTextAssetContent(filepath, limit = 300) {
      try {
        const content = await fs.readFile(filepath, "utf-8");
        return content.slice(0, limit);
      } catch (e) {
        console.error(e);
        return void 0;
      }
    },
    async writeStaticAssets(files, path) {
      const baseDir = resolve(nuxt.options.srcDir, nuxt.options.dir.public + path);
      return await Promise.all(
        files.map(async ({ name, data }) => {
          let dir = resolve(baseDir, name);
          try {
            await fs.stat(dir);
            const ext = dir.split(".").pop();
            const base = dir.slice(0, dir.length - ext.length - 1);
            let i = 1;
            while (await fs.access(`${base}-${i}.${ext}`).then(() => true).catch(() => false))
              i++;
            dir = `${base}-${i}.${ext}`;
          } catch (err) {
          }
          await fs.writeFile(dir, data, "base64");
          return dir;
        })
      );
    }
  };
}

async function checkForUpdateOf(name, current, nuxt = useNuxt()) {
  if (!current) {
    const require = createRequire(nuxt.options.rootDir);
    const info = await getPackageInfo(name, { paths: require.resolve.paths(name) || void 0 });
    if (!info)
      return;
    current = info.packageJson.version;
  }
  const packument = await import('pacote').then((r) => r.default?.packument || r.packument);
  const manifest = await packument(name);
  const latest = manifest["dist-tags"].latest;
  const needsUpdate = latest !== current && semver.lt(current, latest);
  return {
    name,
    current,
    latest,
    needsUpdate
  };
}

function setupNpmRPC({ nuxt }) {
  let detectPromise;
  const updatesPromise = /* @__PURE__ */ new Map();
  function getPackageManager() {
    detectPromise || (detectPromise = detectPackageManager(nuxt.options.rootDir).then((r) => r?.name || "npm"));
    return detectPromise;
  }
  async function getNpmCommand(command, packageName, options = {}) {
    const {
      dev = true,
      global = packageName === "@nuxt/devtools" && isInstalledGlobally
    } = options;
    const agent = await getPackageManager();
    if (command === "install" || command === "update")
      return [agent, agent === "npm" ? "install" : "add", `${packageName}@latest`, dev ? "-D" : "", global ? "-g" : "", "--ignore-scripts"].filter(Boolean);
  }
  async function runNpmCommand(command, packageName, options = {}) {
    const args = await getNpmCommand(command, packageName, options);
    if (!args)
      return;
    const processId = `npm:${command}:${packageName}`;
    startSubprocess({
      command: args[0],
      args: args.slice(1)
    }, {
      id: processId,
      name: `${command} ${packageName}`,
      icon: "i-mdi-npm-variant-outline text-rose",
      restartable: false
    });
    return {
      processId
    };
  }
  return {
    checkForUpdateFor(name) {
      if (!updatesPromise.has(name))
        updatesPromise.set(name, checkForUpdateOf(name, void 0, nuxt));
      return updatesPromise.get(name);
    },
    getPackageManager,
    getNpmCommand,
    runNpmCommand
  };
}

function setupCustomTabRPC({ nuxt, options, refresh }) {
  const iframeTabs = [];
  const customTabs = [];
  if (options.customTabs?.length)
    customTabs.push(...options.customTabs);
  async function initHooks() {
    nuxt.hook("devtools:customTabs:refresh", initCustomTabs);
    await initCustomTabs();
  }
  async function initCustomTabs() {
    customTabs.length = 0;
    if (options.customTabs?.length)
      customTabs.push(...options.customTabs);
    await nuxt.callHook("devtools:customTabs", customTabs);
    refresh("getCustomTabs");
  }
  nuxt.hook("app:resolve", async () => {
    await initHooks();
  });
  return {
    getCustomTabs() {
      return [
        ...iframeTabs,
        ...customTabs
      ].map((i) => {
        i.category = i.category || "modules";
        return i;
      });
    },
    async customTabAction(name, actionIndex) {
      const tab = customTabs.find((i) => i.name === name);
      if (!tab)
        return false;
      const view = tab.view;
      if (view.type !== "launch")
        return false;
      const action = view.actions?.[actionIndex];
      if (!action)
        return false;
      Promise.resolve(action.handle?.()).catch((e) => {
        console.error(e);
      }).finally(() => {
        nuxt.callHook("devtools:customTabs:refresh");
      });
      nuxt.callHook("devtools:customTabs:refresh");
      return true;
    }
  };
}

function setupHooksDebug(hooks) {
  const serverHooks = {};
  const now = typeof globalThis.performance === "undefined" ? () => Date.now() : () => performance.now();
  hooks.beforeEach((event) => {
    if (!serverHooks[event.name]) {
      serverHooks[event.name] = {
        name: event.name,
        start: now(),
        // @ts-expect-error private field
        listeners: hooks._hooks[event.name]?.length || 0,
        executions: []
      };
    } else {
      const hook = serverHooks[event.name];
      if (hook.duration != null)
        hook.executions.push(hook.duration);
      hook.start = now();
      hook.end = void 0;
      hook.duration = void 0;
    }
  });
  hooks.afterEach((event) => {
    const hook = serverHooks[event.name];
    if (!hook)
      return;
    hook.end = now();
    hook.duration = hook.end - hook.start;
    const listeners = hooks._hooks[event.name]?.length;
    if (listeners != null)
      hook.listeners = listeners;
  });
  return serverHooks;
}

function setupGeneralRPC({ nuxt, refresh, openInEditorHooks }) {
  const components = [];
  const imports = [];
  const importPresets = [];
  let importDirs = [];
  const serverPages = [];
  let serverApp;
  const serverHooks = setupHooksDebug(nuxt.hooks);
  let unimport;
  let app;
  nuxt.hook("components:extend", (v) => {
    components.length = 0;
    components.push(...v);
    components.sort((a, b) => a.pascalName.localeCompare(b.pascalName));
    refresh("getComponents");
  });
  nuxt.hook("imports:extend", (v) => {
    imports.length = 0;
    imports.push(...v);
    refresh("getAutoImports");
  });
  nuxt.hook("pages:extend", (v) => {
    serverPages.length = 0;
    const pagesSet = new Set(v);
    function searchChildren(page) {
      if (pagesSet.has(page))
        return;
      pagesSet.add(page);
      page.children?.forEach(searchChildren);
    }
    v.forEach(searchChildren);
    serverPages.push(...Array.from(pagesSet).sort((a, b) => a.path.localeCompare(b.path)));
    refresh("getServerPages");
  });
  nuxt.hook("app:resolve", (app2) => {
    serverApp = app2;
  });
  nuxt.hook("imports:sources", async (v) => {
    const result = (await resolveBuiltinPresets(v)).flat();
    importPresets.length = 0;
    importPresets.push(...result);
    refresh("getAutoImports");
  });
  nuxt.hook("imports:context", (_unimport) => {
    unimport = _unimport;
  });
  nuxt.hook("imports:dirs", (dirs) => {
    importDirs = dirs;
  });
  nuxt.hook("app:resolve", (v) => {
    app = v;
  });
  return {
    getServerConfig() {
      return nuxt.options;
    },
    getServerApp() {
      return serverApp;
    },
    getComponents() {
      return components;
    },
    async getComponentsRelationships() {
      return [];
    },
    getServerPages() {
      return serverPages;
    },
    getAutoImports() {
      return {
        imports: [
          ...imports,
          ...importPresets
        ],
        metadata: unimport?.getMetadata(),
        dirs: importDirs
      };
    },
    getServerLayouts() {
      return Object.values(app?.layouts || []);
    },
    getServerHooks() {
      return Object.values(serverHooks);
    },
    async openInEditor(input) {
      if (input.startsWith("./"))
        input = resolve(process.cwd(), input);
      const match = input.match(/^(.*?)(:[:\d]*)$/);
      let suffix = "";
      if (match) {
        input = match[1];
        suffix = match[2];
      }
      const path = [
        input,
        `${input}.js`,
        `${input}.mjs`,
        `${input}.ts`
      ].find((i) => existsSync(i));
      if (!path) {
        console.error("File not found:", input);
        return false;
      }
      try {
        for (const hook of openInEditorHooks) {
          const result = await hook(path);
          if (result)
            return true;
        }
        await import('launch-editor').then((r) => (r.default || r)(path + suffix));
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    },
    restartNuxt(hard = true) {
      logger.info("Restarting Nuxt...");
      return nuxt.callHook("restart", { hard });
    }
  };
}

const pagesIndexTemplate = `<script setup lang="ts">
const route = useRoute()
<\/script>

<template>
  <div>
    <h1>Nuxt Routing set up successfully!</h1>
    <p>Current route: {{ route.path }}</p>
    <a href="https://nuxt.com/docs/getting-started/routing" target="_blank">Learn more about Nuxt Routing</a>
  </div>
</template>
`;
async function enablePages(nuxt) {
  const pathApp = join(nuxt.options.srcDir, "app.vue");
  const pathPageIndex = join(nuxt.options.srcDir, "pages/index.vue");
  if (fs$1.existsSync(pathPageIndex)) {
    logger.warn("pages/index.vue already exists, skipping");
    return;
  }
  let appContent = fs$1.existsSync(pathApp) ? await fs.readFile(pathApp, "utf-8") : void 0;
  await fs.mkdir(dirname(pathPageIndex), { recursive: true });
  await fs.writeFile(pathPageIndex, pagesIndexTemplate, "utf-8");
  if (appContent && !appContent.includes("<NuxtPage")) {
    appContent = appContent.replace("</template>", "  <NuxtPage />\n</template>").replace(/<NuxtWelcome\s*\/>/, "");
    await fs.writeFile(pathApp, appContent, "utf-8");
  }
  logger.success("Routing creation wizard completed");
}

const wizard = {
  enablePages
};

const LOG_PREFIX = c.cyan("Nuxt DevTools:");

function setupWizardRPC({ nuxt }) {
  return {
    runWizard(name, ...args) {
      logger.info(LOG_PREFIX, `Running wizard ${c.green(name)}...`);
      return wizard[name](nuxt, ...args);
    }
  };
}

function setupTerminalRPC({ nuxt, rpc, refresh }) {
  const terminals = /* @__PURE__ */ new Map();
  nuxt.hook("devtools:terminal:register", (terminal) => {
    terminals.set(terminal.id, terminal);
    refresh("getTerminals");
    return terminal.id;
  });
  nuxt.hook("devtools:terminal:remove", ({ id }) => {
    if (!terminals.has(id))
      return false;
    terminals.delete(id);
    refresh("getTerminals");
    return true;
  });
  nuxt.hook("devtools:terminal:write", ({ id, data }) => {
    const terminal = terminals.get(id);
    if (!terminal)
      return false;
    terminal.buffer || (terminal.buffer = "");
    terminal.buffer += data;
    rpc.broadcast.onTerminalData.asEvent({ id, data });
    return true;
  });
  nuxt.hook("devtools:terminal:exit", ({ id, code }) => {
    const terminal = terminals.get(id);
    if (!terminal)
      return false;
    terminal.isTerminated = true;
    rpc.broadcast.onTerminalExit.asEvent({ id, code });
    refresh("getTerminals");
    return true;
  });
  function serializeTerminal(terminal, buffer = false) {
    if (!terminal)
      return;
    return {
      id: terminal.id,
      name: terminal.name,
      description: terminal.description,
      icon: terminal.icon,
      terminatable: terminal.terminatable ?? !!terminal.onActionTerminate,
      restartable: terminal.restartable ?? !!terminal.onActionRestart,
      isTerminated: terminal.isTerminated,
      buffer: buffer ? terminal.buffer : void 0
    };
  }
  return {
    getTerminals() {
      return Array.from(terminals.values()).map((i) => serializeTerminal(i));
    },
    getTerminalDetail(id) {
      return serializeTerminal(terminals.get(id), true);
    },
    async runTerminalAction(id, action) {
      const terminal = terminals.get(id);
      if (!terminal)
        return false;
      switch (action) {
        case "restart":
          if (!terminal.onActionRestart)
            return false;
          await terminal.onActionRestart();
          return true;
        case "terminate":
          if (!terminal.onActionTerminate)
            return false;
          await terminal.onActionTerminate();
          return true;
        case "remove":
          if (!terminal.isTerminated)
            terminal.onActionTerminate?.();
          terminals.delete(id);
          refresh("getTerminals");
          return true;
        case "clear":
          terminal.buffer = "";
          refresh("getTerminals");
          return true;
      }
    }
  };
}

const PROTOCOL_STRICT_REGEX = /^\w{2,}:([/\\]{1,2})/;
const PROTOCOL_REGEX = /^\w{2,}:([/\\]{2})?/;
const PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
function hasProtocol(inputString, opts = {}) {
  if (typeof opts === "boolean") {
    opts = { acceptRelative: opts };
  }
  if (opts.strict) {
    return PROTOCOL_STRICT_REGEX.test(inputString);
  }
  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
}
const TRAILING_SLASH_RE = /\/$|\/\?/;
function hasTrailingSlash(input = "", queryParameters = false) {
  if (!queryParameters) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE.test(input);
}
function withoutTrailingSlash(input = "", queryParameters = false) {
  if (!queryParameters) {
    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
  }
  if (!hasTrailingSlash(input, true)) {
    return input || "/";
  }
  const [s0, ...s] = input.split("?");
  return (s0.slice(0, -1) || "/") + (s.length > 0 ? `?${s.join("?")}` : "");
}
function withTrailingSlash(input = "", queryParameters = false) {
  if (!queryParameters) {
    return input.endsWith("/") ? input : input + "/";
  }
  if (hasTrailingSlash(input, true)) {
    return input || "/";
  }
  const [s0, ...s] = input.split("?");
  return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "");
}
function hasLeadingSlash(input = "") {
  return input.startsWith("/");
}
function withoutLeadingSlash(input = "") {
  return (hasLeadingSlash(input) ? input.slice(1) : input) || "/";
}
function withLeadingSlash(input = "") {
  return hasLeadingSlash(input) ? input : "/" + input;
}
function withBase(input, base) {
  if (isEmptyURL(base) || hasProtocol(input)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (input.startsWith(_base)) {
    return input;
  }
  return joinURL(_base, input);
}
function isEmptyURL(url) {
  return !url || url === "/";
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
function joinURL(base, ...input) {
  let url = base || "";
  for (const index of input.filter((url2) => isNonEmptyURL(url2))) {
    url = url ? withTrailingSlash(url) + withoutLeadingSlash(index) : index;
  }
  return url;
}

function setupServerRoutesRPC({ nuxt, refresh }) {
  let nitro;
  let promiseCache = null;
  const refreshDebounced = debounce(() => {
    promiseCache = null;
    refresh("getServerRoutes");
  }, 500);
  nuxt.hook("nitro:init", (_) => {
    nitro = _;
    promiseCache = null;
    refresh("getServerRoutes");
  });
  nuxt.hook("ready", () => {
    nitro?.storage.watch((event, key) => {
      if (key.startsWith("src:api:"))
        refreshDebounced();
    });
  });
  function scan() {
    if (promiseCache)
      return promiseCache;
    promiseCache = (async () => {
      if (!nitro)
        return [];
      const files = await Promise.all([
        scanServerDir(nitro, "api", scanFileHandler("api")),
        scanServerDir(nitro, "routes", scanFileHandler("route"))
      ]).then((r) => r.flat());
      return files;
    })();
    return promiseCache;
  }
  return {
    async getServerRoutes() {
      return scan();
    }
  };
}
const GLOB_SCAN_PATTERN = "**/*.{ts,mjs,js,cjs}";
const httpMethodRegex = /\.(connect|delete|get|head|options|patch|post|put|trace)/;
function scanFileHandler(type, prefix = "/") {
  return (file) => {
    let route = file.path.replace(/\.[A-Za-z]+$/, "").replace(/\[\.{3}]/g, "**").replace(/\[\.{3}(\w+)]/g, "**:$1").replace(/\[(\w+)]/g, ":$1");
    route = withLeadingSlash(withoutTrailingSlash(withBase(route, prefix)));
    let method;
    const methodMatch = route.match(httpMethodRegex);
    if (methodMatch) {
      route = route.slice(0, Math.max(0, methodMatch.index));
      method = methodMatch[1];
    }
    route = route.replace(/\/index$/, "") || "/";
    if (type === "api")
      route = `/api${route}`;
    return {
      filepath: file.fullPath,
      path: file.path,
      route,
      type,
      method
    };
  };
}
async function scanServerDir(nitro, name, mapper) {
  const dirs = nitro.options.scanDirs.map((dir) => join(dir, name));
  const files = await scanDirs(dirs);
  return files.map((f) => mapper(f));
}
function scanDirs(dirs) {
  return Promise.all(
    dirs.map(async (dir) => {
      const fileNames = await fg(GLOB_SCAN_PATTERN, {
        cwd: dir,
        dot: true
      });
      return fileNames.map((fileName) => {
        return {
          dir,
          path: fileName,
          fullPath: resolve(dir, fileName)
        };
      }).sort((a, b) => a.path.localeCompare(b.path));
    })
  ).then((r) => r.flat());
}

function setupRPC(nuxt, options) {
  const serverFunctions = {};
  const extendedRpcMap = /* @__PURE__ */ new Map();
  const rpc = createBirpcGroup(
    serverFunctions,
    [],
    {
      resolver: (name, fn) => {
        if (fn)
          return fn;
        if (!name.includes(":"))
          return;
        const [namespace, fnName] = name.split(":");
        return extendedRpcMap.get(namespace)?.[fnName];
      },
      onError(error, name) {
        console.error(`[nuxt-devtools] RPC error on executing "${name}":`, error);
      }
    }
  );
  function refresh(event) {
    rpc.broadcast.refresh.asEvent(event);
  }
  function extendServerRpc(namespace, functions) {
    extendedRpcMap.set(namespace, functions);
    return {
      broadcast: new Proxy({}, {
        get: (_, key) => {
          if (typeof key !== "string")
            return;
          return rpc.broadcast[`${namespace}:${key}`];
        }
      })
    };
  }
  const ctx = {
    nuxt,
    options,
    rpc,
    refresh,
    extendServerRpc,
    openInEditorHooks: []
  };
  nuxt.devtools = ctx;
  Object.assign(serverFunctions, {
    ...setupGeneralRPC(ctx),
    ...setupCustomTabRPC(ctx),
    ...setupStorageRPC(ctx),
    ...setupAssetsRPC(ctx),
    ...setupNpmRPC(ctx),
    ...setupWizardRPC(ctx),
    ...setupTerminalRPC(ctx),
    ...setupServerRoutesRPC(ctx)
  });
  const wsClients = /* @__PURE__ */ new Set();
  const middleware = async (req, _res, next) => {
    if (req.ws) {
      const ws = await req.ws();
      wsClients.add(ws);
      const channel = {
        post: (d) => ws.send(d),
        on: (fn) => ws.on("message", fn),
        serialize: stringify,
        deserialize: parse
      };
      rpc.updateChannels((c) => {
        c.push(channel);
      });
      ws.on("close", () => {
        wsClients.delete(ws);
        rpc.updateChannels((c) => {
          const index = c.indexOf(channel);
          if (index >= 0)
            c.splice(index, 1);
        });
      });
    } else {
      next();
    }
  };
  return {
    middleware,
    ...ctx
  };
}

async function enableModule(options, nuxt) {
  if (process.env.TEST || process.env.NODE_ENV === "test")
    return;
  if (!nuxt.options.dev)
    return;
  if (nuxt.options.builder !== "@nuxt/vite-builder") {
    logger.warn("Nuxt Devtools only supports Vite mode, module is disabled.");
    return;
  }
  await nuxt.callHook("devtools:before");
  nuxt.options.imports.collectMeta = true;
  addPlugin({
    src: join$1(runtimeDir, "plugins/devtools.client"),
    mode: "client"
  });
  const {
    middleware: rpcMiddleware,
    ...ctx
  } = setupRPC(nuxt, options);
  const clientDirExists = existsSync(clientDir);
  nuxt.hook("vite:extendConfig", (config) => {
    var _a, _b;
    config.server || (config.server = {});
    (_a = config.server).fs || (_a.fs = {});
    (_b = config.server.fs).allow || (_b.allow = [
      searchForWorkspaceRoot(process.cwd())
    ]);
    config.server.fs.allow.push(packageDir);
  });
  nuxt.hook("vite:serverCreated", (server) => {
    server.middlewares.use(ROUTE_ENTRY, tinyws());
    server.middlewares.use(ROUTE_ENTRY, rpcMiddleware);
    if (clientDirExists)
      server.middlewares.use(ROUTE_CLIENT, sirv(clientDir, { single: true, dev: true }));
  });
  const integrations = [
    import('./plugin-metrics.mjs').then(({ setup }) => setup(ctx)),
    options.viteInspect !== false ? import('./vite-inspect.mjs').then(({ setup }) => setup(ctx)) : null,
    options.componentInspector !== false ? import('./vue-inspector.mjs').then(({ setup }) => setup(ctx)) : null,
    options.vscode?.enabled ? import('./vscode.mjs').then(({ setup }) => setup(ctx)) : null
  ];
  await Promise.all(integrations);
  await nuxt.callHook("devtools:initialized", {
    version,
    packagePath: packageDir,
    isGlobalInstall: isGlobalInstall()
  });
  logger.success(`Nuxt Devtools is enabled ${c.dim(`v${version}`)}${isGlobalInstall() ? c.dim("[global]") : ""} ${c.yellow("(experimental)")}`);
}

const moduleMain = {
  __proto__: null,
  enableModule: enableModule
};

export { LOG_PREFIX as L, moduleMain as m };
