import { createApp } from "vue";
import { defu } from "defu";
import { callWithNuxt } from "#app";
import ContentPreviewMode from "../components/ContentPreviewMode.vue";
import { createSingleton, deepAssign, deepDelete, mergeDraft, StudioConfigFiles, StudioConfigRoot } from "../utils/index.mjs";
import { refreshNuxtData, useAppConfig, useNuxtApp, useRuntimeConfig, useState, useContentState, queryContent, ref, toRaw, useRoute, useRouter } from "#imports";
const useDefaultAppConfig = createSingleton(() => JSON.parse(JSON.stringify(useAppConfig())));
export const useStudio = () => {
  const nuxtApp = useNuxtApp();
  const { studio: studioConfig, content: contentConfig } = useRuntimeConfig().public;
  const route = useRoute();
  const initialAppConfig = useDefaultAppConfig();
  let initialTokensConfig;
  const storage = useState("studio-client-db", () => null);
  const dbFiles = useState("studio-preview-db-files", () => []);
  if (!storage.value) {
    nuxtApp.hook("content:storage", (_storage) => {
      storage.value = _storage;
    });
    queryContent("/non-existing-path").findOne();
  }
  const syncPreviewFiles = async (contentStorage, files, ignoreBuiltContents = true) => {
    const previewToken = window.sessionStorage.getItem("previewToken");
    const keys = await contentStorage.getKeys(`${previewToken}:`);
    await Promise.all(keys.map((key) => contentStorage.removeItem(key)));
    const sources = new Set(files.map((file) => file.parsed._id.split(":").shift()));
    await contentStorage.setItem(`${previewToken}$`, JSON.stringify({ ignoreSources: Array.from(sources) }));
    await Promise.all(
      files.map((item) => contentStorage.setItem(`${previewToken}:${item.parsed._id}`, JSON.stringify(item.parsed)))
    );
  };
  const syncPreviewAppConfig = (appConfig) => {
    const _appConfig = callWithNuxt(nuxtApp, useAppConfig);
    deepAssign(_appConfig, defu(appConfig, initialAppConfig));
    if (!appConfig) {
      deepDelete(_appConfig, initialAppConfig);
    }
  };
  const syncPreviewTokensConfig = (tokensConfig) => {
    const themeSheet = nuxtApp?.vueApp?._context?.config?.globalProperties?.$pinceauTheme;
    if (!themeSheet || !themeSheet?.updateTheme) {
      return;
    }
    if (!initialTokensConfig) {
      initialTokensConfig = JSON.parse(JSON.stringify(themeSheet?.theme.value || {}));
    }
    callWithNuxt(
      nuxtApp,
      themeSheet.updateTheme,
      [
        // Using `defu` to merge with initial tokens
        // This is important to revert to default values for missing properties
        defu(tokensConfig, initialTokensConfig)
      ]
    );
  };
  const syncPreview = async (data) => {
    dbFiles.value = data.files = data.files || dbFiles.value || [];
    if (!storage.value) {
      return false;
    }
    const mergedFiles = mergeDraft(data.files, data.additions, data.deletions);
    const contentFiles = mergedFiles.filter((item) => !item.path.startsWith(StudioConfigRoot));
    await syncPreviewFiles(storage.value, contentFiles, (data.files || []).length !== 0);
    const appConfig = mergedFiles.find((item) => item.path === StudioConfigFiles.appConfig);
    syncPreviewAppConfig(appConfig?.parsed);
    const tokensConfig = mergedFiles.find((item) => item.path === StudioConfigFiles.tokensConfig);
    syncPreviewTokensConfig(tokensConfig?.parsed);
    requestRerender();
    return true;
  };
  const requestPreviewSynchronization = async () => {
    const previewToken = window.sessionStorage.getItem("previewToken");
    await $fetch("api/projects/preview/sync", {
      baseURL: studioConfig?.apiURL,
      method: "POST",
      params: {
        token: previewToken
      }
    });
  };
  const mountPreviewUI = () => {
    const previewToken = window.sessionStorage.getItem("previewToken");
    const el = document.createElement("div");
    el.id = "__nuxt_preview_wrapper";
    document.body.appendChild(el);
    createApp(ContentPreviewMode, {
      previewToken,
      apiURL: studioConfig?.apiURL,
      syncPreview,
      requestPreviewSyncAPI: requestPreviewSynchronization
    }).mount(el);
  };
  const findContentWithId = async (path) => {
    const previewToken = window.sessionStorage.getItem("previewToken");
    if (!path) {
      return null;
    }
    path = path.replace(/\/$/, "");
    let content = await storage.value?.getItem(`${previewToken}:${path}`);
    if (!content) {
      content = await storage.value?.getItem(`cached:${path}`);
    }
    if (!content) {
      content = content = await storage.value?.getItem(path);
    }
    return content;
  };
  const updateContent = (content) => {
    const previewToken = window.sessionStorage.getItem("previewToken");
    if (!storage.value) {
      return;
    }
    storage.value.setItem(`${previewToken}:${content.parsed?._id}`, JSON.stringify(content.parsed));
  };
  const removeContentWithId = async (path) => {
    const previewToken = window.sessionStorage.getItem("previewToken");
    await storage.value?.removeItem(`${previewToken}:${path}`);
  };
  const requestRerender = async () => {
    if (contentConfig?.documentDriven) {
      const { pages } = callWithNuxt(nuxtApp, useContentState);
      for (const key in pages.value) {
        if (pages.value[key]) {
          pages.value[key] = await findContentWithId(pages.value[key]._id);
        }
      }
    }
    callWithNuxt(nuxtApp, refreshNuxtData);
  };
  return {
    apiURL: studioConfig?.apiURL,
    contentStorage: storage,
    syncPreviewFiles,
    syncPreviewAppConfig,
    syncPreviewTokensConfig,
    requestPreviewSynchronization,
    findContentWithId,
    updateContent,
    removeContentWithId,
    requestRerender,
    mountPreviewUI,
    initiateIframeCommunication
  };
  function initiateIframeCommunication() {
    if (!window.parent || window.self === window.parent) {
      return;
    }
    const router = useRouter();
    const editorSelectedPath = ref("");
    const isDocumentDrivenInitialHook = ref(true);
    const routePayload = (route2) => ({
      path: route2.path,
      query: toRaw(route2.query),
      params: toRaw(route2.params),
      fullPath: route2.fullPath,
      meta: toRaw(route2.meta)
    });
    window.addEventListener("keydown", (e) => {
      if (e.metaKey || e.ctrlKey || e.altKey || e.shiftKey) {
        window.parent.postMessage({
          type: "nuxt-studio:preview:keydown",
          payload: {
            key: e.key,
            metaKey: e.metaKey,
            ctrlKey: e.ctrlKey,
            shiftKey: e.shiftKey,
            altKey: e.altKey
          }
        }, "*");
      }
    });
    window.addEventListener("message", async (e) => {
      const { type, payload = {} } = e.data || {};
      switch (type) {
        case "nuxt-studio:editor:file-selected": {
          const content = await findContentWithId(payload.path);
          if (!content) {
          } else if (content._partial) {
          } else if (content._path !== useRoute().path) {
            editorSelectedPath.value = content._path;
            router.push(content._path);
          }
          break;
        }
        case "nuxt-studio:editor:file-changed": {
          const { additions = [], deletions = [] } = payload;
          for (const addition of additions) {
            await updateContent(addition);
          }
          for (const deletion of deletions) {
            await removeContentWithId(deletion.path);
          }
          requestRerender();
          break;
        }
        case "nuxt-studio:preview:sync": {
          syncPreview(payload);
          break;
        }
        case "nuxt-studio:config:file-changed": {
          const { additions = [], deletions = [] } = payload;
          const appConfig = additions.find((item) => item.path === StudioConfigFiles.appConfig);
          if (appConfig) {
            syncPreviewAppConfig(appConfig?.parsed);
          }
          const shouldRemoveAppConfig = deletions.find((item) => item.path === StudioConfigFiles.appConfig);
          if (shouldRemoveAppConfig) {
            syncPreviewAppConfig(void 0);
          }
          const tokensConfig = additions.find((item) => item.path === StudioConfigFiles.tokensConfig);
          if (tokensConfig) {
            syncPreviewTokensConfig(tokensConfig?.parsed);
          }
          const shouldRemoveTokensConfig = deletions.find((item) => item.path === StudioConfigFiles.tokensConfig);
          if (shouldRemoveTokensConfig) {
            syncPreviewTokensConfig(void 0);
          }
          break;
        }
      }
    });
    nuxtApp.hook("page:finish", () => {
      detectRenderedContents();
    });
    nuxtApp.hook("content:document-driven:finish", ({ route: route2, page }) => {
      route2.meta.studio_page_contentId = page?._id;
    });
    nuxtApp.hook("nuxt-studio:preview:ready", () => {
      window.parent.postMessage({
        type: "nuxt-studio:preview:ready",
        payload: routePayload(useRoute())
      }, "*");
      setTimeout(() => {
        detectRenderedContents();
      }, 100);
    });
    function detectRenderedContents() {
      const renderedContents = Array.from(window.document.querySelectorAll("[data-content-id]")).map((el) => el.getAttribute("data-content-id"));
      const contentIds = Array.from(/* @__PURE__ */ new Set([route.meta.studio_page_contentId, ...renderedContents])).filter(Boolean);
      if (editorSelectedPath.value === contentIds[0]) {
        editorSelectedPath.value = "";
        return;
      }
      window.openContentInStudioEditor(contentIds, { navigate: true, pageContentId: route.meta.studio_page_contentId });
    }
    window.openContentInStudioEditor = (contentIds, data = {}) => {
      window.parent.postMessage({
        type: "nuxt-studio:preview:navigate",
        payload: {
          ...routePayload(route),
          contentIds,
          ...data
        }
      }, "*");
    };
  }
};
