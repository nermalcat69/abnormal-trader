import * as recast from 'recast';
import { Options } from 'recast';
import { Node } from 'estree';
export { Node as ESNode } from 'estree';

interface Loc {
    start?: {
        line?: number;
        column?: number;
        token?: number;
    };
    end?: {
        line?: number;
        column?: number;
        token?: number;
    };
    lines?: any;
}
interface Token {
    type: string;
    value: string;
    loc?: Loc;
}
interface ProgramNode extends recast.types.ASTNode {
    type: "Program";
    body: Node[];
    sourceType: "script" | "module";
    loc: Loc;
    errors: any[];
}
interface ParsedFileNode extends recast.types.ASTNode {
    type: "file";
    program: ProgramNode;
    name?: string;
    loc: Loc;
    comments: null | any;
}

declare class ModuleNode {
    node: ParsedFileNode;
    constructor(node: ParsedFileNode);
    get exports(): Record<string, GenericNode>;
}
declare class GenericNode {
    node: Node;
    constructor(node: Node);
    get type(): "Program" | "CatchClause" | "ClassBody" | "Identifier" | "Literal" | "MethodDefinition" | "PrivateIdentifier" | "Property" | "PropertyDefinition" | "SpreadElement" | "Super" | "SwitchCase" | "TemplateElement" | "VariableDeclarator" | "ArrayExpression" | "ArrowFunctionExpression" | "AssignmentExpression" | "AwaitExpression" | "BinaryExpression" | "CallExpression" | "ChainExpression" | "ClassExpression" | "ConditionalExpression" | "FunctionExpression" | "ImportExpression" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "NewExpression" | "ObjectExpression" | "SequenceExpression" | "TaggedTemplateExpression" | "TemplateLiteral" | "ThisExpression" | "UnaryExpression" | "UpdateExpression" | "YieldExpression" | "ClassDeclaration" | "FunctionDeclaration" | "ImportDeclaration" | "ExportNamedDeclaration" | "ExportDefaultDeclaration" | "ExportAllDeclaration" | "ImportSpecifier" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ExportSpecifier" | "ObjectPattern" | "ArrayPattern" | "RestElement" | "AssignmentPattern" | "ExpressionStatement" | "BlockStatement" | "StaticBlock" | "EmptyStatement" | "DebuggerStatement" | "WithStatement" | "ReturnStatement" | "LabeledStatement" | "BreakStatement" | "ContinueStatement" | "IfStatement" | "SwitchStatement" | "ThrowStatement" | "TryStatement" | "WhileStatement" | "DoWhileStatement" | "ForStatement" | "ForInStatement" | "ForOfStatement" | "VariableDeclaration";
    get props(): Record<string, GenericNode>;
    get arguments(): GenericNode[];
    get(key: string): {} | undefined;
    push(value: string | number | boolean | RegExp | bigint | null): {} | undefined;
}

declare function parseCode(code: string, options?: Options): ModuleNode;
declare function generateCode(module: ModuleNode, options?: Options): {
    code: string;
    map?: any;
};
declare function loadFile(filename: string, options?: Options): Promise<ModuleNode>;
declare function writeFile(node: ModuleNode, filename?: string, options?: Options): Promise<void>;

export { GenericNode, Loc, ModuleNode, ParsedFileNode, ProgramNode, Token, generateCode, loadFile, parseCode, writeFile };
