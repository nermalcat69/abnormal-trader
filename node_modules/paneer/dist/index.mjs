import { promises } from 'node:fs';
import * as recast from 'recast';
import { parse, print } from 'recast';
import babelParser from '@babel/parser';

class ModuleNode {
  constructor(node) {
    this.node = node;
  }
  get exports() {
    const _exports = {};
    for (const n of this.node.program.body) {
      if (n.type === "ExportNamedDeclaration") {
        if (n.declaration && "declarations" in n.declaration) {
          const dec = n.declaration.declarations[0];
          if ("name" in dec.id) {
            _exports[dec.id.name] = new GenericNode(n.declaration);
          }
        }
      } else if (n.type === "ExportDefaultDeclaration") {
        _exports.default = new GenericNode(n.declaration);
      }
    }
    return _exports;
  }
}
class GenericNode {
  constructor(node) {
    this.node = node;
  }
  get type() {
    return this.node.type;
  }
  get props() {
    if (!("properties" in this.node)) {
      return {};
    }
    const props = [];
    for (const prop of this.node.properties) {
      if ("key" in prop && "name" in prop.key) {
        props.push([prop.key.name, new GenericNode(prop.value)]);
      }
    }
    return Object.fromEntries(props);
  }
  get arguments() {
    if (!("arguments" in this.node)) {
      return [];
    }
    return this.node.arguments.map((arg) => new GenericNode(arg));
  }
  get(key) {
    if (!("properties" in this.node)) {
      return {};
    }
    for (const prop of this.node.properties) {
      if ("key" in prop && "name" in prop.key && prop.key.name === key) {
        return prop;
      }
    }
  }
  push(value) {
    if (!("elements" in this.node)) {
      return {};
    }
    const literal = recast.types.builders.literal(value);
    this.node.elements.push(
      literal
      /* ts expects expresion */
    );
  }
}

function getBabelParser() {
  const babelOptions = _getBabelOptions();
  return {
    parse(source, options) {
      return babelParser.parse(source, {
        ...babelOptions,
        ...options
      });
    }
  };
}
function _getBabelOptions() {
  return {
    sourceType: "module",
    strictMode: false,
    allowImportExportEverywhere: true,
    allowReturnOutsideFunction: true,
    startLine: 1,
    tokens: true,
    plugins: [
      "asyncGenerators",
      "bigInt",
      "classPrivateMethods",
      "classPrivateProperties",
      "classProperties",
      "classStaticBlock",
      "decimal",
      "decorators-legacy",
      "doExpressions",
      "dynamicImport",
      "exportDefaultFrom",
      "exportExtensions",
      "exportNamespaceFrom",
      "functionBind",
      "functionSent",
      "importAssertions",
      "importMeta",
      "nullishCoalescingOperator",
      "numericSeparator",
      "objectRestSpread",
      "optionalCatchBinding",
      "optionalChaining",
      [
        "pipelineOperator",
        {
          proposal: "minimal"
        }
      ],
      [
        "recordAndTuple",
        {
          syntaxType: "hash"
        }
      ],
      "throwExpressions",
      "topLevelAwait",
      "v8intrinsic",
      "jsx",
      "typescript"
    ]
  };
}

function parseCode(code, options) {
  const node = parse(code, {
    parser: options?.parser || getBabelParser(),
    ...options
  });
  return new ModuleNode(node);
}
function generateCode(module, options) {
  const { code, map } = print(module.node, {
    ...options
  });
  return { code, map };
}
async function loadFile(filename, options = {}) {
  const contents = await promises.readFile(filename, "utf8");
  options.sourceFileName = options.sourceFileName ?? filename;
  return parseCode(contents, options);
}
async function writeFile(node, filename, options) {
  const { code, map } = generateCode(node, options);
  filename = filename || node.node.name || "output.js";
  await promises.writeFile(filename, code);
  if (map) {
    await promises.writeFile(filename + ".map", map);
  }
}

export { GenericNode, ModuleNode, generateCode, loadFile, parseCode, writeFile };
