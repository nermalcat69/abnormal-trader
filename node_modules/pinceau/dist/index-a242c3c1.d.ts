import { ViteDevServer } from 'vite';
import { GeneratedPinceauTheme, GeneratedPinceauPaths } from '#pinceau/theme';
import { GeneratedPinceauUtils } from '#pinceau/utils';
import { Schema } from 'untyped';
import * as CSSType from 'csstype';

declare const RESOLVED_ID_RE: RegExp;
declare function usePinceauVirtualStore(): {
    readonly outputs: Record<string, any>;
    updateOutputs: (generatedTheme: ThemeGenerationOutput) => void;
    getOutput: (id: string) => any;
    getOutputId: (id: string) => "/__pinceau_css.css" | "/__pinceau_ts.ts" | "/__pinceau_utils.ts" | "/__pinceau_schema.ts" | "/__pinceau_definitions.ts";
};
type PinceauVirtualContext = ReturnType<typeof usePinceauVirtualStore>;

type PinceauTheme = GeneratedPinceauTheme;
type PinceauTokensPaths = GeneratedPinceauPaths;
type PinceauUtils = GeneratedPinceauUtils;
type PinceauMediaQueries = 'dark' | 'light' | 'initial' | (keyof PinceauTheme['media'] extends string ? keyof PinceauTheme['media'] : never);

type RawTokenType = string | number;
/**
 * A token that uses media queries as keys and value as value for this breakpoint.
 */
type ResponsiveToken<T = RawTokenType> = {
    initial: T;
} & {
    [key in PinceauMediaQueries]?: T;
};
/**
 * A token key value pair in the configurations.
 */
type TokenKey<T extends RawTokenType = RawTokenType> = DesignToken<T> | ResponsiveToken<T> | T;
/**
 * A Design Token object for Pinceau.
 */
interface DesignToken<T = RawTokenType> {
    /**
     * The raw value of the token.
     */
    value: T;
    /**
     * The schema definition for the schema output format.
     */
    $schema?: Schema;
    /**
     * CSS Variable reference that gets generated out of the token path.
     */
    variable?: string;
    /**
     * The file path to the source of this token.
     */
    source?: string;
    /**
     * The raw value of this token, before transforms.
     */
    raw?: T;
    /**
     * Token extraneous attributes.
     */
    attributes?: {
        [key: string | number]: any;
    };
}
/**
 * Simple recursive tokens object
 */
interface DesignTokens {
    [key: string | number]: TokenKey | DesignTokens;
}

interface TokensFunctionOptions {
    /**
     * The key that will be unwrapped from the design token object.
     * @default variable
     */
    key?: 'variable' | 'value' | string;
    /**
     * Called on missing tokens.
     * @default false
     */
    onNotFound?: false | ((path: string, options: TokensFunctionOptions) => void);
    /**
     * The location of the resolved token.
     * Can be useful for logging purposes.
     * @default false
     */
    loc?: any;
}
/**
 * $dt function
 */
type DtFunction = (path: PinceauTokensPaths | (string & {}), key?: 'variable' | 'value') => string;
/**
 * $tokens function
 */
type TokensFunction = (path?: PinceauTokensPaths | (string & {}), options?: TokensFunctionOptions, theme?: any) => DesignTokens | DesignToken | number | string;

type Primitive = string | number | symbol;
type WrapKey<TKey, TPrefix extends string = '', TSuffix extends string = ''> = TKey extends string ? `${TPrefix}${TKey}${TSuffix}` : never;
type UnwrapKey<TWrappedKey, TPrefix extends string = '', TSuffix extends string = ''> = TWrappedKey extends WrapKey<infer TKey, TPrefix, TSuffix> ? TKey : '';
type WrappedValue<TObject extends object, TWrappedKey extends string, TPrefix extends string = '', TSuffix extends string = ''> = TObject extends {
    [K in UnwrapKey<TWrappedKey, TPrefix, TSuffix>]: infer TValue;
} ? TValue : never;
type PrefixObjectKeys<TObject extends object, TPrefix extends string> = {
    [K in WrapKey<keyof TObject, TPrefix>]: WrappedValue<TObject, K, TPrefix>;
};
type SuffixObjectKeys<TObject extends object, TSuffix extends string> = {
    [K in WrapKey<keyof TObject, TSuffix>]: WrappedValue<TObject, K, '', TSuffix>;
};
type WrapObjectKeys<TObject extends object, TPrefix extends string, TSuffix extends string> = {
    [K in WrapKey<keyof TObject, TPrefix, TSuffix>]: WrappedValue<TObject, K, TPrefix, TSuffix>;
};
type NestedKeyOf<TObject> = {
    [Key in keyof TObject & (string | number)]: TObject[Key] extends object | string ? `${Key}` | `${Key}.${NestedKeyOf<TObject[Key]>}` : `${Key}`;
}[keyof TObject & (string | number)];
type FilterStartingWith<Set, Needle extends string> = Set extends `${Needle}${infer _X}` ? Set : never;
type WrapUnion<TObject extends Primitive, TPrefix extends string, TSuffix extends string> = keyof {
    [K in WrapKey<TObject, TPrefix, TSuffix>]: any;
};
interface PinceauQuery {
    id: string;
    ext: string;
    filename: string;
    vue?: boolean;
    src?: boolean;
    global?: boolean;
    type?: 'script' | 'template' | 'style' | 'custom';
    blockType?: string;
    index?: number;
    locale?: string;
    lang?: string;
    raw?: boolean;
    scoped?: string;
    transformed?: boolean;
    issuerPath?: string;
    styles?: boolean;
    transformable?: boolean;
}

interface DefaultThemeMap {
    gap: 'space';
    columnGap: 'space';
    rowGap: 'space';
    inset: 'space';
    insetBlock: 'space';
    insetBlockEnd: 'space';
    insetBlockStart: 'space';
    insetInline: 'space';
    insetInlineEnd: 'space';
    insetInlineStart: 'space';
    margin: 'space';
    marginTop: 'space';
    marginRight: 'space';
    marginBottom: 'space';
    marginLeft: 'space';
    marginBlock: 'space';
    marginBlockEnd: 'space';
    marginBlockStart: 'space';
    marginInline: 'space';
    marginInlineEnd: 'space';
    marginInlineStart: 'space';
    padding: 'space';
    paddingTop: 'space';
    paddingRight: 'space';
    paddingBottom: 'space';
    paddingLeft: 'space';
    paddingBlock: 'space';
    paddingBlockEnd: 'space';
    paddingBlockStart: 'space';
    paddingInline: 'space';
    paddingInlineEnd: 'space';
    paddingInlineStart: 'space';
    scrollMargin: 'space';
    scrollMarginTop: 'space';
    scrollMarginRight: 'space';
    scrollMarginBottom: 'space';
    scrollMarginLeft: 'space';
    scrollMarginBlock: 'space';
    scrollMarginBlockEnd: 'space';
    scrollMarginBlockStart: 'space';
    scrollMarginInline: 'space';
    scrollMarginInlineEnd: 'space';
    scrollMarginInlineStart: 'space';
    scrollPadding: 'space';
    scrollPaddingTop: 'space';
    scrollPaddingRight: 'space';
    scrollPaddingBottom: 'space';
    scrollPaddingLeft: 'space';
    scrollPaddingBlock: 'space';
    scrollPaddingBlockEnd: 'space';
    scrollPaddingBlockStart: 'space';
    scrollPaddingInline: 'space';
    scrollPaddingInlineEnd: 'space';
    scrollPaddingInlineStart: 'space';
    top: 'space';
    right: 'space';
    bottom: 'space';
    left: 'space';
    fontSize: 'fontSize';
    background: 'color';
    backgroundColor: 'color';
    backgroundImage: 'color';
    borderImage: 'color';
    border: 'border';
    borderBlock: 'border';
    borderBlockEnd: 'border';
    borderBlockStart: 'border';
    borderBottom: 'border';
    borderBottomColor: 'border';
    borderColor: 'color';
    borderInline: 'color';
    borderInlineEnd: 'color';
    borderInlineStart: 'color';
    borderLeft: 'color';
    borderLeftColor: 'color';
    borderRight: 'color';
    borderRightColor: 'color';
    borderTop: 'color';
    borderTopColor: 'color';
    caretColor: 'color';
    color: 'color';
    columnRuleColor: 'color';
    outline: 'color';
    outlineColor: 'color';
    fill: 'color';
    stroke: 'color';
    textDecorationColor: 'color';
    fontFamily: 'font';
    fontWeight: 'fontWeight';
    lineHeight: 'lead';
    letterSpacing: 'letterSpacing';
    blockSize: 'size';
    minBlockSize: 'size';
    maxBlockSize: 'size';
    inlineSize: 'size';
    minInlineSize: 'size';
    maxInlineSize: 'size';
    width: 'size';
    minWidth: 'size';
    maxWidth: 'size';
    height: 'size';
    minHeight: 'size';
    maxHeight: 'size';
    flexBasis: 'size';
    gridTemplateColumns: 'size';
    gridTemplateRows: 'size';
    borderWidth: 'borderWidth';
    borderTopWidth: 'borderWidth';
    borderLeftWidth: 'borderWidth';
    borderRightWidth: 'borderWidth';
    borderBottomWidth: 'borderWidth';
    borderRadius: 'radii';
    borderTopLeftRadius: 'radii';
    borderTopRightRadius: 'radii';
    borderBottomRightRadius: 'radii';
    borderBottomLeftRadius: 'radii';
    borderStyle: 'borderStyle';
    boxShadow: 'shadow';
    textShadow: 'shadow';
    transition: 'transition';
    zIndex: 'zIndice';
    opacity: 'opacity';
}

interface VariantOptions<T = string> {
    type?: string;
    required?: boolean;
    default?: T | {
        [key in PinceauMediaQueries]?: T;
    };
    mediaPrefix?: boolean;
}
interface BooleanVariant {
    true?: CSSProperties;
    false?: CSSProperties;
    [key: string]: CSSProperties;
}
interface EnumVariant {
    [key: string]: CSSProperties;
}
interface ClassVariant {
    [key: string]: string | (CSSProperties & {
        $class?: string;
    });
}
type Variant = (BooleanVariant | EnumVariant | ClassVariant) & {
    options?: VariantOptions;
};
interface Variants {
    [key: string]: Variant;
}

type VuePseudos = '&:deep(' | '&:slotted(' | '&:global(';
type AdvancedPseudos = '&::cue(' | '&::cue-region(' | '&::part(' | '&::slotted(' | '&:dir(' | '&:has(' | '&:host(' | '&:host-context(' | '&:is(' | '&:lang(' | '&:not(' | '&:nth-child(' | '&:nth-last-child(' | '&:nth-last-of-type(' | '&:nth-of-type(' | '&:where(';
type SimplePseudos = '&::after' | '&::backdrop' | '&::before' | '&::cue' | '&::cue-region' | '&::first-letter' | '&::first-line' | '&::grammar-error' | '&::marker' | '&::placeholder' | '&::selection' | '&::spelling-error' | '&::target-text' | '&:active' | '&:after' | '&:any-link' | '&:before' | '&:blank' | '&:checked' | '&:current' | '&:default' | '&:defined' | '&:disabled' | '&:empty' | '&:enabled' | '&:first' | '&:first-child' | '&:first-letter' | '&:first-line' | '&:first-of-type' | '&:focus' | '&:focus-visible' | '&:focus-within' | '&:fullscreen' | '&:future' | '&:hover' | '&:in-range' | '&:indeterminate' | '&:invalid' | '&:last-child' | '&:last-of-type' | '&:left' | '&:link' | '&:local-link' | '&:nth-col' | '&:nth-last-col' | '&:only-child' | '&:only-of-type' | '&:optional' | '&:out-of-range' | '&:past' | '&:paused' | '&:picture-in-picture' | '&:placeholder-shown' | '&:read-only' | '&:read-write' | '&:required' | '&:right' | '&:root' | '&:scope' | '&:target' | '&:target-within' | '&:user-invalid' | '&:user-valid' | '&:valid' | '&:visited';
type Pseudos = AdvancedPseudos | SimplePseudos | VuePseudos;
type PseudosProperties = {
    [key in Pseudos]?: NativeProperties;
};
interface NativeProperties extends CSSType.StandardProperties, CSSType.StandardShorthandProperties, CSSType.StandardProperties, CSSType.SvgProperties {
}
/**
 * Takes a supported key from the ThemeMap and returns a list of tokens supporting that key.
 */
type ThemeProperties<K extends keyof DefaultThemeMap> = WrapUnion<FilterStartingWith<PinceauTokensPaths, DefaultThemeMap[K]>, '{', '}'>;
/**
 * Take a key and gives a list of tokens under that key in configuration.
 */
type ThemeTokens<K extends PinceauTokensPaths | (string & {})> = WrapUnion<FilterStartingWith<PinceauTokensPaths, K>, '{', '}'>;
/**
 * Supported properties in `css()` function
 */
type SupportedProperties = keyof NativeProperties | keyof DefaultThemeMap;
type PropertyValue<T extends (keyof NativeProperties | keyof DefaultThemeMap | string)> = T extends keyof NativeProperties ? T extends keyof DefaultThemeMap ? ThemeProperties<T> | NativeProperties[T] : NativeProperties[T] : never;
type UsableTokens = WrapUnion<PinceauTokensPaths, '{', '}'>;

type ColorSchemeModes = 'media' | 'class';
type ComputedStyleProp<T extends string> = T | {
    [key in PinceauMediaQueries]?: T;
};
type ComputedStyleDefinition<T extends string, ComponentProps = {}> = (props: ComponentProps) => PropertyValue<T> | {
    [key in PinceauMediaQueries]?: PropertyValue<T>;
};
type MappedProperty<K extends string, ComponentProps = {}> = K | PropertyValue<K> | ComputedStyleDefinition<K, ComponentProps>;
type CSSProperties<ComponentProps = {}, UtilsProperties = PinceauUtils> = {
    [K in keyof DefaultThemeMap]?: MappedProperty<K, ComponentProps> | {};
} & {
    [K in keyof NativeProperties]?: MappedProperty<K, ComponentProps> | {};
} & {
    [K in keyof PseudosProperties]?: CSSProperties<ComponentProps> | {};
} & {
    [K in keyof UtilsProperties]?: UsableTokens | ComputedStyleDefinition<UsableTokens, ComponentProps> | {};
} & {
    [K in string]?: CSSProperties<ComponentProps> | MappedProperty<K, ComponentProps> | {};
};
type CSSFunctionType<ComponentProps = {}, MediaQueries extends string = WrapUnion<PinceauMediaQueries, '@', ''>, UtilsProperties = PinceauUtils> = {
    variants?: Variants;
} & {
    [K in keyof UtilsProperties]?: K extends string ? MappedProperty<K, ComponentProps> : never | ComputedStyleDefinition<UsableTokens, ComponentProps>;
} & {
    [K in MediaQueries]?: CSSProperties<ComponentProps> | {};
} & {
    [K in string]: CSSProperties<ComponentProps> | MappedProperty<K, ComponentProps> | {};
};

/**
 * A configuration layer as expressed by the user.
 */
interface ConfigLayer {
    cwd?: string;
    configFileName?: string;
    tokens?: DefineConfigType<any>;
}
/**
 * A config file import content.
 *
 * Includes both the content of the file as string and its evalued content as import.
 */
interface ConfigFileImport {
    config: any;
    content: string;
    path: string;
}
/**
 * A layer of configuration that has been resolved before being loaded.
 */
interface ResolvedConfigLayer<T = PinceauTheme> {
    path: string | undefined;
    content: string;
    definitions: {
        [key: string]: any;
    };
    config: T;
}
/**
 * A configuration data once loaded by Pinceau.
 */
interface LoadConfigResult<T = any> {
    config: T;
    definitions: {
        [key: string]: any;
    };
    sources: string[];
}
/**
 * Utils properties mappings.
 */
interface PinceauUtilsProperties {
    [key: string]: CSSProperties | ((value: any) => CSSProperties);
}
/**
 * Media queries properties.
 */
interface PinceauMediaProperties {
    $schema?: Schema;
    [key: string]: DesignToken<RawTokenType> | RawTokenType | Schema;
}
/**
 * Reserved keys in define config type.
 */
interface ReservedConfigKeys {
    media?: PinceauMediaProperties;
    utils?: PinceauUtilsProperties;
}
/**
 * Extensible configuration type
 */
type Theme<T> = {
    $schema?: Schema;
} | {
    [K in keyof T]?: T[K] extends DesignToken<ResponsiveToken> ? (Partial<T[K]['raw']> | DesignToken<Partial<T[K]['raw']>> | DesignToken) : Theme<T[K]>;
} | {
    [K in keyof T]?: T[K] extends DesignToken ? (T[K]['raw'] | T[K]) : Theme<T[K]>;
} | {
    [K in keyof T]?: T[K] extends DesignToken ? (T[K] | T[K]['raw'] | ResponsiveToken | DesignToken<ResponsiveToken> | DesignToken<T[K]['raw']>) : Theme<T[K]>;
} | {
    [K in keyof T]?: DesignToken | DesignToken<ResponsiveToken> | ResponsiveToken | RawTokenType | Theme<T[K]>;
};
/**
 * Reserved keys and extensible configuration type
 */
type DefineConfigType<T extends PinceauTheme> = Theme<T> & ReservedConfigKeys;

/**
 * Supports all the different ways of expressing configuration layers from `configOrPaths` from Pinceau's options.
 */
type ConfigOrPaths = (string | ConfigLayer)[];
/**
 *
 */
interface PinceauContext<UserOptions extends PinceauOptions = PinceauOptions> extends PinceauConfigContext<UserOptions>, PinceauVirtualContext {
    env: 'prod' | 'dev';
    tokens: DesignTokens;
    utils: {
        [key: string]: any;
    };
    $tokens: TokensFunction;
    options: PinceauOptions;
    transformed: string[];
    viteServer: ViteDevServer;
    runtime?: boolean;
    addTransformed: (id: string) => void;
    setViteServer(server: ViteDevServer): void;
}
interface PinceauConfigContext<UserOptions = PinceauOptions> {
    /**
     * Current rootDir of Pinceau
     */
    cwd: string;
    /**
     * A list of watched sources
     */
    sources: string[];
    /**
     * Currently resolved configuration from the configuration loader.
     */
    resolvedConfig: any;
    /**
     * Is the loader currently loading configurations layers?
     */
    ready: Promise<LoadConfigResult<PinceauTheme>>;
    /**
     * Update the current rootDir
     */
    updateCwd: (newCwd: string) => Promise<LoadConfigResult<PinceauTheme>>;
    /**
     * Reload the configuration (with new options if provided)
     */
    reloadConfig: (newOptions?: UserOptions) => Promise<LoadConfigResult<PinceauTheme>>;
    /**
     * Registers the initial configurations watchers.
     */
    registerConfigWatchers: () => void;
}
interface ThemeGenerationOutput {
    buildPath: string;
    tokens: any;
    outputs: Record<string, any>;
}

interface PinceauOptions {
    /**
     * The root directory of your project.
     *
     * @default process.cwd()
     */
    cwd?: string;
    /**
     * The path of your configuration file.
     */
    configLayers?: ConfigOrPaths;
    /**
     * The path of your configuration file.
     *
     * @default 'tokens.config'
     */
    configFileName?: string;
    /**
     * A callback called each time your config gets resolved.
     */
    configResolved?: (config: LoadConfigResult) => void;
    /**
     * A callback called each time your config gets built.
     */
    configBuilt?: (config: ThemeGenerationOutput) => void;
    /**
     * The directory in which you want to output the built version of your configuration.
     */
    outputDir?: string;
    /**
     * Imports the default CSS reset in the project.
     *
     * @default true
     */
    preflight?: boolean | 'tailwind' | 'antfu' | 'eric-meyer' | 'normalize';
    /**
     * Excluded transform paths.
     */
    excludes?: string[];
    /**
     * Included transform paths.
     */
    includes?: string[];
    /**
     * Toggle follow of symbolic links in glob.
     *
     * Disabling might be useful when testing.
     *
     * Enabling might be useful when using `link`.
     */
    followSymbolicLinks?: boolean;
    /**
     * Toggles color .{dark|light} global classes.
     *
     * If set to class, all @dark and @light clauses will also be generated
     * with .{dark|light} classes on <html> tag as a parent selector.
     *
     * @default 'class'
     */
    colorSchemeMode?: ColorSchemeModes;
    /**
     * Toggles the development mode of Pinceau.
     */
    dev?: boolean;
    /**
     * Enables extra logging on transform failures.
     */
    debug?: boolean | 2;
    /**
     * Enables support for nuxt-component-meta.
     */
    componentMetaSupport?: boolean;
    /**
     * Completely enable or disable Pinceau runtime features.
     */
    runtime?: boolean;
    /**
     * Support for @nuxthq/studio module.
     */
    studio?: boolean;
    /**
     * Support for definitions.ts ; improving experience for Pinceau IntelliSense.
     */
    definitions?: boolean;
    /**
     * Imports to append before the `utils.ts` declarations.
     *
     * These are usually the imports you make in your utils declaration files that Pinceau cannot automatically resolves.
     *
     * @example {[`import { MyThemeType } from "my-theme-types"`]}
     */
    utilsImports?: string[];
}

export { SimplePseudos as $, Theme as A, DefineConfigType as B, ColorSchemeModes as C, DesignTokens as D, TokensFunction as E, FilterStartingWith as F, RawTokenType as G, ResponsiveToken as H, DesignToken as I, DefaultThemeMap as J, BooleanVariant as K, LoadConfigResult as L, MappedProperty as M, NestedKeyOf as N, EnumVariant as O, PinceauOptions as P, ClassVariant as Q, ResolvedConfigLayer as R, SuffixObjectKeys as S, TokensFunctionOptions as T, UnwrapKey as U, VariantOptions as V, WrapKey as W, Variant as X, Variants as Y, VuePseudos as Z, AdvancedPseudos as _, TokenKey as a, Pseudos as a0, PseudosProperties as a1, NativeProperties as a2, ThemeProperties as a3, ThemeTokens as a4, SupportedProperties as a5, PropertyValue as a6, UsableTokens as a7, RESOLVED_ID_RE as a8, usePinceauVirtualStore as a9, DtFunction as b, Primitive as c, WrappedValue as d, PrefixObjectKeys as e, WrapObjectKeys as f, WrapUnion as g, PinceauQuery as h, PinceauTheme as i, PinceauTokensPaths as j, PinceauUtils as k, PinceauMediaQueries as l, PinceauVirtualContext as m, ConfigOrPaths as n, PinceauContext as o, PinceauConfigContext as p, ThemeGenerationOutput as q, ComputedStyleProp as r, ComputedStyleDefinition as s, CSSProperties as t, CSSFunctionType as u, ConfigLayer as v, ConfigFileImport as w, PinceauUtilsProperties as x, PinceauMediaProperties as y, ReservedConfigKeys as z };
