'use strict';

const fs = require('fs');
const path = require('pathe');
const kit = require('@nuxt/kit');
const createJITI = require('jiti');
const unplugin = require('./shared/pinceau.9e0e8864.cjs');
const context = require('./shared/pinceau.98ff0931.cjs');
const query = require('./shared/pinceau.71cfe6a3.cjs');
require('defu');
require('acorn');
require('vue/compiler-sfc');
require('recast');
require('recast/parsers/typescript.js');
require('ohash');
require('scule');
require('fs/promises');
require('vue');
const stringify = require('./shared/pinceau.1adee1a2.cjs');
require('style-dictionary-esm');
require('untyped');
require('postcss-nested');
require('postcss-custom-properties');
require('postcss-dark-theme-class');
require('unplugin');
require('magic-string');
require('consola');
require('chalk');
require('perf_hooks');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const createJITI__default = /*#__PURE__*/_interopDefaultCompat(createJITI);

const module$1 = kit.defineNuxtModule({
  meta: {
    name: "pinceau/nuxt",
    configKey: "pinceau"
  },
  defaults: (nuxt) => ({
    ...unplugin.defaultOptions,
    colorSchemeMode: "class",
    outputDir: path.join(nuxt.options.buildDir, "pinceau/")
  }),
  async setup(options, nuxt) {
    options.dev = nuxt.options?.dev || process.env.NODE_ENV !== "production";
    const { stopPerfTimer } = query.useDebugPerformance("Setup Nuxt module", options.debug);
    const modulePath = kit.createResolver((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (document.currentScript && document.currentScript.src || new URL('nuxt.cjs', document.baseURI).href)));
    const resolveLocalModule = (path) => kit.resolveModule(path, { paths: modulePath.resolve("./") });
    nuxt.options.build.transpile = nuxt.options.build.transpile || [];
    nuxt.options.build.transpile.push("pinceau", "chroma-js");
    options.cwd = nuxt.options.rootDir;
    if (options.componentMetaSupport) {
      const cachedTokens = [];
      nuxt.hook("component-meta:transformers", (transformers) => {
        transformers.push(
          (component, code) => {
            const resolvedTokens = [];
            if (!cachedTokens && fs.existsSync(path.join(options.outputDir, "index.ts"))) {
              const _tokens = createJITI__default(options.outputDir)(path.join(options.outputDir, "index.ts")).default;
              stringify.walkTokens(_tokens?.theme || _tokens, (_, __, paths) => cachedTokens.push(paths.join(".")));
            }
            if (cachedTokens.length) {
              const referencesRegex = /\{([a-zA-Z].+)\}/g;
              const matches = code.match(referencesRegex) || [];
              matches.forEach(
                (match) => {
                  const _match = match.replace("{", "").replace("}", "");
                  if (cachedTokens.includes(_match) && !resolvedTokens.includes(_match)) {
                    resolvedTokens.push(match);
                  }
                }
              );
            }
            component.meta.tokens = resolvedTokens;
            return { component, code };
          }
        );
        return transformers;
      });
    }
    nuxt.hook("prepare:types", async (opts) => {
      const tsConfig = opts.tsConfig;
      tsConfig.compilerOptions = tsConfig.compilerOptions || {};
      tsConfig.compilerOptions.paths = tsConfig.compilerOptions.paths || {};
      if (options?.outputDir) {
        tsConfig.compilerOptions.paths["#pinceau/utils"] = [`${path.resolve(options.outputDir, "utils.ts")}`];
        tsConfig.compilerOptions.paths["#pinceau/theme"] = [`${path.resolve(options.outputDir, "index.ts")}`];
        if (options?.studio) {
          tsConfig.compilerOptions.paths["#pinceau/schema"] = [`${path.resolve(options.outputDir, "schema.ts")}`];
        }
        if (options?.definitions) {
          tsConfig.compilerOptions.paths["#pinceau/definitions"] = [`${path.resolve(options.outputDir, "definitions.ts")}`];
        }
      }
      opts.references.push({ path: "pinceau" });
      opts.references.push({ path: "pinceau/runtime" });
      tsConfig.vueCompilerOptions = tsConfig.vueCompilerOptions || {};
      tsConfig.vueCompilerOptions.plugins = tsConfig.vueCompilerOptions.plugins || [];
      tsConfig.vueCompilerOptions.plugins.push("pinceau/volar");
      await context.prepareOutputDir(options);
    });
    if (nuxt.options.ssr) {
      if (!nuxt.options.nitro) {
        nuxt.options.nitro = {};
      }
      const nitroConfig = nuxt.options.nitro;
      nitroConfig.plugins = nitroConfig.plugins || [];
      nitroConfig.plugins.push(resolveLocalModule("./nitro"));
      nitroConfig.externals = nitroConfig.externals || {};
      nitroConfig.externals.inline = nitroConfig.externals.inline || [];
      nitroConfig.externals.inline.push(resolveLocalModule("./nitro"));
    } else {
      nuxt.options.css = nuxt.options.css || [];
      nuxt.options.css.push(path.join(options.outputDir, "theme/index.css"));
    }
    nuxt.hook("nitro:config", (nitroConfig) => {
      nitroConfig.bundledStorage = nitroConfig.bundledStorage || [];
      nitroConfig.bundledStorage.push("pinceau");
      nitroConfig.devStorage = nitroConfig.devStorage || {};
      nitroConfig.devStorage.pinceau = {
        driver: "fs",
        base: path.join(options.outputDir, "theme")
      };
    });
    options.configLayers = [
      ...options?.configLayers,
      ...nuxt.options._layers.reduce(
        (acc, layer) => {
          if (typeof layer === "string") {
            acc.push({ cwd: layer, configFileName: options.configFileName });
          }
          if (layer?.cwd) {
            acc.push({ cwd: layer?.cwd, configFileName: options.configFileName });
          }
          return acc;
        },
        []
      )
    ];
    await nuxt.callHook("pinceau:options", options);
    nuxt.options.runtimeConfig.pinceau = { studio: options?.studio, outputDir: options?.outputDir };
    if (options.studio) {
      kit.addPlugin(resolveLocalModule("./runtime/schema.server"));
      kit.addPrerenderRoutes("/__pinceau_tokens_config.json");
      kit.addPrerenderRoutes("/__pinceau_tokens_schema.json");
      const studioAppConfigPath = kit.resolveAlias("~/.studio");
      if (fs.existsSync(studioAppConfigPath)) {
        options.configLayers.unshift({ cwd: studioAppConfigPath, configFileName: "tokens.config" });
      }
    }
    kit.addPluginTemplate({
      filename: "pinceau-nuxt-plugin.server.mjs",
      mode: "server",
      getContents() {
        const lines = [];
        if (options.runtime) {
          lines.push(
            "import { dirname, join } from 'pathe'",
            "import { useRuntimeConfig } from '#imports'",
            "import { plugin as pinceau } from 'pinceau/runtime'",
            "import utils from '#build/pinceau/utils'",
            "import theme from '#build/pinceau/index'",
            "",
            `export default defineNuxtPlugin(async (nuxtApp) => {
              nuxtApp.vueApp.use(pinceau, { colorSchemeMode: '${options.colorSchemeMode}', theme, utils })

              const { pinceau: runtimeConfig } = useRuntimeConfig()

              // Handle first render of SSR styles
              nuxtApp.hook('app:rendered', async (app) => {
                app.ssrContext.event.pinceauContent = app.ssrContext.event.pinceauContent || {}
                const content = app.ssrContext.nuxt.vueApp.config.globalProperties.$pinceauSsr.get()
                app.ssrContext.event.pinceauContent.runtime = content
              })
            })`
          );
        }
        if (options?.preflight) {
          lines.unshift(`import '@unocss/reset/${typeof options.preflight === "boolean" ? "tailwind" : options.preflight}.css'`);
        }
        return lines.join("\n");
      }
    });
    kit.addPluginTemplate({
      filename: "pinceau-nuxt-plugin.client.mjs",
      mode: "client",
      getContents() {
        const lines = [];
        if (options.runtime) {
          lines.push(
            "import { plugin as pinceau } from 'pinceau/runtime'",
            "import utils from '#build/pinceau/utils'",
            `export default defineNuxtPlugin(async (nuxtApp) => nuxtApp.vueApp.use(pinceau, { colorSchemeMode: '${options.colorSchemeMode}', utils }))`
          );
        } else {
          lines.push(
            "import 'pinceau.css'",
            "export default defineNuxtPlugin(() => {})"
          );
        }
        if (options?.preflight) {
          lines.unshift(`import '@unocss/reset/${typeof options.preflight === "boolean" ? "tailwind" : options.preflight}.css'`);
        }
        return lines.join("\n");
      }
    });
    nuxt.hook("vite:extend", (vite) => {
      vite.config.plugins = vite.config.plugins || [];
      vite.config.plugins.push(unplugin.pinceau.vite(options));
    });
    stopPerfTimer();
  }
});

module.exports = module$1;
