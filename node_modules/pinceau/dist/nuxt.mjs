import { existsSync } from 'fs';
import { join, resolve } from 'pathe';
import { defineNuxtModule, createResolver, addPlugin, addPrerenderRoutes, resolveAlias, addPluginTemplate, resolveModule } from '@nuxt/kit';
import createJITI from 'jiti';
import { d as defaultOptions, p as pinceau } from './shared/pinceau.c426a31e.mjs';
import { p as prepareOutputDir } from './shared/pinceau.aa6b702d.mjs';
import { u as useDebugPerformance } from './shared/pinceau.23c34d4f.mjs';
import 'defu';
import 'acorn';
import 'vue/compiler-sfc';
import 'recast';
import 'recast/parsers/typescript.js';
import 'ohash';
import 'scule';
import 'fs/promises';
import 'vue';
import { w as walkTokens } from './shared/pinceau.3988746b.mjs';
import 'style-dictionary-esm';
import 'untyped';
import 'postcss-nested';
import 'postcss-custom-properties';
import 'postcss-dark-theme-class';
import 'unplugin';
import 'magic-string';
import 'consola';
import 'chalk';
import 'perf_hooks';

const module = defineNuxtModule({
  meta: {
    name: "pinceau/nuxt",
    configKey: "pinceau"
  },
  defaults: (nuxt) => ({
    ...defaultOptions,
    colorSchemeMode: "class",
    outputDir: join(nuxt.options.buildDir, "pinceau/")
  }),
  async setup(options, nuxt) {
    options.dev = nuxt.options?.dev || process.env.NODE_ENV !== "production";
    const { stopPerfTimer } = useDebugPerformance("Setup Nuxt module", options.debug);
    const modulePath = createResolver(import.meta.url);
    const resolveLocalModule = (path) => resolveModule(path, { paths: modulePath.resolve("./") });
    nuxt.options.build.transpile = nuxt.options.build.transpile || [];
    nuxt.options.build.transpile.push("pinceau", "chroma-js");
    options.cwd = nuxt.options.rootDir;
    if (options.componentMetaSupport) {
      const cachedTokens = [];
      nuxt.hook("component-meta:transformers", (transformers) => {
        transformers.push(
          (component, code) => {
            const resolvedTokens = [];
            if (!cachedTokens && existsSync(join(options.outputDir, "index.ts"))) {
              const _tokens = createJITI(options.outputDir)(join(options.outputDir, "index.ts")).default;
              walkTokens(_tokens?.theme || _tokens, (_, __, paths) => cachedTokens.push(paths.join(".")));
            }
            if (cachedTokens.length) {
              const referencesRegex = /\{([a-zA-Z].+)\}/g;
              const matches = code.match(referencesRegex) || [];
              matches.forEach(
                (match) => {
                  const _match = match.replace("{", "").replace("}", "");
                  if (cachedTokens.includes(_match) && !resolvedTokens.includes(_match)) {
                    resolvedTokens.push(match);
                  }
                }
              );
            }
            component.meta.tokens = resolvedTokens;
            return { component, code };
          }
        );
        return transformers;
      });
    }
    nuxt.hook("prepare:types", async (opts) => {
      const tsConfig = opts.tsConfig;
      tsConfig.compilerOptions = tsConfig.compilerOptions || {};
      tsConfig.compilerOptions.paths = tsConfig.compilerOptions.paths || {};
      if (options?.outputDir) {
        tsConfig.compilerOptions.paths["#pinceau/utils"] = [`${resolve(options.outputDir, "utils.ts")}`];
        tsConfig.compilerOptions.paths["#pinceau/theme"] = [`${resolve(options.outputDir, "index.ts")}`];
        if (options?.studio) {
          tsConfig.compilerOptions.paths["#pinceau/schema"] = [`${resolve(options.outputDir, "schema.ts")}`];
        }
        if (options?.definitions) {
          tsConfig.compilerOptions.paths["#pinceau/definitions"] = [`${resolve(options.outputDir, "definitions.ts")}`];
        }
      }
      opts.references.push({ path: "pinceau" });
      opts.references.push({ path: "pinceau/runtime" });
      tsConfig.vueCompilerOptions = tsConfig.vueCompilerOptions || {};
      tsConfig.vueCompilerOptions.plugins = tsConfig.vueCompilerOptions.plugins || [];
      tsConfig.vueCompilerOptions.plugins.push("pinceau/volar");
      await prepareOutputDir(options);
    });
    if (nuxt.options.ssr) {
      if (!nuxt.options.nitro) {
        nuxt.options.nitro = {};
      }
      const nitroConfig = nuxt.options.nitro;
      nitroConfig.plugins = nitroConfig.plugins || [];
      nitroConfig.plugins.push(resolveLocalModule("./nitro"));
      nitroConfig.externals = nitroConfig.externals || {};
      nitroConfig.externals.inline = nitroConfig.externals.inline || [];
      nitroConfig.externals.inline.push(resolveLocalModule("./nitro"));
    } else {
      nuxt.options.css = nuxt.options.css || [];
      nuxt.options.css.push(join(options.outputDir, "theme/index.css"));
    }
    nuxt.hook("nitro:config", (nitroConfig) => {
      nitroConfig.bundledStorage = nitroConfig.bundledStorage || [];
      nitroConfig.bundledStorage.push("pinceau");
      nitroConfig.devStorage = nitroConfig.devStorage || {};
      nitroConfig.devStorage.pinceau = {
        driver: "fs",
        base: join(options.outputDir, "theme")
      };
    });
    options.configLayers = [
      ...options?.configLayers,
      ...nuxt.options._layers.reduce(
        (acc, layer) => {
          if (typeof layer === "string") {
            acc.push({ cwd: layer, configFileName: options.configFileName });
          }
          if (layer?.cwd) {
            acc.push({ cwd: layer?.cwd, configFileName: options.configFileName });
          }
          return acc;
        },
        []
      )
    ];
    await nuxt.callHook("pinceau:options", options);
    nuxt.options.runtimeConfig.pinceau = { studio: options?.studio, outputDir: options?.outputDir };
    if (options.studio) {
      addPlugin(resolveLocalModule("./runtime/schema.server"));
      addPrerenderRoutes("/__pinceau_tokens_config.json");
      addPrerenderRoutes("/__pinceau_tokens_schema.json");
      const studioAppConfigPath = resolveAlias("~/.studio");
      if (existsSync(studioAppConfigPath)) {
        options.configLayers.unshift({ cwd: studioAppConfigPath, configFileName: "tokens.config" });
      }
    }
    addPluginTemplate({
      filename: "pinceau-nuxt-plugin.server.mjs",
      mode: "server",
      getContents() {
        const lines = [];
        if (options.runtime) {
          lines.push(
            "import { dirname, join } from 'pathe'",
            "import { useRuntimeConfig } from '#imports'",
            "import { plugin as pinceau } from 'pinceau/runtime'",
            "import utils from '#build/pinceau/utils'",
            "import theme from '#build/pinceau/index'",
            "",
            `export default defineNuxtPlugin(async (nuxtApp) => {
              nuxtApp.vueApp.use(pinceau, { colorSchemeMode: '${options.colorSchemeMode}', theme, utils })

              const { pinceau: runtimeConfig } = useRuntimeConfig()

              // Handle first render of SSR styles
              nuxtApp.hook('app:rendered', async (app) => {
                app.ssrContext.event.pinceauContent = app.ssrContext.event.pinceauContent || {}
                const content = app.ssrContext.nuxt.vueApp.config.globalProperties.$pinceauSsr.get()
                app.ssrContext.event.pinceauContent.runtime = content
              })
            })`
          );
        }
        if (options?.preflight) {
          lines.unshift(`import '@unocss/reset/${typeof options.preflight === "boolean" ? "tailwind" : options.preflight}.css'`);
        }
        return lines.join("\n");
      }
    });
    addPluginTemplate({
      filename: "pinceau-nuxt-plugin.client.mjs",
      mode: "client",
      getContents() {
        const lines = [];
        if (options.runtime) {
          lines.push(
            "import { plugin as pinceau } from 'pinceau/runtime'",
            "import utils from '#build/pinceau/utils'",
            `export default defineNuxtPlugin(async (nuxtApp) => nuxtApp.vueApp.use(pinceau, { colorSchemeMode: '${options.colorSchemeMode}', utils }))`
          );
        } else {
          lines.push(
            "import 'pinceau.css'",
            "export default defineNuxtPlugin(() => {})"
          );
        }
        if (options?.preflight) {
          lines.unshift(`import '@unocss/reset/${typeof options.preflight === "boolean" ? "tailwind" : options.preflight}.css'`);
        }
        return lines.join("\n");
      }
    });
    nuxt.hook("vite:extend", (vite) => {
      vite.config.plugins = vite.config.plugins || [];
      vite.config.plugins.push(pinceau.vite(options));
    });
    stopPerfTimer();
  }
});

export { module as default };
