import { defu, createDefu } from 'defu';
import { parse as parse$2 } from 'acorn';
import { performance } from 'perf_hooks';
import { hash } from 'ohash';
import { camelCase, kebabCase } from 'scule';
import 'fs';
import 'fs/promises';
import 'jiti';
import * as path from 'pathe';
import 'vue';
import 'style-dictionary-esm';
import 'untyped';
import { z as stringify, a as resolveCssProperty } from './pinceau.3988746b.mjs';
import 'postcss-nested';
import 'postcss-custom-properties';
import 'postcss-dark-theme-class';
import { parse as parse$1 } from 'vue/compiler-sfc';
import * as recast from 'recast';
import { parse } from 'recast/parsers/typescript.js';

const useDebugPerformance = (text, debug, logOnStop = true) => {
  const isDebug = debug === 2;
  const performanceTimerStart = performance.now();
  let performanceTimerStop;
  return {
    stopPerfTimer: isDebug ? stop : () => {
    },
    logPerfTimer: isDebug ? debugMarker(text, timing()) : () => {
    }
  };
  function timing() {
    const { error, success, warning } = getDebugContext();
    let count = Number(parseFloat(`${performanceTimerStop - performanceTimerStart}`).toFixed(2));
    if (isNaN(count)) {
      count = 0;
    }
    let color = success;
    if (count > 5) {
      color = warning;
    }
    if (count > 10) {
      color = error;
    }
    return color(count);
  }
  function stop(silent = false) {
    if (silent) {
      return;
    }
    performanceTimerStop = performance.now();
    if (logOnStop) {
      debugMarker(text, timing());
    }
  }
};
function findLineColumn(content, index) {
  const lines = content.split("\n");
  let line;
  let column;
  lines.forEach((lineContent, lineIndex) => {
    if (lineContent.includes(index)) {
      line = lineIndex;
      column = lineContent.indexOf(index) + 1;
    }
  });
  return {
    line,
    column
  };
}

const noopHelper = (value) => value?.toString() || value;
let context = {
  // consola.withScope(' ðŸ–Œ ')
  logger: console,
  // false
  debugLevel: false,
  // chalk.bgBlue.blue
  tag: noopHelper,
  // chalk.blue
  info: noopHelper,
  // chalk.yellow
  warning: noopHelper,
  // chalk.red
  error: noopHelper,
  // chalk.green
  success: noopHelper
};
const updateDebugContext = (newContext) => {
  context = {
    ...context,
    ...newContext
  };
};
const getDebugContext = () => context;
const c = getDebugContext;
const fileLink = (id) => c().logger.log(`\u{1F517} ${c().info(id)}
`);
const errorMessage = (message2) => c().logger.log(`\u{1F6A7} ${c().warning(message2)}
`);
const DEBUG_MARKER = () => c().tag(" DEBUG ");
const debugMarker = (text, timing) => c().logger.info(`${DEBUG_MARKER()} ${text} ${timing ? `[${timing}ms]` : ""}`);
const messages = {
  /**
   * Errors
   */
  TRANSFORM_ERROR: (debugLevel, id, error) => {
    c().logger.error("Pinceau could not transform this file:");
    fileLink(id);
    error?.message && errorMessage(error.message);
  },
  CONFIG_RESOLVE_ERROR: (debugLevel, path, error) => {
    c().logger.error("Pinceau could not resolve this configuration file:");
    const loc = error?.loc?.start?.line ? `${error.loc.start.line}:${error.loc.start.column}` : "";
    fileLink(`${path}${loc}`);
    error?.message && errorMessage(error.message);
  },
  CONFIG_BUILD_ERROR: (debugLevel, error) => {
    c().logger.error("Pinceau could not build your design tokens configuration!\n");
    c().logger.log(error);
  },
  SELECTOR_CONFLICT: (debugLevel, selector) => {
    c().logger.warn("Pinceau detected a conflicting selector:");
    c().logger.log(`\u2753 ${selector}
`);
    c().logger.log("If you want to combine `@dark` or `@light` with `html` selector, consider using `html.dark` or `html.light`.\n");
  },
  UTIL_NAME_CONFLICT: (debugLevel, name) => {
    c().logger.warn("Pinceau detected a conflicting util name:");
    c().logger.log(`\u2753 ${name}
`);
    c().logger.log("Util properties must be valid const names.\n");
    c().logger.log("Learn more about `const` name limitations: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types\n");
  },
  WRONG_TOKEN_NAMING: (debugLevel, token) => {
    c().logger.error(`Pinceau detected an invalid token name: ${c().error(token?.path?.join("-") || "Unknown path!")}`);
    c().logger.log("Token paths can not contains the following characters: `.` or `-`\n");
    c().logger.log("These paths keys also has to only contains characters supported in CSS stylesheets.\n");
  },
  /**
   * Warnings (debugLevel >= 1)
   */
  CONFIG_RESOLVED: (debugLevel, resolvedConfig) => {
    if (debugLevel === 2) {
      c().logger.log("\u2705 Pinceau loaded with following configuration sources:\n");
      resolvedConfig.sources.forEach((path) => fileLink(path));
      c().logger.log("\u{1F6A7} Disable this message by setting `debug: false` option.\n");
      c().logger.log(`\u{1F6A7} Current debug level: ${c().info(Number(debugLevel))}
`);
    }
  },
  TOKEN_NOT_FOUND: (debugLevel, path, options) => {
    if (debugLevel && options?.loc?.query && !options.loc.query?.type) {
      c().logger.warn(`Token not found in static CSS: ${c().error(path)}`);
      const { line: lineOffset, column: columnOffset } = findLineColumn(options.loc.source, `{${path}}`);
      if (!options.loc?.start) {
        options.loc.start = findLineColumn(options.loc.source, "css({");
      }
      const line = (options.loc?.start?.line || 0) + lineOffset;
      const column = (options.loc?.start?.column || 0) + columnOffset;
      c().logger.log(`\u{1F517} ${options.loc.query.filename}${line && column ? `:${line}:${column}
` : ""}`);
    }
  },
  SCHEMA_BUILD_ERROR: (debugLevel, _) => {
    if (debugLevel) {
      c().logger.warn("Pinceau could not build your schema.ts file!");
      c().logger.log("Design tokens editor might be hidden from Nuxt Studio.");
    }
  },
  RUNTIME_FEATURES_CONFLICT: (debugLevel, id) => {
    if (debugLevel) {
      c().logger.error("This component uses runtime features even though `runtime` is set to false in options:");
      fileLink(id);
    }
  }
};
const message = (id, options) => messages[id].bind(void 0, c().debugLevel, ...options)();

function parseAst(source, options) {
  return recast.parse(source, defu({ parser: { parse: parse } }, options));
}
function parseVueComponent(source, options = {}) {
  return parse$1(source, options);
}
function expressionToAst(type, leftSide = "const toAst = ", kind = "js") {
  const parsed = recast.parse(`${leftSide}${type}`, { parser: { parse: parse } });
  return kind === "js" ? parsed.program.body[0].declarations[0].init : parsed.program.body[0].typeAnnotation;
}
function defaultExport(node) {
  return node.program.body.find((n) => n.type === "ExportDefaultDeclaration")?.declaration;
}
const visitAst = recast.visit;
const printAst = recast.print;
const astTypes = recast.types;

function resolveRuntimeContents(cssAst, computedStyles = {}, localTokens = {}) {
  visitAst(
    cssAst,
    {
      visitObjectProperty(path) {
        if (path.value) {
          const key = path?.value?.key?.name || path?.value?.key?.value;
          const valueType = path?.value?.value?.type;
          if (key.startsWith("--") && !localTokens[key]) {
            localTokens[key] = path.value.value;
          }
          if (valueType === "ArrowFunctionExpression" || valueType === "FunctionExpression") {
            const computedStyleKey = camelCase(key.replace(/--/g, "__"));
            const id = `_${hash(path.value.loc.start).slice(0, 3)}_${computedStyleKey}`;
            computedStyles[id] = printAst(path.value.value.body).code;
            path.replace(
              astTypes.builders.objectProperty(
                path.value.key,
                astTypes.builders.stringLiteral(`var(--${kebabCase(id)})`)
              )
            );
          }
        }
        return this.traverse(path);
      }
    }
  );
}

const transformCssFunction = (id, code = "", variants, computedStyles, localTokens, ctx, loc) => {
  try {
    parse$2(code, { ecmaVersion: "latest" });
  } catch (e) {
    e.loc.line = loc.start.line + e.loc.line - 1;
    const filePath = `${id.split("?")[0]}:${e.loc.line}:${e.loc.column}`;
    message("TRANSFORM_ERROR", [filePath, e]);
    return "";
  }
  const declaration = resolveCssCallees(
    code,
    (ast) => evalCssDeclaration(ast, computedStyles, localTokens)
  );
  if (declaration && declaration?.variants) {
    Object.assign(variants || {}, defu(variants || {}, declaration?.variants || {}));
    delete declaration.variants;
  }
  return stringify(declaration, (property, value, _style, _selectors) => resolveCssProperty(property, value, _style, _selectors, Object.keys(localTokens || {}), ctx, loc));
};
function castVariants(property, value) {
  return Object.entries(value).reduce(
    (acc, [key, value2]) => {
      acc[key] = value2;
      return acc;
    },
    {}
  );
}
function resolveCssCallees(code, cb) {
  const ast = parseAst(code);
  let result = false;
  visitAst(ast, {
    visitCallExpression(path) {
      if (path.value.callee.name === "css") {
        result = defu(result || {}, cb(path.value.arguments[0]));
      }
      return this.traverse(path);
    }
  });
  return result;
}
function evalCssDeclaration(cssAst, computedStyles = {}, localTokens = {}) {
  resolveRuntimeContents(cssAst, computedStyles, localTokens);
  try {
    const _eval = eval;
    _eval(`var cssDeclaration = ${printAst(cssAst).code}`);
    return cssDeclaration;
  } catch (e) {
    return {};
  }
}

function transformVariants(code = "", variants = {}, isTs) {
  const variantsProps = resolveVariantsProps(variants, isTs);
  const sanitizedVariants = Object.entries(variants || {}).reduce(
    (acc, [key, variant]) => {
      delete variant.options;
      acc[key] = variant;
      return acc;
    },
    {}
  );
  code += `const __$pVariants = ${JSON.stringify(sanitizedVariants)}
`;
  if (variantsProps) {
    code = pushVariantsProps(code, variantsProps);
  }
  return code;
}
function pushVariantsProps(code, variantsProps) {
  const scriptAst = parseAst(code);
  let propsAst = expressionToAst(JSON.stringify(variantsProps));
  propsAst = castVariantsPropsAst(propsAst);
  visitAst(
    scriptAst,
    {
      visitCallExpression(path) {
        if (path?.value?.callee?.name === "defineProps") {
          path.value.arguments[0].properties.push(
            astTypes.builders.spreadElement(propsAst)
          );
        }
        return this.traverse(path);
      }
    }
  );
  return printAst(scriptAst).code;
}
function resolveVariantsProps(variants, isTs) {
  const props = {};
  Object.entries(variants).forEach(
    ([key, variant]) => {
      const prop = {
        required: false
      };
      const isBooleanVariant = Object.keys(variant).some((key2) => key2 === "true" || key2 === "false");
      if (isBooleanVariant) {
        prop.type = isTs ? " [Boolean, Object] as import('vue').PropType<boolean | { [key in import('pinceau').PinceauMediaQueries]?: boolean }>" : " [Boolean, Object]";
        prop.default = false;
      } else {
        const possibleValues = `'${Object.keys(variant).filter((key2) => key2 !== "options").join("' | '")}'`;
        prop.type = isTs ? ` [String, Object] as import('vue').PropType<${possibleValues} | { [key in import('pinceau').PinceauMediaQueries]?: ${possibleValues} }>` : " [String, Object]";
        prop.default = void 0;
      }
      if (variant?.options) {
        const options = variant.options;
        if (options.default) {
          prop.default = options.default;
        }
        if (options.required) {
          prop.required = options.required;
        }
        if (options.type) {
          prop.type = options.type;
        }
        if (options.validator) {
          prop.validator = options.validator?.toString();
        }
      }
      props[key] = prop;
    }
  );
  return props;
}
function castVariantsPropsAst(ast) {
  visitAst(
    ast,
    {
      visitObjectProperty(path) {
        const key = path.value?.key?.value;
        if (key === "type") {
          path.value.value = expressionToAst(path.value.value.value);
        }
        if (key === "validator") {
          path.value.value = expressionToAst(path.value.value.value);
        }
        if (key === "required" || key === "default") {
          const printedAst = printAst(path.value.value).code;
          path.value.value = expressionToAst(`${printedAst} as const`);
        }
        return this.traverse(path);
      }
    }
  );
  return ast;
}

const merger = createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) && Array.isArray(value)) {
    obj[key] = Array.from(/* @__PURE__ */ new Set([...obj[key], ...value]));
    return true;
  }
});

const STYLES_EXTENSIONS = ["css", "sass", "scss", "postcss", "less", "styl", "stylus"];
const JS_EXTENSIONS = ["js", "jsx", "mjs", "ts", "tsx", "jsx", "tsx", "js", "ts"];
const SUPPORTED_EXTENSIONS = [...STYLES_EXTENSIONS, ...JS_EXTENSIONS, "vue"];
function parsePinceauQuery(id) {
  const [filename, rawQuery] = id.split("?", 2);
  const params = new URLSearchParams(rawQuery);
  const ret = { filename, id };
  const langPart = Object.keys(Object.fromEntries(params)).find((key) => /lang\./i.test(key));
  ret.vue = params.has("vue") || id.endsWith(".vue");
  ret.global = params.has("global");
  ret.src = params.has("src");
  ret.raw = params.has("raw");
  ret.ext = path.extname(id).slice(1);
  if (params.has("type")) {
    ret.type = params.get("type");
  }
  if (params.has("blockType")) {
    ret.blockType = params.get("blockType");
  }
  if (params.has("index")) {
    ret.index = Number(params.get("index"));
  }
  if (params.has("scoped")) {
    ret.scoped = String(params.get("scoped"));
  } else if (params.has("lang")) {
    ret.lang = params.get("lang");
  }
  if (params.has("issuerPath")) {
    ret.issuerPath = params.get("issuerPath");
  }
  if (params.has("transformed")) {
    ret.transformed = true;
  }
  if (STYLES_EXTENSIONS.includes(ret.ext)) {
    ret.styles = true;
  }
  if (SUPPORTED_EXTENSIONS.includes(ret.ext)) {
    ret.transformable = true;
  }
  if (langPart) {
    const [, lang] = langPart.split(".");
    ret.lang = lang;
  }
  return ret;
}

export { SUPPORTED_EXTENSIONS as A, JS_EXTENSIONS as J, STYLES_EXTENSIONS as S, updateDebugContext as a, message as b, castVariants as c, castVariantsPropsAst as d, evalCssDeclaration as e, pushVariantsProps as f, resolveRuntimeContents as g, resolveVariantsProps as h, transformVariants as i, parseAst as j, parseVueComponent as k, expressionToAst as l, merger as m, defaultExport as n, printAst as o, parsePinceauQuery as p, astTypes as q, resolveCssCallees as r, findLineColumn as s, transformCssFunction as t, useDebugPerformance as u, visitAst as v, getDebugContext as w, debugMarker as x, fileLink as y, errorMessage as z };
