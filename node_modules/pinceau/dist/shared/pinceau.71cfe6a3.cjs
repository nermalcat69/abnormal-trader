'use strict';

const defu = require('defu');
const acorn = require('acorn');
const perf_hooks = require('perf_hooks');
const ohash = require('ohash');
const scule = require('scule');
require('fs');
require('fs/promises');
require('jiti');
const path = require('pathe');
require('vue');
require('style-dictionary-esm');
require('untyped');
const stringify = require('./pinceau.1adee1a2.cjs');
require('postcss-nested');
require('postcss-custom-properties');
require('postcss-dark-theme-class');
const compilerSfc = require('vue/compiler-sfc');
const recast = require('recast');
const typescript_js = require('recast/parsers/typescript.js');

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return n;
}

const path__namespace = /*#__PURE__*/_interopNamespaceCompat(path);
const recast__namespace = /*#__PURE__*/_interopNamespaceCompat(recast);

const useDebugPerformance = (text, debug, logOnStop = true) => {
  const isDebug = debug === 2;
  const performanceTimerStart = perf_hooks.performance.now();
  let performanceTimerStop;
  return {
    stopPerfTimer: isDebug ? stop : () => {
    },
    logPerfTimer: isDebug ? debugMarker(text, timing()) : () => {
    }
  };
  function timing() {
    const { error, success, warning } = getDebugContext();
    let count = Number(parseFloat(`${performanceTimerStop - performanceTimerStart}`).toFixed(2));
    if (isNaN(count)) {
      count = 0;
    }
    let color = success;
    if (count > 5) {
      color = warning;
    }
    if (count > 10) {
      color = error;
    }
    return color(count);
  }
  function stop(silent = false) {
    if (silent) {
      return;
    }
    performanceTimerStop = perf_hooks.performance.now();
    if (logOnStop) {
      debugMarker(text, timing());
    }
  }
};
function findLineColumn(content, index) {
  const lines = content.split("\n");
  let line;
  let column;
  lines.forEach((lineContent, lineIndex) => {
    if (lineContent.includes(index)) {
      line = lineIndex;
      column = lineContent.indexOf(index) + 1;
    }
  });
  return {
    line,
    column
  };
}

const noopHelper = (value) => value?.toString() || value;
let context = {
  // consola.withScope(' ðŸ–Œ ')
  logger: console,
  // false
  debugLevel: false,
  // chalk.bgBlue.blue
  tag: noopHelper,
  // chalk.blue
  info: noopHelper,
  // chalk.yellow
  warning: noopHelper,
  // chalk.red
  error: noopHelper,
  // chalk.green
  success: noopHelper
};
const updateDebugContext = (newContext) => {
  context = {
    ...context,
    ...newContext
  };
};
const getDebugContext = () => context;
const c = getDebugContext;
const fileLink = (id) => c().logger.log(`\u{1F517} ${c().info(id)}
`);
const errorMessage = (message2) => c().logger.log(`\u{1F6A7} ${c().warning(message2)}
`);
const DEBUG_MARKER = () => c().tag(" DEBUG ");
const debugMarker = (text, timing) => c().logger.info(`${DEBUG_MARKER()} ${text} ${timing ? `[${timing}ms]` : ""}`);
const messages = {
  /**
   * Errors
   */
  TRANSFORM_ERROR: (debugLevel, id, error) => {
    c().logger.error("Pinceau could not transform this file:");
    fileLink(id);
    error?.message && errorMessage(error.message);
  },
  CONFIG_RESOLVE_ERROR: (debugLevel, path, error) => {
    c().logger.error("Pinceau could not resolve this configuration file:");
    const loc = error?.loc?.start?.line ? `${error.loc.start.line}:${error.loc.start.column}` : "";
    fileLink(`${path}${loc}`);
    error?.message && errorMessage(error.message);
  },
  CONFIG_BUILD_ERROR: (debugLevel, error) => {
    c().logger.error("Pinceau could not build your design tokens configuration!\n");
    c().logger.log(error);
  },
  SELECTOR_CONFLICT: (debugLevel, selector) => {
    c().logger.warn("Pinceau detected a conflicting selector:");
    c().logger.log(`\u2753 ${selector}
`);
    c().logger.log("If you want to combine `@dark` or `@light` with `html` selector, consider using `html.dark` or `html.light`.\n");
  },
  UTIL_NAME_CONFLICT: (debugLevel, name) => {
    c().logger.warn("Pinceau detected a conflicting util name:");
    c().logger.log(`\u2753 ${name}
`);
    c().logger.log("Util properties must be valid const names.\n");
    c().logger.log("Learn more about `const` name limitations: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types\n");
  },
  WRONG_TOKEN_NAMING: (debugLevel, token) => {
    c().logger.error(`Pinceau detected an invalid token name: ${c().error(token?.path?.join("-") || "Unknown path!")}`);
    c().logger.log("Token paths can not contains the following characters: `.` or `-`\n");
    c().logger.log("These paths keys also has to only contains characters supported in CSS stylesheets.\n");
  },
  /**
   * Warnings (debugLevel >= 1)
   */
  CONFIG_RESOLVED: (debugLevel, resolvedConfig) => {
    if (debugLevel === 2) {
      c().logger.log("\u2705 Pinceau loaded with following configuration sources:\n");
      resolvedConfig.sources.forEach((path) => fileLink(path));
      c().logger.log("\u{1F6A7} Disable this message by setting `debug: false` option.\n");
      c().logger.log(`\u{1F6A7} Current debug level: ${c().info(Number(debugLevel))}
`);
    }
  },
  TOKEN_NOT_FOUND: (debugLevel, path, options) => {
    if (debugLevel && options?.loc?.query && !options.loc.query?.type) {
      c().logger.warn(`Token not found in static CSS: ${c().error(path)}`);
      const { line: lineOffset, column: columnOffset } = findLineColumn(options.loc.source, `{${path}}`);
      if (!options.loc?.start) {
        options.loc.start = findLineColumn(options.loc.source, "css({");
      }
      const line = (options.loc?.start?.line || 0) + lineOffset;
      const column = (options.loc?.start?.column || 0) + columnOffset;
      c().logger.log(`\u{1F517} ${options.loc.query.filename}${line && column ? `:${line}:${column}
` : ""}`);
    }
  },
  SCHEMA_BUILD_ERROR: (debugLevel, _) => {
    if (debugLevel) {
      c().logger.warn("Pinceau could not build your schema.ts file!");
      c().logger.log("Design tokens editor might be hidden from Nuxt Studio.");
    }
  },
  RUNTIME_FEATURES_CONFLICT: (debugLevel, id) => {
    if (debugLevel) {
      c().logger.error("This component uses runtime features even though `runtime` is set to false in options:");
      fileLink(id);
    }
  }
};
const message = (id, options) => messages[id].bind(void 0, c().debugLevel, ...options)();

function parseAst(source, options) {
  return recast__namespace.parse(source, defu.defu({ parser: { parse: typescript_js.parse } }, options));
}
function parseVueComponent(source, options = {}) {
  return compilerSfc.parse(source, options);
}
function expressionToAst(type, leftSide = "const toAst = ", kind = "js") {
  const parsed = recast__namespace.parse(`${leftSide}${type}`, { parser: { parse: typescript_js.parse } });
  return kind === "js" ? parsed.program.body[0].declarations[0].init : parsed.program.body[0].typeAnnotation;
}
function defaultExport(node) {
  return node.program.body.find((n) => n.type === "ExportDefaultDeclaration")?.declaration;
}
const visitAst = recast__namespace.visit;
const printAst = recast__namespace.print;
const astTypes = recast__namespace.types;

function resolveRuntimeContents(cssAst, computedStyles = {}, localTokens = {}) {
  visitAst(
    cssAst,
    {
      visitObjectProperty(path) {
        if (path.value) {
          const key = path?.value?.key?.name || path?.value?.key?.value;
          const valueType = path?.value?.value?.type;
          if (key.startsWith("--") && !localTokens[key]) {
            localTokens[key] = path.value.value;
          }
          if (valueType === "ArrowFunctionExpression" || valueType === "FunctionExpression") {
            const computedStyleKey = scule.camelCase(key.replace(/--/g, "__"));
            const id = `_${ohash.hash(path.value.loc.start).slice(0, 3)}_${computedStyleKey}`;
            computedStyles[id] = printAst(path.value.value.body).code;
            path.replace(
              astTypes.builders.objectProperty(
                path.value.key,
                astTypes.builders.stringLiteral(`var(--${scule.kebabCase(id)})`)
              )
            );
          }
        }
        return this.traverse(path);
      }
    }
  );
}

const transformCssFunction = (id, code = "", variants, computedStyles, localTokens, ctx, loc) => {
  try {
    acorn.parse(code, { ecmaVersion: "latest" });
  } catch (e) {
    e.loc.line = loc.start.line + e.loc.line - 1;
    const filePath = `${id.split("?")[0]}:${e.loc.line}:${e.loc.column}`;
    message("TRANSFORM_ERROR", [filePath, e]);
    return "";
  }
  const declaration = resolveCssCallees(
    code,
    (ast) => evalCssDeclaration(ast, computedStyles, localTokens)
  );
  if (declaration && declaration?.variants) {
    Object.assign(variants || {}, defu.defu(variants || {}, declaration?.variants || {}));
    delete declaration.variants;
  }
  return stringify.stringify(declaration, (property, value, _style, _selectors) => stringify.resolveCssProperty(property, value, _style, _selectors, Object.keys(localTokens || {}), ctx, loc));
};
function castVariants(property, value) {
  return Object.entries(value).reduce(
    (acc, [key, value2]) => {
      acc[key] = value2;
      return acc;
    },
    {}
  );
}
function resolveCssCallees(code, cb) {
  const ast = parseAst(code);
  let result = false;
  visitAst(ast, {
    visitCallExpression(path) {
      if (path.value.callee.name === "css") {
        result = defu.defu(result || {}, cb(path.value.arguments[0]));
      }
      return this.traverse(path);
    }
  });
  return result;
}
function evalCssDeclaration(cssAst, computedStyles = {}, localTokens = {}) {
  resolveRuntimeContents(cssAst, computedStyles, localTokens);
  try {
    const _eval = eval;
    _eval(`var cssDeclaration = ${printAst(cssAst).code}`);
    return cssDeclaration;
  } catch (e) {
    return {};
  }
}

function transformVariants(code = "", variants = {}, isTs) {
  const variantsProps = resolveVariantsProps(variants, isTs);
  const sanitizedVariants = Object.entries(variants || {}).reduce(
    (acc, [key, variant]) => {
      delete variant.options;
      acc[key] = variant;
      return acc;
    },
    {}
  );
  code += `const __$pVariants = ${JSON.stringify(sanitizedVariants)}
`;
  if (variantsProps) {
    code = pushVariantsProps(code, variantsProps);
  }
  return code;
}
function pushVariantsProps(code, variantsProps) {
  const scriptAst = parseAst(code);
  let propsAst = expressionToAst(JSON.stringify(variantsProps));
  propsAst = castVariantsPropsAst(propsAst);
  visitAst(
    scriptAst,
    {
      visitCallExpression(path) {
        if (path?.value?.callee?.name === "defineProps") {
          path.value.arguments[0].properties.push(
            astTypes.builders.spreadElement(propsAst)
          );
        }
        return this.traverse(path);
      }
    }
  );
  return printAst(scriptAst).code;
}
function resolveVariantsProps(variants, isTs) {
  const props = {};
  Object.entries(variants).forEach(
    ([key, variant]) => {
      const prop = {
        required: false
      };
      const isBooleanVariant = Object.keys(variant).some((key2) => key2 === "true" || key2 === "false");
      if (isBooleanVariant) {
        prop.type = isTs ? " [Boolean, Object] as import('vue').PropType<boolean | { [key in import('pinceau').PinceauMediaQueries]?: boolean }>" : " [Boolean, Object]";
        prop.default = false;
      } else {
        const possibleValues = `'${Object.keys(variant).filter((key2) => key2 !== "options").join("' | '")}'`;
        prop.type = isTs ? ` [String, Object] as import('vue').PropType<${possibleValues} | { [key in import('pinceau').PinceauMediaQueries]?: ${possibleValues} }>` : " [String, Object]";
        prop.default = void 0;
      }
      if (variant?.options) {
        const options = variant.options;
        if (options.default) {
          prop.default = options.default;
        }
        if (options.required) {
          prop.required = options.required;
        }
        if (options.type) {
          prop.type = options.type;
        }
        if (options.validator) {
          prop.validator = options.validator?.toString();
        }
      }
      props[key] = prop;
    }
  );
  return props;
}
function castVariantsPropsAst(ast) {
  visitAst(
    ast,
    {
      visitObjectProperty(path) {
        const key = path.value?.key?.value;
        if (key === "type") {
          path.value.value = expressionToAst(path.value.value.value);
        }
        if (key === "validator") {
          path.value.value = expressionToAst(path.value.value.value);
        }
        if (key === "required" || key === "default") {
          const printedAst = printAst(path.value.value).code;
          path.value.value = expressionToAst(`${printedAst} as const`);
        }
        return this.traverse(path);
      }
    }
  );
  return ast;
}

const merger = defu.createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) && Array.isArray(value)) {
    obj[key] = Array.from(/* @__PURE__ */ new Set([...obj[key], ...value]));
    return true;
  }
});

const STYLES_EXTENSIONS = ["css", "sass", "scss", "postcss", "less", "styl", "stylus"];
const JS_EXTENSIONS = ["js", "jsx", "mjs", "ts", "tsx", "jsx", "tsx", "js", "ts"];
const SUPPORTED_EXTENSIONS = [...STYLES_EXTENSIONS, ...JS_EXTENSIONS, "vue"];
function parsePinceauQuery(id) {
  const [filename, rawQuery] = id.split("?", 2);
  const params = new URLSearchParams(rawQuery);
  const ret = { filename, id };
  const langPart = Object.keys(Object.fromEntries(params)).find((key) => /lang\./i.test(key));
  ret.vue = params.has("vue") || id.endsWith(".vue");
  ret.global = params.has("global");
  ret.src = params.has("src");
  ret.raw = params.has("raw");
  ret.ext = path__namespace.extname(id).slice(1);
  if (params.has("type")) {
    ret.type = params.get("type");
  }
  if (params.has("blockType")) {
    ret.blockType = params.get("blockType");
  }
  if (params.has("index")) {
    ret.index = Number(params.get("index"));
  }
  if (params.has("scoped")) {
    ret.scoped = String(params.get("scoped"));
  } else if (params.has("lang")) {
    ret.lang = params.get("lang");
  }
  if (params.has("issuerPath")) {
    ret.issuerPath = params.get("issuerPath");
  }
  if (params.has("transformed")) {
    ret.transformed = true;
  }
  if (STYLES_EXTENSIONS.includes(ret.ext)) {
    ret.styles = true;
  }
  if (SUPPORTED_EXTENSIONS.includes(ret.ext)) {
    ret.transformable = true;
  }
  if (langPart) {
    const [, lang] = langPart.split(".");
    ret.lang = lang;
  }
  return ret;
}

exports.JS_EXTENSIONS = JS_EXTENSIONS;
exports.STYLES_EXTENSIONS = STYLES_EXTENSIONS;
exports.SUPPORTED_EXTENSIONS = SUPPORTED_EXTENSIONS;
exports.astTypes = astTypes;
exports.castVariants = castVariants;
exports.castVariantsPropsAst = castVariantsPropsAst;
exports.debugMarker = debugMarker;
exports.defaultExport = defaultExport;
exports.errorMessage = errorMessage;
exports.evalCssDeclaration = evalCssDeclaration;
exports.expressionToAst = expressionToAst;
exports.fileLink = fileLink;
exports.findLineColumn = findLineColumn;
exports.getDebugContext = getDebugContext;
exports.merger = merger;
exports.message = message;
exports.parseAst = parseAst;
exports.parsePinceauQuery = parsePinceauQuery;
exports.parseVueComponent = parseVueComponent;
exports.printAst = printAst;
exports.pushVariantsProps = pushVariantsProps;
exports.resolveCssCallees = resolveCssCallees;
exports.resolveRuntimeContents = resolveRuntimeContents;
exports.resolveVariantsProps = resolveVariantsProps;
exports.transformCssFunction = transformCssFunction;
exports.transformVariants = transformVariants;
exports.updateDebugContext = updateDebugContext;
exports.useDebugPerformance = useDebugPerformance;
exports.visitAst = visitAst;
