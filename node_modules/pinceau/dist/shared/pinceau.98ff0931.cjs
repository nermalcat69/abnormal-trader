'use strict';

const query = require('./pinceau.71cfe6a3.cjs');
require('ohash');
require('scule');
const stringify = require('./pinceau.1adee1a2.cjs');
const fs = require('fs');
const promises = require('fs/promises');
const createJITI = require('jiti');
const path = require('pathe');
require('perf_hooks');
require('vue');
const StyleDictionary = require('style-dictionary-esm');
const untyped = require('untyped');
const postCssNested = require('postcss-nested');
const postCssCustomProperties = require('postcss-custom-properties');
const postCssDarkThemeClass = require('postcss-dark-theme-class');
require('defu');
require('acorn');
require('vue/compiler-sfc');
require('recast');
require('recast/parsers/typescript.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const createJITI__default = /*#__PURE__*/_interopDefaultCompat(createJITI);
const StyleDictionary__default = /*#__PURE__*/_interopDefaultCompat(StyleDictionary);
const postCssNested__default = /*#__PURE__*/_interopDefaultCompat(postCssNested);
const postCssCustomProperties__default = /*#__PURE__*/_interopDefaultCompat(postCssCustomProperties);
const postCssDarkThemeClass__default = /*#__PURE__*/_interopDefaultCompat(postCssDarkThemeClass);

function transformAddPinceauClass(code) {
  if (code.includes("$pinceau")) {
    return code;
  }
  let firstTag = code.match(/<([a-zA-Z]+)([^>]+)*>/);
  if (firstTag?.[0]) {
    const _source = String(firstTag[0]);
    if (_source.includes(":class")) {
      const existingAttr = _source.match(/:class="([^"]+)"/);
      if (existingAttr) {
        let attrAst = query.expressionToAst(existingAttr[1]);
        const newAttrAst = query.astTypes.builders.identifier("$pinceau");
        switch (attrAst.type) {
          case "ArrayExpression":
            attrAst.elements.push(newAttrAst);
            break;
          case "StringLiteral":
          case "Literal":
            attrAst = query.astTypes.builders.arrayExpression([
              existingAttr
            ]);
            break;
          case "ObjectExpression":
            attrAst = query.astTypes.builders.arrayExpression([
              attrAst,
              newAttrAst
            ]);
            break;
        }
        firstTag = _source.replace(existingAttr[1], query.printAst(attrAst).code);
      }
    } else if (_source.includes("/>")) {
      firstTag = _source.replace("/>", ' :class="[$pinceau]" />');
    } else {
      firstTag = _source.replace(">", ' :class="[$pinceau]">');
    }
    code = code.replace(_source, firstTag);
  }
  return code;
}

function replaceStyleTs(code, id) {
  if (id.endsWith(".vue") && !id.includes("?")) {
    const styleTagRe = /<style\b(.*?)\blang=['"][tj]sx?['"](.*?)>/g;
    if (code.match(styleTagRe)) {
      return code.replace(styleTagRe, '<style$1lang="postcss" transformed$2>');
    }
  }
  return code;
}

function transformAddPropsKey(code, add = true) {
  try {
    const ast = query.parseAst(code);
    let propsKey;
    let hasDefineProps;
    let hasWithDefaults;
    query.visitAst(
      ast,
      {
        // Visit <script setup> variable declarations to find defineProps
        visitVariableDeclaration(path) {
          if (path.value?.declarations?.[0]?.init?.callee?.name === "defineProps") {
            propsKey = path.value.declarations[0].id.name;
            return false;
          }
          return this.traverse(path);
        },
        visitCallExpression(path) {
          if (path.node.callee.name === "defineProps") {
            hasDefineProps = true;
            return false;
          }
          if (path.node.callee.name === "withDefaults") {
            hasWithDefaults = true;
          }
          return this.traverse(path);
        }
      }
    );
    if (add && hasDefineProps && !propsKey) {
      code = code.replace(
        /defineProps|withDefaults\(defineProps/,
        () => {
          propsKey = "__$pProps";
          return `const __$pProps = ${hasWithDefaults ? "withDefaults(defineProps" : "defineProps"}`;
        }
      );
    }
    return { propsKey, code };
  } catch (e) {
    return void 0;
  }
}

const transformDtHelper = (code, ctx, wrapper = void 0) => {
  const replace = (content) => `${wrapper || ""}${content}${wrapper || ""}`;
  return code.replace(stringify.dtRegex, (_, ...code2) => {
    const path = code2?.[0];
    const arg = code2?.[2];
    if (arg) {
      const token = ctx.$tokens(path, { key: arg || "variable" });
      if (token) {
        return replace(token);
      }
    }
    return replace(`var(--${path.split(".").join("-")})`);
  });
};

function transformStyle(code = "", ctx, loc) {
  code = transformDtHelper(code, ctx);
  code = transformMediaQueries(code, ctx, loc);
  code = transformScheme(code, "dark");
  code = transformScheme(code, "light");
  return code;
}
function transformScheme(code = "", scheme) {
  const schemesRegex = {
    light: stringify.lightRegex,
    dark: stringify.darkRegex
  };
  code = code.replace(
    schemesRegex[scheme],
    () => `@media (prefers-color-scheme: ${scheme}) {`
  );
  return code;
}
function transformMediaQueries(code = "", ctx, loc) {
  const mediaQueries = ctx.$tokens("media", { key: void 0, loc });
  code = code.replace(
    stringify.mqCssRegex,
    (declaration, query) => {
      const mediaQuery = mediaQueries?.[query];
      if (!mediaQuery) {
        return declaration;
      }
      return `@media ${mediaQuery.value} {`;
    }
  );
  return code;
}

function transformVueSFC(code, query$1, magicString, ctx) {
  const variants = {};
  const computedStyles = {};
  const localTokens = {};
  const parsedComponent = query.parseVueComponent(code, { filename: query$1.id });
  if (parsedComponent?.descriptor?.styles) {
    resolveStyle(query$1.id, parsedComponent, magicString, variants, computedStyles, localTokens, ctx, query$1);
  }
  const hasRuntimeStyles = Object.keys(variants).length > 0 || Object.keys(computedStyles).length > 0;
  if (parsedComponent?.descriptor?.template) {
    resolveTemplate(query$1.id, parsedComponent, magicString, ctx, hasRuntimeStyles);
  }
  if (parsedComponent?.descriptor?.scriptSetup) {
    resolveScriptSetup(query$1.id, parsedComponent, magicString, variants, computedStyles, ctx, parsedComponent.descriptor.scriptSetup.lang === "ts");
  }
  return { code, magicString, variants, computedStyles, localTokens };
}
function resolveStyleQuery(code, magicString, query$1, ctx, loc) {
  if (query$1.lang === "ts") {
    code = query.transformCssFunction(query$1.id, code, {}, {}, {}, ctx, loc);
  }
  code = transformStyle(code, ctx);
  return { code, magicString };
}
function resolveTemplate(_, parsedComponent, magicString, ctx, hasRuntimeStyles) {
  const templateContent = parsedComponent.descriptor.template;
  let newTemplateContent = templateContent.content;
  newTemplateContent = transformDtHelper(newTemplateContent, ctx, "'");
  if (ctx.options.runtime && hasRuntimeStyles) {
    newTemplateContent = transformAddPinceauClass(newTemplateContent);
  }
  if (templateContent.loc.end?.offset && templateContent.loc.end?.offset > templateContent.loc.start.offset) {
    magicString.overwrite(
      templateContent.loc.start.offset,
      templateContent.loc.end.offset,
      newTemplateContent
    );
  }
}
function resolveStyle(id, parsedComponent, magicString, variants, computedStyles, localTokens, ctx, query$1) {
  const styles = parsedComponent.descriptor.styles;
  styles.forEach(
    (styleBlock) => {
      const { loc, content } = styleBlock;
      let code = content;
      if (styleBlock.attrs.lang === "ts" || styleBlock.lang === "ts" || styleBlock.attrs?.transformed) {
        code = query.transformCssFunction(id, code, variants, computedStyles, localTokens, ctx, { query: query$1, ...loc });
      }
      code = transformStyle(code, ctx);
      magicString.remove(loc.start.offset, loc.end.offset);
      magicString.appendRight(loc.end.offset, `
${code}
`);
    }
  );
}
function resolveScriptSetup(id, parsedComponent, magicString, variants, computedStyles, ctx, isTs) {
  const scriptSetup = parsedComponent.descriptor.scriptSetup;
  const hasVariants = Object.keys(variants).length;
  const hasComputedStyles = Object.keys(computedStyles).length;
  let code = scriptSetup.content;
  code = transformDtHelper(code, ctx, "`");
  code = code.replace(stringify.variantsRegex, () => "");
  if (ctx.options.runtime) {
    if (hasVariants || hasComputedStyles) {
      code = transformAddRuntimeImports(code);
    }
    if (hasVariants) {
      code = query.transformVariants(code, variants, isTs);
    }
    if (hasComputedStyles) {
      code = transformComputedStyles(code, computedStyles);
    }
    if (hasVariants || hasComputedStyles) {
      code = transformFinishRuntimeSetup(code, hasComputedStyles, hasVariants, computedStyles);
    }
  } else if (hasVariants || hasComputedStyles) {
    query.message("RUNTIME_FEATURES_CONFLICT", [id]);
  }
  magicString.overwrite(scriptSetup.loc.start.offset, scriptSetup.loc.end.offset, code);
}
function transformComputedStyles(code, computedStyles) {
  code = Object.entries(computedStyles).map(([key, styleFunction]) => `
const ${key} = computed(() => ((props = __$pProps) => ${styleFunction})())
`).join("") + code;
  return code;
}
function transformAddRuntimeImports(code) {
  code = `import { usePinceauRuntime } from 'pinceau/runtime'
${code}`;
  const vueImports = [];
  if (!code.match(/reactive\(/gm)) {
    vueImports.push("reactive");
  }
  if (!code.match(/computed\(/gm)) {
    vueImports.push("computed");
  }
  if (!code.match(/getCurrentInstance\(/gm)) {
    vueImports.push("getCurrentInstance");
  }
  if (!code.match(/ref\(/gm)) {
    vueImports.push("ref");
  }
  if (vueImports.length) {
    code = `import { ${vueImports.join(", ")} } from 'vue'
${code}`;
  }
  const { propsKey, code: _code } = transformAddPropsKey(code);
  code = _code;
  if (propsKey && propsKey === "__$pProps") {
    return code;
  }
  code += `
const __$pProps = ${propsKey || "{}"}
`;
  return code;
}
function transformFinishRuntimeSetup(newScriptSetup, hasComputedStyles, hasVariants, computedStyles) {
  newScriptSetup += [
    `
${hasVariants || hasComputedStyles ? "const { $pinceau } = " : ""}`,
    "usePinceauRuntime(",
    "__$pProps, ",
    `${hasVariants ? "__$pVariants" : "undefined"}, `,
    `${hasComputedStyles ? `{ ${Object.keys(computedStyles).map((key) => `${key}`).join(",")} }` : "undefined"}`,
    ")\n"
  ].join("");
  return newScriptSetup;
}

function isSafeConstName(name) {
  if (!/^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name)) {
    return false;
  }
  if (["break", "case", "catch", "class", "const", "continue", "debugger", "default", "delete", "do", "else", "enum", "export", "extends", "false", "finally", "for", "function", "if", "implements", "import", "in", "instanceof", "interface", "let", "new", "null", "package", "private", "protected", "public", "return", "static", "super", "switch", "this", "throw", "true", "try", "typeof", "var", "void", "while", "with", "yield"].includes(name)) {
    return false;
  }
  return true;
}

function registerAliases(config, options) {
  if (!config?.resolve) {
    config.resolve = {};
  }
  if (!config.resolve?.alias) {
    config.resolve.alias = {};
  }
  if (options?.outputDir) {
    config.resolve.alias["#pinceau/theme"] = path.join(options.outputDir, "/index.ts");
    config.resolve.alias["#pinceau/utils"] = path.join(options.outputDir, "/utils.ts");
  }
}
function registerPostCssPlugins(config, options) {
  if (!config?.css) {
    config.css = {};
  }
  if (!config.css?.postcss) {
    config.css.postcss = {};
  }
  if (!config.css?.postcss.plugins) {
    config.css.postcss.plugins = [];
  }
  config.css.postcss.plugins.push(
    postCssNested__default,
    postCssCustomProperties__default
  );
  if (options?.colorSchemeMode === "class") {
    config.css.postcss.plugins.push(
      postCssDarkThemeClass__default({
        darkSelector: ".dark",
        lightSelector: ".light"
      })
    );
  }
}

const objectPaths = (data) => {
  const output = [];
  function step(obj, prev) {
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      const isarray = Array.isArray(value);
      const type = Object.prototype.toString.call(value);
      const isobject = type === "[object Object]" || type === "[object Array]";
      const newKey = prev ? `${prev}.${key}` : key;
      if ((typeof value?.value !== "undefined" || typeof value === "string") && !output.includes(newKey)) {
        output.push([newKey, value?.value || value]);
        return;
      }
      if (!isarray && isobject && Object.keys(value).length) {
        return step(value, newKey);
      }
    });
  }
  step(data);
  return output;
};
const flattenTokens = (data, toValue = false, raw = true) => {
  return stringify.walkTokens(data, (value) => {
    const toRet = toValue ? value?.value : {
      value: value?.value,
      variable: value?.attributes?.variable
    };
    if (!toValue && raw && value?.original?.value) {
      toRet.raw = value.original.value;
    }
    return toRet;
  });
};

const loadVueStyle = (query$1, ctx) => {
  const { filename } = query$1;
  const file = fs.readFileSync(filename, "utf8");
  if (!file) {
    return;
  }
  const { descriptor } = query.parseVueComponent(file, { filename });
  if (!descriptor) {
    return;
  }
  const style = descriptor?.styles?.[query$1.index];
  if (!style?.content) {
    return;
  }
  let source = style.content;
  const loc = { query: query$1, ...style.loc };
  if (style.attrs.lang === "ts") {
    source = query.transformCssFunction(query$1.id, source, void 0, void 0, void 0, ctx, loc);
  }
  return transformStyle(source, ctx, loc);
};

function resolveDefinitions(content, mediaQueriesKeys, filePath) {
  const definitions = {};
  query.visitAst(
    query.defaultExport(query.parseAst(content)),
    {
      visitObjectProperty(path) {
        const tokenNode = getTokenNode(path, mediaQueriesKeys);
        if (tokenNode) {
          const key = resolvePropertyKeyPath(tokenNode);
          if (!key) {
            return false;
          }
          if ((key.startsWith("utils.") || key.startsWith("media.")) && key.split(".").length > 2) {
            return false;
          }
          definitions[key] = {
            uri: filePath,
            range: {
              start: path.value.loc.start,
              end: path.value.loc.end
            }
          };
          if (key.startsWith("utils.")) {
            definitions[key].content = query.printAst(tokenNode.value.value).code;
          }
          return false;
        }
        if (tokenNode === false) {
          return false;
        }
        return this.traverse(path);
      }
    }
  );
  return definitions;
}
function isResponsiveToken(node, mqKeys) {
  const properties = node?.value?.properties || [];
  const propertiesKeys = properties.map((node2) => node2?.key?.value?.toString() || node2?.key?.name?.toString());
  if (propertiesKeys.includes("initial") && propertiesKeys.some((propKey) => mqKeys.includes(propKey))) {
    return true;
  }
}
function isTokenLike(node) {
  const properties = node?.value?.properties || [];
  const propertiesKeys = properties.map((node2) => node2?.key?.value?.toString() || node2?.key?.name?.toString());
  if (propertiesKeys.includes("value")) {
    return true;
  }
}
function getTokenNode(node, mqKeys) {
  if (isResponsiveToken(node?.parent, mqKeys)) {
    return node?.parent;
  }
  if (isTokenLike(node?.parent)) {
    return node?.parent;
  }
  if (node?.value?.key?.name === "$schema" || node?.parent?.value?.key?.name === "$schema") {
    return false;
  }
  if (["FunctionDeclaration", "ObjectExpression"].includes(node?.value?.value?.type)) {
    return;
  }
  return node;
}
function resolvePropertyKeyPath(node) {
  let currentPath = node;
  const currentKeyPath = [];
  while (currentPath.parent) {
    const path = currentPath?.value?.key?.value?.toString() || currentPath?.value?.key?.name?.toString();
    if (path) {
      currentKeyPath.push(path);
    }
    currentPath = currentPath?.parent || void 0;
  }
  return currentKeyPath.filter(Boolean).reverse().join(".");
}

const extensions = [".js", ".ts", ".mjs", ".cjs", ".json"];
async function loadLayers({
  cwd = process.cwd(),
  configLayers,
  configFileName = "tokens.config",
  definitions = true
}) {
  const sources = resolveConfigSources({ cwd, configLayers, configFileName });
  const result = {
    config: {},
    definitions: {},
    sources: []
  };
  for (const layer of sources) {
    if (layer.tokens) {
      const mediaQueriesKeys = resolveMediaQueriesKeys(result.config);
      result.config = query.merger(stringify.normalizeConfig(layer.tokens, mediaQueriesKeys), result.config);
      continue;
    }
    const { path, config, definitions: resolvedDefinitions } = await resolveConfigLayer({ cwd, configFileName, definitions }, layer);
    if (path) {
      result.sources.push(path);
    }
    if (config) {
      result.config = query.merger(config, result.config);
    }
    if (definitions) {
      result.definitions = Object.assign(result?.definitions || {}, resolvedDefinitions);
    }
  }
  return result;
}
function resolveConfigFile(configFile, definitions = true) {
  const { config, content, path } = configFile;
  const mediaQueriesKeys = resolveMediaQueriesKeys(config);
  const normalizedConfig = stringify.normalizeConfig(config, mediaQueriesKeys, false);
  let resolvedDefinitions;
  if (definitions) {
    try {
      resolvedDefinitions = resolveDefinitions(content, mediaQueriesKeys, path);
    } catch (e) {
    }
  }
  return {
    path,
    content,
    definitions: resolvedDefinitions,
    config: normalizedConfig
  };
}
async function resolveConfigLayer({
  configFileName,
  cwd,
  definitions
}, layer) {
  const empty = (path2 = void 0) => ({ path: path2, content: "", config: {}, schema: {}, definitions: {} });
  let path$1 = "";
  if (typeof layer === "string") {
    path$1 = path.resolve(layer);
  } else if (typeof layer === "object") {
    path$1 = path.resolve(layer?.cwd || cwd, layer?.configFileName || configFileName);
  } else {
    return empty();
  }
  let filePath = "";
  let ext;
  extensions.some((_ext) => {
    if (fs.existsSync(path$1 + _ext)) {
      filePath = path$1 + _ext;
      ext = _ext;
      return true;
    }
    return false;
  });
  if (!filePath) {
    return empty();
  }
  try {
    return resolveConfigFile(
      await importConfigFile({ path: filePath, ext }),
      definitions
    );
  } catch (e) {
    query.message("CONFIG_RESOLVE_ERROR", [filePath, e]);
    return empty(filePath);
  }
}
function resolveConfigSources({
  cwd = process.cwd(),
  configLayers = [],
  configFileName = "tokens.config"
}) {
  let sources = configLayers.reduce(
    (acc, layerOrPath) => {
      if (typeof layerOrPath === "object") {
        acc.push(layerOrPath);
        return acc;
      }
      if (typeof layerOrPath === "string") {
        acc.push({
          cwd: layerOrPath,
          configFileName
        });
        return acc;
      }
      return acc;
    },
    []
  );
  if (cwd && !sources.some((source) => source.cwd === cwd)) {
    sources.unshift({
      cwd,
      configFileName
    });
  }
  sources = [...new Set(sources)];
  return sources.reverse();
}
async function importConfigFile({ path, ext }) {
  const content = await promises.readFile(path, "utf-8");
  if (ext === ".json") {
    const config = JSON.parse(content);
    return {
      path,
      content,
      config
    };
  }
  const configImport = createJITI__default(path, {
    interopDefault: true,
    requireCache: false,
    esmResolve: true
  })(path);
  return {
    path,
    content,
    config: configImport
  };
}
function resolveMediaQueriesKeys(config) {
  let mediaQueriesKeys = ["dark", "light", "initial"];
  if (config.media && config.media.length) {
    mediaQueriesKeys = [...mediaQueriesKeys, ...Object.keys(config.media)];
  }
  return mediaQueriesKeys;
}

function usePinceauConfigContext(options, getViteServer, getTransformed, dispatchConfigUpdate) {
  let cwd = options?.cwd ?? process.cwd();
  let sources = [];
  let resolvedConfig = {};
  let ready = reloadConfig();
  async function reloadConfig(newOptions = options) {
    const result = await loadLayers(newOptions || options);
    cwd = newOptions?.cwd ?? process.cwd();
    resolvedConfig = result.config;
    sources = result.sources;
    if (dispatchConfigUpdate) {
      dispatchConfigUpdate(result);
    }
    if (options?.configResolved) {
      options.configResolved(result);
    }
    return result;
  }
  async function updateCwd(newCwd) {
    if (newCwd !== cwd) {
      cwd = newCwd;
      ready = reloadConfig();
    }
    return await ready;
  }
  async function onConfigChange(p) {
    if (!sources.includes(p)) {
      return;
    }
    const viteServer = getViteServer();
    await reloadConfig();
    const ids = [...stringify.outputFileNames];
    getTransformed().forEach((transformed) => !ids.includes(transformed) && ids.push(transformed));
    for (const id of ids) {
      const _module = viteServer.moduleGraph.getModuleById(id);
      if (!_module) {
        continue;
      }
      viteServer.reloadModule(_module);
    }
  }
  function registerConfigWatchers() {
    if (!sources.length) {
      return;
    }
    const viteServer = getViteServer();
    viteServer.watcher.add(sources);
    viteServer.watcher.on("change", onConfigChange);
  }
  return {
    get ready() {
      return ready;
    },
    get cwd() {
      return cwd;
    },
    updateCwd,
    sources,
    reloadConfig,
    resolvedConfig,
    registerConfigWatchers
  };
}

const stringifyUtils = (value, definitions) => {
  const entries = Object.entries(value);
  return entries.reduce(
    (acc, [key, value2]) => {
      if (!isSafeConstName(key)) {
        query.message("UTIL_NAME_CONFLICT", [key]);
        return acc;
      }
      if (definitions[`utils.${key}`]?.content) {
        acc += `export const ${key} = ${definitions[`utils.${key}`].content}

`;
        return acc;
      }
      if (typeof value2 === "function") {
        acc += `export const ${key} = ${String(value2)}

`;
      } else {
        acc += `export const ${key} = ${JSON.stringify(value2, null, 4)}

`;
      }
      return acc;
    },
    ""
  );
};
const enhanceTokenPaths = (value = []) => {
  const tokensLiteralNodes = [];
  value.forEach(([keyPath]) => {
    tokensLiteralNodes.push(
      query.astTypes.builders.tsLiteralType(query.astTypes.builders.stringLiteral(keyPath))
    );
  });
  const ast = query.astTypes.builders.tsTypeAliasDeclaration(
    query.astTypes.builders.identifier("GeneratedPinceauPaths"),
    query.astTypes.builders.tsUnionType(tokensLiteralNodes)
  );
  return query.printAst(ast).code;
};
function tsFull(tokensObject) {
  let result = "";
  const flattenedTokens = flattenTokens(tokensObject);
  if (Object.keys(flattenedTokens).length) {
    result += `export const theme = ${JSON.stringify(flattenedTokens, null, 2)} as const

`;
  } else {
    result += "export const theme = undefined\n\n";
  }
  result += "export type GeneratedPinceauTheme = typeof theme\n\n";
  const tokensPaths = objectPaths(tokensObject);
  if (tokensPaths.length) {
    result += `export ${enhanceTokenPaths(tokensPaths)}

`;
  } else {
    result += "export type GeneratedPinceauPaths = undefined\n\n";
  }
  result += "export default theme";
  return result;
}
const cssFull = (dictionary, options, responsiveTokens, colorSchemeMode) => {
  const { formattedVariables } = StyleDictionary__default.formatHelpers;
  const tokens = {
    initial: []
  };
  stringify.walkTokens(
    dictionary.tokens,
    (token) => {
      if (typeof token?.value === "object" && token?.value?.initial) {
        Object.entries(token.value).forEach(([media, value]) => {
          if (!tokens[media]) {
            tokens[media] = [];
          }
          tokens[media].push({
            ...token,
            attributes: {
              ...token?.attributes || {},
              media
            },
            value
          });
        });
        return token;
      }
      tokens.initial.push(token);
      return token;
    }
  );
  let css = "";
  Object.entries(tokens).forEach(
    ([key, value]) => {
      const formattedContent = formattedVariables({ format: "css", dictionary: { ...dictionary, allTokens: value }, outputReferences: true, formatting: { lineSeparator: "", indentation: "", prefix: "" } });
      css += stringify.resolveThemeRule(key, formattedContent, dictionary.tokens, colorSchemeMode);
    }
  );
  return css.replace(/(\n|\s\s)/g, "");
};
const definitionsFull = (definitions) => {
  return `export const definitions = ${JSON.stringify(definitions, null, 2)} as const`;
};
function schemaFull(schema) {
  let result = `export const schema = ${JSON.stringify({ properties: schema?.properties?.tokensConfig || {}, default: schema?.default?.tokensConfig || {} }, null, 2)} as const

`;
  result += "export const GeneratedPinceauThemeSchema = typeof schema\n\n";
  return result;
}
const utilsFull = (utils = {}, utilsImports = [], definitions = {}) => {
  let result = "import { PinceauTheme, PropertyValue } from 'pinceau'\n";
  result += utilsImports.filter(Boolean).join("\n");
  result += `
${stringifyUtils(utils, definitions)}`;
  result += `export const utils = ${Object.keys(utils).length ? `{ ${Object.keys(utils).join(", ")} }` : "undefined"}

`;
  result += "export type GeneratedPinceauUtils = typeof utils\n\n";
  result += "export default utils";
  return result;
};

async function generateTheme(tokens, definitions, {
  outputDir: buildPath,
  colorSchemeMode,
  studio: studioSupport,
  definitions: definitionsSupport,
  utilsImports
}, silent = true, write = true) {
  let styleDictionary = StyleDictionary__default;
  const files = [
    {
      destination: "theme/index.css",
      // Has to be named `css` to be recognized as CSS output
      format: "css"
    },
    {
      destination: "index.ts",
      format: "pinceau/typescript"
    },
    {
      destination: "utils.ts",
      format: "pinceau/utils"
    }
  ];
  if (definitionsSupport) {
    files.push({
      destination: "definitions.ts",
      format: "pinceau/definitions"
    });
  }
  if (studioSupport) {
    files.push({
      destination: "schema.ts",
      format: "pinceau/schema"
    });
  }
  const transforms = [
    "size/px",
    "color/hex",
    "pinceau/name",
    "pinceau/variable",
    "pinceau/responsiveTokens"
  ];
  const outputs = {};
  let result = {
    tokens: {},
    outputs: {},
    buildPath
  };
  if (!tokens || typeof tokens !== "object" || !Object.keys(tokens).length) {
    return result;
  }
  const utils = { ...tokens?.utils || {} };
  if (tokens?.utils) {
    delete tokens?.utils;
  }
  const mqKeys = ["dark", "light", ...Object.keys(tokens?.media || {})];
  const responsiveTokens = {};
  styleDictionary.fileHeader = {};
  styleDictionary.registerTransform({
    name: "pinceau/variable",
    type: "attribute",
    matcher: () => true,
    transformer(token) {
      return { variable: `var(--${token.name})` };
    }
  });
  styleDictionary.registerTransform({
    name: "pinceau/name",
    type: "name",
    matcher: () => true,
    transformer(token) {
      if (token?.path?.join("").includes("-")) {
        query.message("WRONG_TOKEN_NAMING", [token]);
      }
      return token?.path?.join("-");
    }
  });
  styleDictionary.registerTransform({
    name: "pinceau/responsiveTokens",
    type: "value",
    transitive: true,
    matcher: (token) => {
      const keys = typeof token.value === "object" ? Object.keys(token.value) : [];
      if (keys && keys.includes("initial") && keys.some((key) => mqKeys.includes(key))) {
        return true;
      }
      return false;
    },
    transformer: (token) => {
      Object.entries(token.value).forEach(
        ([key, value]) => {
          if (key === "initial") {
            return;
          }
          if (!responsiveTokens[key]) {
            responsiveTokens[key] = [];
          }
          const responsiveToken = { ...token, value };
          responsiveTokens[key].push(responsiveToken);
        }
      );
      return token.value;
    }
  });
  styleDictionary.registerFormat({
    name: "css",
    formatter({ dictionary, options }) {
      const result2 = cssFull(dictionary, options, responsiveTokens, colorSchemeMode);
      outputs.css = result2;
      return result2;
    }
  });
  styleDictionary.registerFormat({
    name: "pinceau/utils",
    formatter() {
      outputs.utils = utilsFull(utils, utilsImports, definitions);
      return outputs.utils;
    }
  });
  styleDictionary.registerFormat({
    name: "pinceau/definitions",
    formatter() {
      outputs.definitions = definitionsFull(definitions);
      return outputs.definitions;
    }
  });
  const schema = await untyped.resolveSchema({ tokensConfig: tokens });
  styleDictionary.registerFormat({
    name: "pinceau/schema",
    formatter() {
      outputs.schema = schemaFull(schema);
      return outputs.schema;
    }
  });
  styleDictionary.registerFormat({
    name: "pinceau/typescript",
    formatter({ dictionary }) {
      outputs.ts = tsFull(dictionary.tokens);
      return outputs.ts;
    }
  });
  styleDictionary.registerTransformGroup({
    name: "pinceau",
    transforms
  });
  styleDictionary = styleDictionary.extend({
    tokens: stringify.normalizeConfig(tokens, mqKeys, true),
    platforms: {
      prepare: {
        silent,
        transformGroup: "pinceau"
      },
      base: {
        silent,
        transformGroup: "pinceau",
        buildPath,
        files,
        write
      },
      done: {
        silent,
        transformGroup: "pinceau",
        actions: ["done"]
      }
    }
  });
  try {
    result = await new Promise(
      (resolve) => {
        styleDictionary.registerAction({
          name: "done",
          do: ({ tokens: tokens2 }) => {
            resolve({
              tokens: flattenTokens(tokens2),
              outputs,
              buildPath
            });
          },
          undo: () => {
          }
        });
        styleDictionary.buildAllPlatforms();
      }
    );
  } catch (e) {
    query.message("CONFIG_BUILD_ERROR", [e]);
  }
  return result;
}

const RESOLVED_ID_RE = /^(virtual:pinceau:|#)?\/__pinceau(?:(_.*?))?\.(css|ts|js)(\?.*)?$/;
function usePinceauVirtualStore() {
  const outputs = {
    _css: "/* This file is empty because no tokens has been provided or the configuration is broken. */",
    _ts: tsFull({}),
    _utils: utilsFull({}),
    _schema: "export const schema = {}\nexport const GeneratedPinceauThemeSchema = typeof schema",
    _definitions: "export const definitions = {} as const"
  };
  function updateOutputs(generatedTheme) {
    Object.entries(generatedTheme.outputs).forEach(([key, value]) => outputs[`_${key}`] = value);
  }
  function getOutput(id) {
    if (id === "/__pinceau_css.css") {
      return outputs._css;
    }
    if (id === "/__pinceau_ts.ts") {
      return outputs._ts;
    }
    if (id === "/__pinceau_utils.ts") {
      return outputs._utils;
    }
    if (id === "/__pinceau_schema.ts") {
      return outputs._schema;
    }
    if (id === "/__pinceau_definitions.ts") {
      return outputs._definitions;
    }
  }
  function getOutputId(id) {
    if (id.includes("pinceau.css")) {
      return "/__pinceau_css.css";
    }
    if (id.includes("#pinceau/theme")) {
      return "/__pinceau_ts.ts";
    }
    if (id.includes("#pinceau/utils")) {
      return "/__pinceau_utils.ts";
    }
    if (id.includes("#pinceau/schema")) {
      return "/__pinceau_schema.ts";
    }
    if (id.includes("#pinceau/definitions")) {
      return "/__pinceau_definitions.ts";
    }
  }
  return {
    get outputs() {
      return outputs;
    },
    updateOutputs,
    getOutput,
    getOutputId
  };
}

async function prepareOutputDir({
  outputDir = path.join(process.cwd(), "node_modules/.vite/pinceau"),
  studio
}) {
  const themeDir = path.join(outputDir, "theme");
  if (!fs.existsSync(themeDir)) {
    await promises.mkdir(themeDir, { recursive: true });
  }
  await stubOutputs(outputDir, false, studio);
  return outputDir;
}
async function stubOutputs(buildPath, force = false, schema = false) {
  const files = {
    "theme/index.css": () => "/* This file is empty because no tokens has been provided or your configuration is broken. */",
    "definitions.ts": () => "export const definitions = {} as const",
    "index.ts": tsFull,
    "utils.ts": utilsFull
  };
  if (schema) {
    files["schema.ts"] = schemaFull;
  }
  for (const [file, stubbingFunction] of Object.entries(files)) {
    const path$1 = path.join(buildPath, file);
    if (force && fs.existsSync(path$1)) {
      await promises.rm(path$1);
    }
    if (!fs.existsSync(path$1)) {
      await promises.writeFile(path$1, stubbingFunction ? await stubbingFunction({}) : "");
    }
  }
}

function usePinceauContext(options) {
  const env = "prod";
  const transformed = [];
  const getTransformed = () => transformed;
  let viteServer;
  const getViteServer = () => viteServer;
  let tokens = {};
  const getTokens = () => tokens;
  let utils = {};
  const getUtils = () => utils;
  prepareOutputDir(options);
  const { outputs, getOutput, getOutputId, updateOutputs } = usePinceauVirtualStore();
  const configContext = usePinceauConfigContext(
    options,
    getViteServer,
    getTransformed,
    async (resolvedConfig) => {
      query.message("CONFIG_RESOLVED", [resolvedConfig]);
      const { stopPerfTimer } = query.useDebugPerformance("Build theme", options.debug);
      utils = resolvedConfig.config?.utils || {};
      const builtTheme = await generateTheme(resolvedConfig.config, resolvedConfig.definitions, options);
      if (options?.configBuilt) {
        options.configBuilt(builtTheme);
      }
      if (!builtTheme) {
        stopPerfTimer();
        return;
      }
      updateOutputs(builtTheme);
      tokens = builtTheme.tokens;
      if (viteServer) {
        viteServer.ws.send({
          type: "custom",
          event: "pinceau:themeUpdate",
          data: {
            css: builtTheme.outputs.css,
            theme: tokens
          }
        });
      }
      stopPerfTimer();
    }
  );
  return {
    // Local context
    env,
    options,
    // Transformed files
    get transformed() {
      return getTransformed();
    },
    addTransformed(id) {
      if (!transformed.includes(id)) {
        transformed.push(id);
      }
    },
    // $tokens
    get tokens() {
      return getTokens();
    },
    get $tokens() {
      return stringify.createTokensHelper(
        tokens,
        {
          onNotFound(path, options2) {
            query.message("TOKEN_NOT_FOUND", [path, options2]);
          }
        }
      );
    },
    // utils
    get utils() {
      return getUtils();
    },
    // Vite
    get viteServer() {
      return getViteServer();
    },
    setViteServer: (server) => {
      viteServer = server;
      configContext.registerConfigWatchers();
    },
    // Config
    ...configContext,
    // Virtual storage
    outputs,
    getOutput,
    updateOutputs,
    getOutputId
  };
}

exports.RESOLVED_ID_RE = RESOLVED_ID_RE;
exports.cssFull = cssFull;
exports.definitionsFull = definitionsFull;
exports.flattenTokens = flattenTokens;
exports.generateTheme = generateTheme;
exports.importConfigFile = importConfigFile;
exports.isSafeConstName = isSafeConstName;
exports.loadLayers = loadLayers;
exports.loadVueStyle = loadVueStyle;
exports.objectPaths = objectPaths;
exports.prepareOutputDir = prepareOutputDir;
exports.registerAliases = registerAliases;
exports.registerPostCssPlugins = registerPostCssPlugins;
exports.replaceStyleTs = replaceStyleTs;
exports.resolveConfigFile = resolveConfigFile;
exports.resolveConfigLayer = resolveConfigLayer;
exports.resolveConfigSources = resolveConfigSources;
exports.resolveDefinitions = resolveDefinitions;
exports.resolveMediaQueriesKeys = resolveMediaQueriesKeys;
exports.resolveScriptSetup = resolveScriptSetup;
exports.resolveStyle = resolveStyle;
exports.resolveStyleQuery = resolveStyleQuery;
exports.resolveTemplate = resolveTemplate;
exports.schemaFull = schemaFull;
exports.stubOutputs = stubOutputs;
exports.transformAddPinceauClass = transformAddPinceauClass;
exports.transformAddPropsKey = transformAddPropsKey;
exports.transformAddRuntimeImports = transformAddRuntimeImports;
exports.transformComputedStyles = transformComputedStyles;
exports.transformDtHelper = transformDtHelper;
exports.transformFinishRuntimeSetup = transformFinishRuntimeSetup;
exports.transformMediaQueries = transformMediaQueries;
exports.transformScheme = transformScheme;
exports.transformStyle = transformStyle;
exports.transformVueSFC = transformVueSFC;
exports.tsFull = tsFull;
exports.usePinceauConfigContext = usePinceauConfigContext;
exports.usePinceauContext = usePinceauContext;
exports.usePinceauVirtualStore = usePinceauVirtualStore;
exports.utilsFull = utilsFull;
