import { l as expressionToAst, q as astTypes, o as printAst, j as parseAst, v as visitAst, k as parseVueComponent, t as transformCssFunction, i as transformVariants, b as message, n as defaultExport, m as merger, u as useDebugPerformance } from './pinceau.23c34d4f.mjs';
import 'ohash';
import 'scule';
import { u as dtRegex, j as mqCssRegex, q as lightRegex, l as darkRegex, v as variantsRegex, w as walkTokens, n as normalizeConfig, o as outputFileNames, g as resolveThemeRule, c as createTokensHelper } from './pinceau.3988746b.mjs';
import { readFileSync, existsSync } from 'fs';
import { readFile, mkdir, rm, writeFile } from 'fs/promises';
import createJITI from 'jiti';
import { join, resolve } from 'pathe';
import 'perf_hooks';
import 'vue';
import StyleDictionary from 'style-dictionary-esm';
import { resolveSchema } from 'untyped';
import postCssNested from 'postcss-nested';
import postCssCustomProperties from 'postcss-custom-properties';
import postCssDarkThemeClass from 'postcss-dark-theme-class';
import 'defu';
import 'acorn';
import 'vue/compiler-sfc';
import 'recast';
import 'recast/parsers/typescript.js';

function transformAddPinceauClass(code) {
  if (code.includes("$pinceau")) {
    return code;
  }
  let firstTag = code.match(/<([a-zA-Z]+)([^>]+)*>/);
  if (firstTag?.[0]) {
    const _source = String(firstTag[0]);
    if (_source.includes(":class")) {
      const existingAttr = _source.match(/:class="([^"]+)"/);
      if (existingAttr) {
        let attrAst = expressionToAst(existingAttr[1]);
        const newAttrAst = astTypes.builders.identifier("$pinceau");
        switch (attrAst.type) {
          case "ArrayExpression":
            attrAst.elements.push(newAttrAst);
            break;
          case "StringLiteral":
          case "Literal":
            attrAst = astTypes.builders.arrayExpression([
              existingAttr
            ]);
            break;
          case "ObjectExpression":
            attrAst = astTypes.builders.arrayExpression([
              attrAst,
              newAttrAst
            ]);
            break;
        }
        firstTag = _source.replace(existingAttr[1], printAst(attrAst).code);
      }
    } else if (_source.includes("/>")) {
      firstTag = _source.replace("/>", ' :class="[$pinceau]" />');
    } else {
      firstTag = _source.replace(">", ' :class="[$pinceau]">');
    }
    code = code.replace(_source, firstTag);
  }
  return code;
}

function replaceStyleTs(code, id) {
  if (id.endsWith(".vue") && !id.includes("?")) {
    const styleTagRe = /<style\b(.*?)\blang=['"][tj]sx?['"](.*?)>/g;
    if (code.match(styleTagRe)) {
      return code.replace(styleTagRe, '<style$1lang="postcss" transformed$2>');
    }
  }
  return code;
}

function transformAddPropsKey(code, add = true) {
  try {
    const ast = parseAst(code);
    let propsKey;
    let hasDefineProps;
    let hasWithDefaults;
    visitAst(
      ast,
      {
        // Visit <script setup> variable declarations to find defineProps
        visitVariableDeclaration(path) {
          if (path.value?.declarations?.[0]?.init?.callee?.name === "defineProps") {
            propsKey = path.value.declarations[0].id.name;
            return false;
          }
          return this.traverse(path);
        },
        visitCallExpression(path) {
          if (path.node.callee.name === "defineProps") {
            hasDefineProps = true;
            return false;
          }
          if (path.node.callee.name === "withDefaults") {
            hasWithDefaults = true;
          }
          return this.traverse(path);
        }
      }
    );
    if (add && hasDefineProps && !propsKey) {
      code = code.replace(
        /defineProps|withDefaults\(defineProps/,
        () => {
          propsKey = "__$pProps";
          return `const __$pProps = ${hasWithDefaults ? "withDefaults(defineProps" : "defineProps"}`;
        }
      );
    }
    return { propsKey, code };
  } catch (e) {
    return void 0;
  }
}

const transformDtHelper = (code, ctx, wrapper = void 0) => {
  const replace = (content) => `${wrapper || ""}${content}${wrapper || ""}`;
  return code.replace(dtRegex, (_, ...code2) => {
    const path = code2?.[0];
    const arg = code2?.[2];
    if (arg) {
      const token = ctx.$tokens(path, { key: arg || "variable" });
      if (token) {
        return replace(token);
      }
    }
    return replace(`var(--${path.split(".").join("-")})`);
  });
};

function transformStyle(code = "", ctx, loc) {
  code = transformDtHelper(code, ctx);
  code = transformMediaQueries(code, ctx, loc);
  code = transformScheme(code, "dark");
  code = transformScheme(code, "light");
  return code;
}
function transformScheme(code = "", scheme) {
  const schemesRegex = {
    light: lightRegex,
    dark: darkRegex
  };
  code = code.replace(
    schemesRegex[scheme],
    () => `@media (prefers-color-scheme: ${scheme}) {`
  );
  return code;
}
function transformMediaQueries(code = "", ctx, loc) {
  const mediaQueries = ctx.$tokens("media", { key: void 0, loc });
  code = code.replace(
    mqCssRegex,
    (declaration, query) => {
      const mediaQuery = mediaQueries?.[query];
      if (!mediaQuery) {
        return declaration;
      }
      return `@media ${mediaQuery.value} {`;
    }
  );
  return code;
}

function transformVueSFC(code, query, magicString, ctx) {
  const variants = {};
  const computedStyles = {};
  const localTokens = {};
  const parsedComponent = parseVueComponent(code, { filename: query.id });
  if (parsedComponent?.descriptor?.styles) {
    resolveStyle(query.id, parsedComponent, magicString, variants, computedStyles, localTokens, ctx, query);
  }
  const hasRuntimeStyles = Object.keys(variants).length > 0 || Object.keys(computedStyles).length > 0;
  if (parsedComponent?.descriptor?.template) {
    resolveTemplate(query.id, parsedComponent, magicString, ctx, hasRuntimeStyles);
  }
  if (parsedComponent?.descriptor?.scriptSetup) {
    resolveScriptSetup(query.id, parsedComponent, magicString, variants, computedStyles, ctx, parsedComponent.descriptor.scriptSetup.lang === "ts");
  }
  return { code, magicString, variants, computedStyles, localTokens };
}
function resolveStyleQuery(code, magicString, query, ctx, loc) {
  if (query.lang === "ts") {
    code = transformCssFunction(query.id, code, {}, {}, {}, ctx, loc);
  }
  code = transformStyle(code, ctx);
  return { code, magicString };
}
function resolveTemplate(_, parsedComponent, magicString, ctx, hasRuntimeStyles) {
  const templateContent = parsedComponent.descriptor.template;
  let newTemplateContent = templateContent.content;
  newTemplateContent = transformDtHelper(newTemplateContent, ctx, "'");
  if (ctx.options.runtime && hasRuntimeStyles) {
    newTemplateContent = transformAddPinceauClass(newTemplateContent);
  }
  if (templateContent.loc.end?.offset && templateContent.loc.end?.offset > templateContent.loc.start.offset) {
    magicString.overwrite(
      templateContent.loc.start.offset,
      templateContent.loc.end.offset,
      newTemplateContent
    );
  }
}
function resolveStyle(id, parsedComponent, magicString, variants, computedStyles, localTokens, ctx, query) {
  const styles = parsedComponent.descriptor.styles;
  styles.forEach(
    (styleBlock) => {
      const { loc, content } = styleBlock;
      let code = content;
      if (styleBlock.attrs.lang === "ts" || styleBlock.lang === "ts" || styleBlock.attrs?.transformed) {
        code = transformCssFunction(id, code, variants, computedStyles, localTokens, ctx, { query, ...loc });
      }
      code = transformStyle(code, ctx);
      magicString.remove(loc.start.offset, loc.end.offset);
      magicString.appendRight(loc.end.offset, `
${code}
`);
    }
  );
}
function resolveScriptSetup(id, parsedComponent, magicString, variants, computedStyles, ctx, isTs) {
  const scriptSetup = parsedComponent.descriptor.scriptSetup;
  const hasVariants = Object.keys(variants).length;
  const hasComputedStyles = Object.keys(computedStyles).length;
  let code = scriptSetup.content;
  code = transformDtHelper(code, ctx, "`");
  code = code.replace(variantsRegex, () => "");
  if (ctx.options.runtime) {
    if (hasVariants || hasComputedStyles) {
      code = transformAddRuntimeImports(code);
    }
    if (hasVariants) {
      code = transformVariants(code, variants, isTs);
    }
    if (hasComputedStyles) {
      code = transformComputedStyles(code, computedStyles);
    }
    if (hasVariants || hasComputedStyles) {
      code = transformFinishRuntimeSetup(code, hasComputedStyles, hasVariants, computedStyles);
    }
  } else if (hasVariants || hasComputedStyles) {
    message("RUNTIME_FEATURES_CONFLICT", [id]);
  }
  magicString.overwrite(scriptSetup.loc.start.offset, scriptSetup.loc.end.offset, code);
}
function transformComputedStyles(code, computedStyles) {
  code = Object.entries(computedStyles).map(([key, styleFunction]) => `
const ${key} = computed(() => ((props = __$pProps) => ${styleFunction})())
`).join("") + code;
  return code;
}
function transformAddRuntimeImports(code) {
  code = `import { usePinceauRuntime } from 'pinceau/runtime'
${code}`;
  const vueImports = [];
  if (!code.match(/reactive\(/gm)) {
    vueImports.push("reactive");
  }
  if (!code.match(/computed\(/gm)) {
    vueImports.push("computed");
  }
  if (!code.match(/getCurrentInstance\(/gm)) {
    vueImports.push("getCurrentInstance");
  }
  if (!code.match(/ref\(/gm)) {
    vueImports.push("ref");
  }
  if (vueImports.length) {
    code = `import { ${vueImports.join(", ")} } from 'vue'
${code}`;
  }
  const { propsKey, code: _code } = transformAddPropsKey(code);
  code = _code;
  if (propsKey && propsKey === "__$pProps") {
    return code;
  }
  code += `
const __$pProps = ${propsKey || "{}"}
`;
  return code;
}
function transformFinishRuntimeSetup(newScriptSetup, hasComputedStyles, hasVariants, computedStyles) {
  newScriptSetup += [
    `
${hasVariants || hasComputedStyles ? "const { $pinceau } = " : ""}`,
    "usePinceauRuntime(",
    "__$pProps, ",
    `${hasVariants ? "__$pVariants" : "undefined"}, `,
    `${hasComputedStyles ? `{ ${Object.keys(computedStyles).map((key) => `${key}`).join(",")} }` : "undefined"}`,
    ")\n"
  ].join("");
  return newScriptSetup;
}

function isSafeConstName(name) {
  if (!/^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name)) {
    return false;
  }
  if (["break", "case", "catch", "class", "const", "continue", "debugger", "default", "delete", "do", "else", "enum", "export", "extends", "false", "finally", "for", "function", "if", "implements", "import", "in", "instanceof", "interface", "let", "new", "null", "package", "private", "protected", "public", "return", "static", "super", "switch", "this", "throw", "true", "try", "typeof", "var", "void", "while", "with", "yield"].includes(name)) {
    return false;
  }
  return true;
}

function registerAliases(config, options) {
  if (!config?.resolve) {
    config.resolve = {};
  }
  if (!config.resolve?.alias) {
    config.resolve.alias = {};
  }
  if (options?.outputDir) {
    config.resolve.alias["#pinceau/theme"] = join(options.outputDir, "/index.ts");
    config.resolve.alias["#pinceau/utils"] = join(options.outputDir, "/utils.ts");
  }
}
function registerPostCssPlugins(config, options) {
  if (!config?.css) {
    config.css = {};
  }
  if (!config.css?.postcss) {
    config.css.postcss = {};
  }
  if (!config.css?.postcss.plugins) {
    config.css.postcss.plugins = [];
  }
  config.css.postcss.plugins.push(
    postCssNested,
    postCssCustomProperties
  );
  if (options?.colorSchemeMode === "class") {
    config.css.postcss.plugins.push(
      postCssDarkThemeClass({
        darkSelector: ".dark",
        lightSelector: ".light"
      })
    );
  }
}

const objectPaths = (data) => {
  const output = [];
  function step(obj, prev) {
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      const isarray = Array.isArray(value);
      const type = Object.prototype.toString.call(value);
      const isobject = type === "[object Object]" || type === "[object Array]";
      const newKey = prev ? `${prev}.${key}` : key;
      if ((typeof value?.value !== "undefined" || typeof value === "string") && !output.includes(newKey)) {
        output.push([newKey, value?.value || value]);
        return;
      }
      if (!isarray && isobject && Object.keys(value).length) {
        return step(value, newKey);
      }
    });
  }
  step(data);
  return output;
};
const flattenTokens = (data, toValue = false, raw = true) => {
  return walkTokens(data, (value) => {
    const toRet = toValue ? value?.value : {
      value: value?.value,
      variable: value?.attributes?.variable
    };
    if (!toValue && raw && value?.original?.value) {
      toRet.raw = value.original.value;
    }
    return toRet;
  });
};

const loadVueStyle = (query, ctx) => {
  const { filename } = query;
  const file = readFileSync(filename, "utf8");
  if (!file) {
    return;
  }
  const { descriptor } = parseVueComponent(file, { filename });
  if (!descriptor) {
    return;
  }
  const style = descriptor?.styles?.[query.index];
  if (!style?.content) {
    return;
  }
  let source = style.content;
  const loc = { query, ...style.loc };
  if (style.attrs.lang === "ts") {
    source = transformCssFunction(query.id, source, void 0, void 0, void 0, ctx, loc);
  }
  return transformStyle(source, ctx, loc);
};

function resolveDefinitions(content, mediaQueriesKeys, filePath) {
  const definitions = {};
  visitAst(
    defaultExport(parseAst(content)),
    {
      visitObjectProperty(path) {
        const tokenNode = getTokenNode(path, mediaQueriesKeys);
        if (tokenNode) {
          const key = resolvePropertyKeyPath(tokenNode);
          if (!key) {
            return false;
          }
          if ((key.startsWith("utils.") || key.startsWith("media.")) && key.split(".").length > 2) {
            return false;
          }
          definitions[key] = {
            uri: filePath,
            range: {
              start: path.value.loc.start,
              end: path.value.loc.end
            }
          };
          if (key.startsWith("utils.")) {
            definitions[key].content = printAst(tokenNode.value.value).code;
          }
          return false;
        }
        if (tokenNode === false) {
          return false;
        }
        return this.traverse(path);
      }
    }
  );
  return definitions;
}
function isResponsiveToken(node, mqKeys) {
  const properties = node?.value?.properties || [];
  const propertiesKeys = properties.map((node2) => node2?.key?.value?.toString() || node2?.key?.name?.toString());
  if (propertiesKeys.includes("initial") && propertiesKeys.some((propKey) => mqKeys.includes(propKey))) {
    return true;
  }
}
function isTokenLike(node) {
  const properties = node?.value?.properties || [];
  const propertiesKeys = properties.map((node2) => node2?.key?.value?.toString() || node2?.key?.name?.toString());
  if (propertiesKeys.includes("value")) {
    return true;
  }
}
function getTokenNode(node, mqKeys) {
  if (isResponsiveToken(node?.parent, mqKeys)) {
    return node?.parent;
  }
  if (isTokenLike(node?.parent)) {
    return node?.parent;
  }
  if (node?.value?.key?.name === "$schema" || node?.parent?.value?.key?.name === "$schema") {
    return false;
  }
  if (["FunctionDeclaration", "ObjectExpression"].includes(node?.value?.value?.type)) {
    return;
  }
  return node;
}
function resolvePropertyKeyPath(node) {
  let currentPath = node;
  const currentKeyPath = [];
  while (currentPath.parent) {
    const path = currentPath?.value?.key?.value?.toString() || currentPath?.value?.key?.name?.toString();
    if (path) {
      currentKeyPath.push(path);
    }
    currentPath = currentPath?.parent || void 0;
  }
  return currentKeyPath.filter(Boolean).reverse().join(".");
}

const extensions = [".js", ".ts", ".mjs", ".cjs", ".json"];
async function loadLayers({
  cwd = process.cwd(),
  configLayers,
  configFileName = "tokens.config",
  definitions = true
}) {
  const sources = resolveConfigSources({ cwd, configLayers, configFileName });
  const result = {
    config: {},
    definitions: {},
    sources: []
  };
  for (const layer of sources) {
    if (layer.tokens) {
      const mediaQueriesKeys = resolveMediaQueriesKeys(result.config);
      result.config = merger(normalizeConfig(layer.tokens, mediaQueriesKeys), result.config);
      continue;
    }
    const { path, config, definitions: resolvedDefinitions } = await resolveConfigLayer({ cwd, configFileName, definitions }, layer);
    if (path) {
      result.sources.push(path);
    }
    if (config) {
      result.config = merger(config, result.config);
    }
    if (definitions) {
      result.definitions = Object.assign(result?.definitions || {}, resolvedDefinitions);
    }
  }
  return result;
}
function resolveConfigFile(configFile, definitions = true) {
  const { config, content, path } = configFile;
  const mediaQueriesKeys = resolveMediaQueriesKeys(config);
  const normalizedConfig = normalizeConfig(config, mediaQueriesKeys, false);
  let resolvedDefinitions;
  if (definitions) {
    try {
      resolvedDefinitions = resolveDefinitions(content, mediaQueriesKeys, path);
    } catch (e) {
    }
  }
  return {
    path,
    content,
    definitions: resolvedDefinitions,
    config: normalizedConfig
  };
}
async function resolveConfigLayer({
  configFileName,
  cwd,
  definitions
}, layer) {
  const empty = (path2 = void 0) => ({ path: path2, content: "", config: {}, schema: {}, definitions: {} });
  let path = "";
  if (typeof layer === "string") {
    path = resolve(layer);
  } else if (typeof layer === "object") {
    path = resolve(layer?.cwd || cwd, layer?.configFileName || configFileName);
  } else {
    return empty();
  }
  let filePath = "";
  let ext;
  extensions.some((_ext) => {
    if (existsSync(path + _ext)) {
      filePath = path + _ext;
      ext = _ext;
      return true;
    }
    return false;
  });
  if (!filePath) {
    return empty();
  }
  try {
    return resolveConfigFile(
      await importConfigFile({ path: filePath, ext }),
      definitions
    );
  } catch (e) {
    message("CONFIG_RESOLVE_ERROR", [filePath, e]);
    return empty(filePath);
  }
}
function resolveConfigSources({
  cwd = process.cwd(),
  configLayers = [],
  configFileName = "tokens.config"
}) {
  let sources = configLayers.reduce(
    (acc, layerOrPath) => {
      if (typeof layerOrPath === "object") {
        acc.push(layerOrPath);
        return acc;
      }
      if (typeof layerOrPath === "string") {
        acc.push({
          cwd: layerOrPath,
          configFileName
        });
        return acc;
      }
      return acc;
    },
    []
  );
  if (cwd && !sources.some((source) => source.cwd === cwd)) {
    sources.unshift({
      cwd,
      configFileName
    });
  }
  sources = [...new Set(sources)];
  return sources.reverse();
}
async function importConfigFile({ path, ext }) {
  const content = await readFile(path, "utf-8");
  if (ext === ".json") {
    const config = JSON.parse(content);
    return {
      path,
      content,
      config
    };
  }
  const configImport = createJITI(path, {
    interopDefault: true,
    requireCache: false,
    esmResolve: true
  })(path);
  return {
    path,
    content,
    config: configImport
  };
}
function resolveMediaQueriesKeys(config) {
  let mediaQueriesKeys = ["dark", "light", "initial"];
  if (config.media && config.media.length) {
    mediaQueriesKeys = [...mediaQueriesKeys, ...Object.keys(config.media)];
  }
  return mediaQueriesKeys;
}

function usePinceauConfigContext(options, getViteServer, getTransformed, dispatchConfigUpdate) {
  let cwd = options?.cwd ?? process.cwd();
  let sources = [];
  let resolvedConfig = {};
  let ready = reloadConfig();
  async function reloadConfig(newOptions = options) {
    const result = await loadLayers(newOptions || options);
    cwd = newOptions?.cwd ?? process.cwd();
    resolvedConfig = result.config;
    sources = result.sources;
    if (dispatchConfigUpdate) {
      dispatchConfigUpdate(result);
    }
    if (options?.configResolved) {
      options.configResolved(result);
    }
    return result;
  }
  async function updateCwd(newCwd) {
    if (newCwd !== cwd) {
      cwd = newCwd;
      ready = reloadConfig();
    }
    return await ready;
  }
  async function onConfigChange(p) {
    if (!sources.includes(p)) {
      return;
    }
    const viteServer = getViteServer();
    await reloadConfig();
    const ids = [...outputFileNames];
    getTransformed().forEach((transformed) => !ids.includes(transformed) && ids.push(transformed));
    for (const id of ids) {
      const _module = viteServer.moduleGraph.getModuleById(id);
      if (!_module) {
        continue;
      }
      viteServer.reloadModule(_module);
    }
  }
  function registerConfigWatchers() {
    if (!sources.length) {
      return;
    }
    const viteServer = getViteServer();
    viteServer.watcher.add(sources);
    viteServer.watcher.on("change", onConfigChange);
  }
  return {
    get ready() {
      return ready;
    },
    get cwd() {
      return cwd;
    },
    updateCwd,
    sources,
    reloadConfig,
    resolvedConfig,
    registerConfigWatchers
  };
}

const stringifyUtils = (value, definitions) => {
  const entries = Object.entries(value);
  return entries.reduce(
    (acc, [key, value2]) => {
      if (!isSafeConstName(key)) {
        message("UTIL_NAME_CONFLICT", [key]);
        return acc;
      }
      if (definitions[`utils.${key}`]?.content) {
        acc += `export const ${key} = ${definitions[`utils.${key}`].content}

`;
        return acc;
      }
      if (typeof value2 === "function") {
        acc += `export const ${key} = ${String(value2)}

`;
      } else {
        acc += `export const ${key} = ${JSON.stringify(value2, null, 4)}

`;
      }
      return acc;
    },
    ""
  );
};
const enhanceTokenPaths = (value = []) => {
  const tokensLiteralNodes = [];
  value.forEach(([keyPath]) => {
    tokensLiteralNodes.push(
      astTypes.builders.tsLiteralType(astTypes.builders.stringLiteral(keyPath))
    );
  });
  const ast = astTypes.builders.tsTypeAliasDeclaration(
    astTypes.builders.identifier("GeneratedPinceauPaths"),
    astTypes.builders.tsUnionType(tokensLiteralNodes)
  );
  return printAst(ast).code;
};
function tsFull(tokensObject) {
  let result = "";
  const flattenedTokens = flattenTokens(tokensObject);
  if (Object.keys(flattenedTokens).length) {
    result += `export const theme = ${JSON.stringify(flattenedTokens, null, 2)} as const

`;
  } else {
    result += "export const theme = undefined\n\n";
  }
  result += "export type GeneratedPinceauTheme = typeof theme\n\n";
  const tokensPaths = objectPaths(tokensObject);
  if (tokensPaths.length) {
    result += `export ${enhanceTokenPaths(tokensPaths)}

`;
  } else {
    result += "export type GeneratedPinceauPaths = undefined\n\n";
  }
  result += "export default theme";
  return result;
}
const cssFull = (dictionary, options, responsiveTokens, colorSchemeMode) => {
  const { formattedVariables } = StyleDictionary.formatHelpers;
  const tokens = {
    initial: []
  };
  walkTokens(
    dictionary.tokens,
    (token) => {
      if (typeof token?.value === "object" && token?.value?.initial) {
        Object.entries(token.value).forEach(([media, value]) => {
          if (!tokens[media]) {
            tokens[media] = [];
          }
          tokens[media].push({
            ...token,
            attributes: {
              ...token?.attributes || {},
              media
            },
            value
          });
        });
        return token;
      }
      tokens.initial.push(token);
      return token;
    }
  );
  let css = "";
  Object.entries(tokens).forEach(
    ([key, value]) => {
      const formattedContent = formattedVariables({ format: "css", dictionary: { ...dictionary, allTokens: value }, outputReferences: true, formatting: { lineSeparator: "", indentation: "", prefix: "" } });
      css += resolveThemeRule(key, formattedContent, dictionary.tokens, colorSchemeMode);
    }
  );
  return css.replace(/(\n|\s\s)/g, "");
};
const definitionsFull = (definitions) => {
  return `export const definitions = ${JSON.stringify(definitions, null, 2)} as const`;
};
function schemaFull(schema) {
  let result = `export const schema = ${JSON.stringify({ properties: schema?.properties?.tokensConfig || {}, default: schema?.default?.tokensConfig || {} }, null, 2)} as const

`;
  result += "export const GeneratedPinceauThemeSchema = typeof schema\n\n";
  return result;
}
const utilsFull = (utils = {}, utilsImports = [], definitions = {}) => {
  let result = "import { PinceauTheme, PropertyValue } from 'pinceau'\n";
  result += utilsImports.filter(Boolean).join("\n");
  result += `
${stringifyUtils(utils, definitions)}`;
  result += `export const utils = ${Object.keys(utils).length ? `{ ${Object.keys(utils).join(", ")} }` : "undefined"}

`;
  result += "export type GeneratedPinceauUtils = typeof utils\n\n";
  result += "export default utils";
  return result;
};

async function generateTheme(tokens, definitions, {
  outputDir: buildPath,
  colorSchemeMode,
  studio: studioSupport,
  definitions: definitionsSupport,
  utilsImports
}, silent = true, write = true) {
  let styleDictionary = StyleDictionary;
  const files = [
    {
      destination: "theme/index.css",
      // Has to be named `css` to be recognized as CSS output
      format: "css"
    },
    {
      destination: "index.ts",
      format: "pinceau/typescript"
    },
    {
      destination: "utils.ts",
      format: "pinceau/utils"
    }
  ];
  if (definitionsSupport) {
    files.push({
      destination: "definitions.ts",
      format: "pinceau/definitions"
    });
  }
  if (studioSupport) {
    files.push({
      destination: "schema.ts",
      format: "pinceau/schema"
    });
  }
  const transforms = [
    "size/px",
    "color/hex",
    "pinceau/name",
    "pinceau/variable",
    "pinceau/responsiveTokens"
  ];
  const outputs = {};
  let result = {
    tokens: {},
    outputs: {},
    buildPath
  };
  if (!tokens || typeof tokens !== "object" || !Object.keys(tokens).length) {
    return result;
  }
  const utils = { ...tokens?.utils || {} };
  if (tokens?.utils) {
    delete tokens?.utils;
  }
  const mqKeys = ["dark", "light", ...Object.keys(tokens?.media || {})];
  const responsiveTokens = {};
  styleDictionary.fileHeader = {};
  styleDictionary.registerTransform({
    name: "pinceau/variable",
    type: "attribute",
    matcher: () => true,
    transformer(token) {
      return { variable: `var(--${token.name})` };
    }
  });
  styleDictionary.registerTransform({
    name: "pinceau/name",
    type: "name",
    matcher: () => true,
    transformer(token) {
      if (token?.path?.join("").includes("-")) {
        message("WRONG_TOKEN_NAMING", [token]);
      }
      return token?.path?.join("-");
    }
  });
  styleDictionary.registerTransform({
    name: "pinceau/responsiveTokens",
    type: "value",
    transitive: true,
    matcher: (token) => {
      const keys = typeof token.value === "object" ? Object.keys(token.value) : [];
      if (keys && keys.includes("initial") && keys.some((key) => mqKeys.includes(key))) {
        return true;
      }
      return false;
    },
    transformer: (token) => {
      Object.entries(token.value).forEach(
        ([key, value]) => {
          if (key === "initial") {
            return;
          }
          if (!responsiveTokens[key]) {
            responsiveTokens[key] = [];
          }
          const responsiveToken = { ...token, value };
          responsiveTokens[key].push(responsiveToken);
        }
      );
      return token.value;
    }
  });
  styleDictionary.registerFormat({
    name: "css",
    formatter({ dictionary, options }) {
      const result2 = cssFull(dictionary, options, responsiveTokens, colorSchemeMode);
      outputs.css = result2;
      return result2;
    }
  });
  styleDictionary.registerFormat({
    name: "pinceau/utils",
    formatter() {
      outputs.utils = utilsFull(utils, utilsImports, definitions);
      return outputs.utils;
    }
  });
  styleDictionary.registerFormat({
    name: "pinceau/definitions",
    formatter() {
      outputs.definitions = definitionsFull(definitions);
      return outputs.definitions;
    }
  });
  const schema = await resolveSchema({ tokensConfig: tokens });
  styleDictionary.registerFormat({
    name: "pinceau/schema",
    formatter() {
      outputs.schema = schemaFull(schema);
      return outputs.schema;
    }
  });
  styleDictionary.registerFormat({
    name: "pinceau/typescript",
    formatter({ dictionary }) {
      outputs.ts = tsFull(dictionary.tokens);
      return outputs.ts;
    }
  });
  styleDictionary.registerTransformGroup({
    name: "pinceau",
    transforms
  });
  styleDictionary = styleDictionary.extend({
    tokens: normalizeConfig(tokens, mqKeys, true),
    platforms: {
      prepare: {
        silent,
        transformGroup: "pinceau"
      },
      base: {
        silent,
        transformGroup: "pinceau",
        buildPath,
        files,
        write
      },
      done: {
        silent,
        transformGroup: "pinceau",
        actions: ["done"]
      }
    }
  });
  try {
    result = await new Promise(
      (resolve) => {
        styleDictionary.registerAction({
          name: "done",
          do: ({ tokens: tokens2 }) => {
            resolve({
              tokens: flattenTokens(tokens2),
              outputs,
              buildPath
            });
          },
          undo: () => {
          }
        });
        styleDictionary.buildAllPlatforms();
      }
    );
  } catch (e) {
    message("CONFIG_BUILD_ERROR", [e]);
  }
  return result;
}

const RESOLVED_ID_RE = /^(virtual:pinceau:|#)?\/__pinceau(?:(_.*?))?\.(css|ts|js)(\?.*)?$/;
function usePinceauVirtualStore() {
  const outputs = {
    _css: "/* This file is empty because no tokens has been provided or the configuration is broken. */",
    _ts: tsFull({}),
    _utils: utilsFull({}),
    _schema: "export const schema = {}\nexport const GeneratedPinceauThemeSchema = typeof schema",
    _definitions: "export const definitions = {} as const"
  };
  function updateOutputs(generatedTheme) {
    Object.entries(generatedTheme.outputs).forEach(([key, value]) => outputs[`_${key}`] = value);
  }
  function getOutput(id) {
    if (id === "/__pinceau_css.css") {
      return outputs._css;
    }
    if (id === "/__pinceau_ts.ts") {
      return outputs._ts;
    }
    if (id === "/__pinceau_utils.ts") {
      return outputs._utils;
    }
    if (id === "/__pinceau_schema.ts") {
      return outputs._schema;
    }
    if (id === "/__pinceau_definitions.ts") {
      return outputs._definitions;
    }
  }
  function getOutputId(id) {
    if (id.includes("pinceau.css")) {
      return "/__pinceau_css.css";
    }
    if (id.includes("#pinceau/theme")) {
      return "/__pinceau_ts.ts";
    }
    if (id.includes("#pinceau/utils")) {
      return "/__pinceau_utils.ts";
    }
    if (id.includes("#pinceau/schema")) {
      return "/__pinceau_schema.ts";
    }
    if (id.includes("#pinceau/definitions")) {
      return "/__pinceau_definitions.ts";
    }
  }
  return {
    get outputs() {
      return outputs;
    },
    updateOutputs,
    getOutput,
    getOutputId
  };
}

async function prepareOutputDir({
  outputDir = join(process.cwd(), "node_modules/.vite/pinceau"),
  studio
}) {
  const themeDir = join(outputDir, "theme");
  if (!existsSync(themeDir)) {
    await mkdir(themeDir, { recursive: true });
  }
  await stubOutputs(outputDir, false, studio);
  return outputDir;
}
async function stubOutputs(buildPath, force = false, schema = false) {
  const files = {
    "theme/index.css": () => "/* This file is empty because no tokens has been provided or your configuration is broken. */",
    "definitions.ts": () => "export const definitions = {} as const",
    "index.ts": tsFull,
    "utils.ts": utilsFull
  };
  if (schema) {
    files["schema.ts"] = schemaFull;
  }
  for (const [file, stubbingFunction] of Object.entries(files)) {
    const path = join(buildPath, file);
    if (force && existsSync(path)) {
      await rm(path);
    }
    if (!existsSync(path)) {
      await writeFile(path, stubbingFunction ? await stubbingFunction({}) : "");
    }
  }
}

function usePinceauContext(options) {
  const env = "prod";
  const transformed = [];
  const getTransformed = () => transformed;
  let viteServer;
  const getViteServer = () => viteServer;
  let tokens = {};
  const getTokens = () => tokens;
  let utils = {};
  const getUtils = () => utils;
  prepareOutputDir(options);
  const { outputs, getOutput, getOutputId, updateOutputs } = usePinceauVirtualStore();
  const configContext = usePinceauConfigContext(
    options,
    getViteServer,
    getTransformed,
    async (resolvedConfig) => {
      message("CONFIG_RESOLVED", [resolvedConfig]);
      const { stopPerfTimer } = useDebugPerformance("Build theme", options.debug);
      utils = resolvedConfig.config?.utils || {};
      const builtTheme = await generateTheme(resolvedConfig.config, resolvedConfig.definitions, options);
      if (options?.configBuilt) {
        options.configBuilt(builtTheme);
      }
      if (!builtTheme) {
        stopPerfTimer();
        return;
      }
      updateOutputs(builtTheme);
      tokens = builtTheme.tokens;
      if (viteServer) {
        viteServer.ws.send({
          type: "custom",
          event: "pinceau:themeUpdate",
          data: {
            css: builtTheme.outputs.css,
            theme: tokens
          }
        });
      }
      stopPerfTimer();
    }
  );
  return {
    // Local context
    env,
    options,
    // Transformed files
    get transformed() {
      return getTransformed();
    },
    addTransformed(id) {
      if (!transformed.includes(id)) {
        transformed.push(id);
      }
    },
    // $tokens
    get tokens() {
      return getTokens();
    },
    get $tokens() {
      return createTokensHelper(
        tokens,
        {
          onNotFound(path, options2) {
            message("TOKEN_NOT_FOUND", [path, options2]);
          }
        }
      );
    },
    // utils
    get utils() {
      return getUtils();
    },
    // Vite
    get viteServer() {
      return getViteServer();
    },
    setViteServer: (server) => {
      viteServer = server;
      configContext.registerConfigWatchers();
    },
    // Config
    ...configContext,
    // Virtual storage
    outputs,
    getOutput,
    updateOutputs,
    getOutputId
  };
}

export { importConfigFile as A, loadLayers as B, resolveConfigFile as C, resolveConfigLayer as D, resolveConfigSources as E, resolveDefinitions as F, resolveMediaQueriesKeys as G, schemaFull as H, stubOutputs as I, tsFull as J, usePinceauConfigContext as K, usePinceauVirtualStore as L, utilsFull as M, RESOLVED_ID_RE as R, registerPostCssPlugins as a, replaceStyleTs as b, resolveStyleQuery as c, transformVueSFC as d, resolveScriptSetup as e, resolveStyle as f, resolveTemplate as g, transformAddPinceauClass as h, transformAddPropsKey as i, transformAddRuntimeImports as j, transformComputedStyles as k, loadVueStyle as l, transformFinishRuntimeSetup as m, transformMediaQueries as n, transformScheme as o, prepareOutputDir as p, transformStyle as q, registerAliases as r, isSafeConstName as s, transformDtHelper as t, usePinceauContext as u, objectPaths as v, flattenTokens as w, cssFull as x, definitionsFull as y, generateTheme as z };
