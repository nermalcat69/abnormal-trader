import { ASTNode } from 'ast-types';
import { o as PinceauContext, h as PinceauQuery, P as PinceauOptions, L as LoadConfigResult, i as PinceauTheme, p as PinceauConfigContext, C as ColorSchemeModes, q as ThemeGenerationOutput, w as ConfigFileImport, R as ResolvedConfigLayer, v as ConfigLayer, m as PinceauVirtualContext, a8 as RESOLVED_ID_RE, a9 as usePinceauVirtualStore } from './index-a242c3c1.js';
import * as vue_compiler_sfc from 'vue/compiler-sfc';
import { SFCParseResult, SFCParseOptions } from 'vue/compiler-sfc';
import MagicString from 'magic-string';
import { ViteDevServer, UserConfig } from 'vite';
import { d as defineTheme } from './define-b8c306eb.js';
import { Dictionary, Options } from 'style-dictionary-esm';
import { Schema } from 'untyped';
export { d as castValue, b as castValues, c as createTokensHelper, h as getResolvedSelectors, p as pathToVarName, a as resolveCssProperty, f as resolveCustomDirectives, e as resolveReferences, g as resolveThemeRule, r as resolveVariableFromPath, s as stringify, t as transformTokensToVariable } from './stringify-9cb687f6.js';
import * as recast from 'recast';
import { Options as Options$1 } from 'recast';
import { File } from '@babel/types';
import { PinceauOptions as PinceauOptions$1 } from 'pinceau';
import * as defu from 'defu';
import '#pinceau/theme';
import '#pinceau/utils';
import 'csstype';

/**
 * Stringify every call of css() into a valid Vue <style> declaration.
 */
declare const transformCssFunction: (id: string, code: string, variants: any, computedStyles: any, localTokens: any, ctx: PinceauContext, loc?: any) => string;
/**
 * Transform a variants property to nested selectors.
 */
declare function castVariants(property: any, value: any): any;
/**
 * Find all calls of css() and call a callback on each.
 */
declare function resolveCssCallees(code: string, cb: (ast: ASTNode) => any): any;
/**
 * Resolve computed styles found in css() declaration.
 */
declare function evalCssDeclaration(cssAst: ASTNode, computedStyles?: any, localTokens?: any): any;

/**
 * Adds `$pinceau` to the root element class via transform
 */
declare function transformAddPinceauClass(code: string): string;

declare function resolveRuntimeContents(cssAst: ASTNode, computedStyles?: any, localTokens?: any): void;

/**
 * Transforms the `<style lang="ts">` attribute into `<style lang="postcss">`.
 */
declare function replaceStyleTs(code: string, id: string): string;

declare function transformAddPropsKey(code: string, add?: boolean): {
    propsKey: any;
    code: string;
};

declare function transformVueSFC(code: string, query: PinceauQuery, magicString: MagicString, ctx: PinceauContext): {
    code: string;
    magicString: MagicString;
    variants: any;
    computedStyles: any;
    localTokens: any;
};
/**
 * Transform direct <style> queries.
 *
 * These does not need to resolve variants or populate computed styles.
 */
declare function resolveStyleQuery(code: string, magicString: MagicString, query: PinceauQuery, ctx: PinceauContext, loc?: any): {
    code: string;
    magicString: MagicString;
};
/**
 * Transform <template> blocks.
 */
declare function resolveTemplate(_: string, parsedComponent: SFCParseResult, magicString: MagicString, ctx: PinceauContext, hasRuntimeStyles: boolean): void;
/**
 * Transform all <style> blocks.
 */
declare function resolveStyle(id: string, parsedComponent: SFCParseResult, magicString: MagicString, variants: any, computedStyles: any, localTokens: any, ctx: PinceauContext, query?: PinceauQuery): void;
/**
 * Transforms <script setup> blocks.
 */
declare function resolveScriptSetup(id: string, parsedComponent: SFCParseResult, magicString: MagicString, variants: any, computedStyles: any, ctx: PinceauContext, isTs: boolean): void;
/**
 * Adds computed styles code to <script setup>
 */
declare function transformComputedStyles(code: string, computedStyles: any): string;
declare function transformAddRuntimeImports(code: string): string;
declare function transformFinishRuntimeSetup(newScriptSetup: any, hasComputedStyles: any, hasVariants: any, computedStyles: any): any;

/**
 * Helper grouping all resolvers applying to <style>
 */
declare function transformStyle(code: string, ctx: PinceauContext, loc?: any): string;
/**
 * Transform media scheme into proper declaration
 */
declare function transformScheme(code: string, scheme: 'light' | 'dark'): string;
/**
 * Resolve `@{media.xl}` declarations.
 */
declare function transformMediaQueries(code: string, ctx: PinceauContext, loc?: any): string;

interface PropOptions {
    type?: any;
    required?: boolean;
    default?: any;
    validator?: (value: unknown) => boolean;
}
/**
 * Takes variants object and turns it into a `const` inside `<script setup>`
 */
declare function transformVariants(code: string, variants: any, isTs: boolean): string;
/**
 * Push variants object to components props.
 *
 * Only work with `defineProps()`.
 */
declare function pushVariantsProps(code: string, variantsProps: any): string;
/**
 * Resolve a Vue component props object from css() variant.
 */
declare function resolveVariantsProps(variants: any, isTs: boolean): {};
declare function castVariantsPropsAst(ast: ASTNode): ASTNode;

/**
 * Resolve `$dt()` calls.
 *
 * Supports `wrapper` to be used in both `<style>` and `<script>` or `<template>` tags.
 */
declare const transformDtHelper: (code: string, ctx: PinceauContext, wrapper?: string | undefined) => string;

type index$1_PropOptions = PropOptions;
declare const index$1_castVariants: typeof castVariants;
declare const index$1_castVariantsPropsAst: typeof castVariantsPropsAst;
declare const index$1_evalCssDeclaration: typeof evalCssDeclaration;
declare const index$1_pushVariantsProps: typeof pushVariantsProps;
declare const index$1_replaceStyleTs: typeof replaceStyleTs;
declare const index$1_resolveCssCallees: typeof resolveCssCallees;
declare const index$1_resolveRuntimeContents: typeof resolveRuntimeContents;
declare const index$1_resolveScriptSetup: typeof resolveScriptSetup;
declare const index$1_resolveStyle: typeof resolveStyle;
declare const index$1_resolveStyleQuery: typeof resolveStyleQuery;
declare const index$1_resolveTemplate: typeof resolveTemplate;
declare const index$1_resolveVariantsProps: typeof resolveVariantsProps;
declare const index$1_transformAddPinceauClass: typeof transformAddPinceauClass;
declare const index$1_transformAddPropsKey: typeof transformAddPropsKey;
declare const index$1_transformAddRuntimeImports: typeof transformAddRuntimeImports;
declare const index$1_transformComputedStyles: typeof transformComputedStyles;
declare const index$1_transformCssFunction: typeof transformCssFunction;
declare const index$1_transformDtHelper: typeof transformDtHelper;
declare const index$1_transformFinishRuntimeSetup: typeof transformFinishRuntimeSetup;
declare const index$1_transformMediaQueries: typeof transformMediaQueries;
declare const index$1_transformScheme: typeof transformScheme;
declare const index$1_transformStyle: typeof transformStyle;
declare const index$1_transformVariants: typeof transformVariants;
declare const index$1_transformVueSFC: typeof transformVueSFC;
declare namespace index$1 {
  export {
    index$1_PropOptions as PropOptions,
    index$1_castVariants as castVariants,
    index$1_castVariantsPropsAst as castVariantsPropsAst,
    index$1_evalCssDeclaration as evalCssDeclaration,
    index$1_pushVariantsProps as pushVariantsProps,
    index$1_replaceStyleTs as replaceStyleTs,
    index$1_resolveCssCallees as resolveCssCallees,
    index$1_resolveRuntimeContents as resolveRuntimeContents,
    index$1_resolveScriptSetup as resolveScriptSetup,
    index$1_resolveStyle as resolveStyle,
    index$1_resolveStyleQuery as resolveStyleQuery,
    index$1_resolveTemplate as resolveTemplate,
    index$1_resolveVariantsProps as resolveVariantsProps,
    index$1_transformAddPinceauClass as transformAddPinceauClass,
    index$1_transformAddPropsKey as transformAddPropsKey,
    index$1_transformAddRuntimeImports as transformAddRuntimeImports,
    index$1_transformComputedStyles as transformComputedStyles,
    index$1_transformCssFunction as transformCssFunction,
    index$1_transformDtHelper as transformDtHelper,
    index$1_transformFinishRuntimeSetup as transformFinishRuntimeSetup,
    index$1_transformMediaQueries as transformMediaQueries,
    index$1_transformScheme as transformScheme,
    index$1_transformStyle as transformStyle,
    index$1_transformVariants as transformVariants,
    index$1_transformVueSFC as transformVueSFC,
  };
}

declare function usePinceauConfigContext<UserOptions extends PinceauOptions = PinceauOptions>(options: UserOptions, getViteServer: () => ViteDevServer, getTransformed: () => string[], dispatchConfigUpdate?: (result: LoadConfigResult<PinceauTheme>) => void): PinceauConfigContext<UserOptions>;

/**
 * Creates the Pinceau context from the options.
 */
declare function usePinceauContext(options: PinceauOptions): PinceauContext;

/**
 * Resolve tokens and utils definitions (uri, range, content)
 */
declare function resolveDefinitions(content: string, mediaQueriesKeys: string[], filePath: string): {};

/**
 * import theme from '#pinceau/theme'
 * import type { GeneratedPinceauTheme, GeneratedPinceauPaths } from '#pinceau/theme'
 */
declare function tsFull(tokensObject: any): string;
/**
 * import 'pinceau.css'
 */
declare const cssFull: (dictionary: Dictionary, options: Options, responsiveTokens: any, colorSchemeMode: ColorSchemeModes) => string;
/**
 * definitions.ts
 */
declare const definitionsFull: (definitions: any) => string;
/**
 * Nuxt Studio schema support
 */
declare function schemaFull(schema: Schema): string;
/**
 * import utils from '#pinceau/utils'
 */
declare const utilsFull: (utils?: {}, utilsImports?: any[], definitions?: {}) => string;

declare function generateTheme(tokens: any, definitions: any, { outputDir: buildPath, colorSchemeMode, studio: studioSupport, definitions: definitionsSupport, utilsImports, }: PinceauOptions, silent?: boolean, write?: boolean): Promise<ThemeGenerationOutput>;

/**
 * Resolves all `configLayers` from Pinceau options and returns a LoadConfigResult object.
 */
declare function loadLayers<U extends PinceauTheme>({ cwd, configLayers, configFileName, definitions, }: PinceauOptions): Promise<LoadConfigResult<U>>;
/**
 * Resolve a config file content for the provided ConfigFileImport.
 */
declare function resolveConfigFile(configFile: ConfigFileImport, definitions?: boolean): ResolvedConfigLayer<any>;
/**
 * Resolves one layer of configuration.
 */
declare function resolveConfigLayer({ configFileName, cwd, definitions, }: PinceauOptions, layer: ConfigLayer): Promise<ResolvedConfigLayer>;
/**
 * Resolve a safe layers array from configLayers option.
 */
declare function resolveConfigSources({ cwd, configLayers, configFileName, }: PinceauOptions): ConfigLayer[];
/**
 * Makes an import of a configuration file.
 */
declare function importConfigFile({ path, ext }: {
    path: any;
    ext: any;
}): Promise<ConfigFileImport>;
declare function resolveMediaQueriesKeys(config: any): string[];

declare function prepareOutputDir<UserOptions extends PinceauOptions = PinceauOptions>({ outputDir, studio, }: UserOptions): Promise<string>;
declare function stubOutputs(buildPath: string, force?: boolean, schema?: boolean): Promise<void>;

declare const index_PinceauVirtualContext: typeof PinceauVirtualContext;
declare const index_RESOLVED_ID_RE: typeof RESOLVED_ID_RE;
declare const index_cssFull: typeof cssFull;
declare const index_defineTheme: typeof defineTheme;
declare const index_definitionsFull: typeof definitionsFull;
declare const index_generateTheme: typeof generateTheme;
declare const index_importConfigFile: typeof importConfigFile;
declare const index_loadLayers: typeof loadLayers;
declare const index_prepareOutputDir: typeof prepareOutputDir;
declare const index_resolveConfigFile: typeof resolveConfigFile;
declare const index_resolveConfigLayer: typeof resolveConfigLayer;
declare const index_resolveConfigSources: typeof resolveConfigSources;
declare const index_resolveDefinitions: typeof resolveDefinitions;
declare const index_resolveMediaQueriesKeys: typeof resolveMediaQueriesKeys;
declare const index_schemaFull: typeof schemaFull;
declare const index_stubOutputs: typeof stubOutputs;
declare const index_tsFull: typeof tsFull;
declare const index_usePinceauConfigContext: typeof usePinceauConfigContext;
declare const index_usePinceauContext: typeof usePinceauContext;
declare const index_usePinceauVirtualStore: typeof usePinceauVirtualStore;
declare const index_utilsFull: typeof utilsFull;
declare namespace index {
  export {
    index_PinceauVirtualContext as PinceauVirtualContext,
    index_RESOLVED_ID_RE as RESOLVED_ID_RE,
    index_cssFull as cssFull,
    index_defineTheme as defineTheme,
    index_definitionsFull as definitionsFull,
    index_generateTheme as generateTheme,
    index_importConfigFile as importConfigFile,
    index_loadLayers as loadLayers,
    index_prepareOutputDir as prepareOutputDir,
    index_resolveConfigFile as resolveConfigFile,
    index_resolveConfigLayer as resolveConfigLayer,
    index_resolveConfigSources as resolveConfigSources,
    index_resolveDefinitions as resolveDefinitions,
    index_resolveMediaQueriesKeys as resolveMediaQueriesKeys,
    index_schemaFull as schemaFull,
    index_stubOutputs as stubOutputs,
    index_tsFull as tsFull,
    index_usePinceauConfigContext as usePinceauConfigContext,
    index_usePinceauContext as usePinceauContext,
    index_usePinceauVirtualStore as usePinceauVirtualStore,
    index_utilsFull as utilsFull,
  };
}

/**
 * Parse AST with TypeScript parser.
 */
declare function parseAst(source: string, options?: Partial<Options$1>): File;
/**
 * Parse a Vue component with vue/compiler-sfc.
 */
declare function parseVueComponent(source: string, options?: Partial<SFCParseOptions>): vue_compiler_sfc.SFCParseResult;
/**
 * Cast a `props.type` string into an AST declaration.
 */
declare function expressionToAst(type: string, leftSide?: string, kind?: 'js' | 'ts'): any;
/**
 * Gets the default export from an AST node.
 */
declare function defaultExport(node: File): ASTNode;
/**
 * Re-exports from recast.
 *
 * Might be useful in case Pinceau changes of AST parser.
 */
declare const visitAst: <M = {}>(node: recast.types.ASTNode, methods?: recast.types.Visitor<M>) => any;
declare const printAst: typeof recast.print;
declare const astTypes: typeof recast.types;

declare function isSafeConstName(name: any): boolean;

/**
 * Get a key from an object with a dotted syntax.
 *
 * @example get({ foot: { bar: 'baz' } }, 'foo.bar') // 'baz'
 */
/**
 * Set a nested key in an object from a paths array.
 */
declare function set(object: any, paths: string | string[], value: any, splitter?: string): void;
/**
 * Get a nested key in an object from a paths array.
 */
declare function get(object: any, paths: string | string[], splitter?: string): any;
/**
 * Walk through tokens definition an call callback on each design token.
 */
declare function walkTokens(obj: any, cb: (value: any, obj: any, paths: string[]) => any, paths?: string[]): Record<string, any>;
/**
 * Normalize a tokens object definition.
 */
declare function normalizeConfig(obj: any, mqKeys: string[], removeSchemaKeys?: boolean): Record<string, any>;

declare const useDebugPerformance: (text: string, debug: PinceauOptions$1['debug'], logOnStop?: boolean) => {
    stopPerfTimer: (silent?: boolean) => void;
    logPerfTimer: any;
};
declare function findLineColumn(content: any, index: any): {
    line: any;
    column: any;
};

type DebugLevel = PinceauOptions['debug'];
declare let context: {
    logger: any;
    debugLevel: DebugLevel;
    tag: any;
    info: any;
    warning: any;
    error: any;
    success: any;
};
declare const updateDebugContext: (newContext: Partial<typeof context>) => void;
declare const getDebugContext: () => {
    logger: any;
    debugLevel: DebugLevel;
    tag: any;
    info: any;
    warning: any;
    error: any;
    success: any;
};
declare const fileLink: (id: string) => any;
declare const errorMessage: (message: string) => any;
declare const debugMarker: (text: any, timing: any) => any;
type DropFirst<T extends unknown[]> = T extends [any, ...infer U] ? U : never;
declare const message: <T extends "TRANSFORM_ERROR" | "CONFIG_RESOLVE_ERROR" | "CONFIG_BUILD_ERROR" | "SELECTOR_CONFLICT" | "UTIL_NAME_CONFLICT" | "WRONG_TOKEN_NAMING" | "CONFIG_RESOLVED" | "TOKEN_NOT_FOUND" | "SCHEMA_BUILD_ERROR" | "RUNTIME_FEATURES_CONFLICT">(id: T, options?: DropFirst<Parameters<{
    /**
     * Errors
     */
    readonly TRANSFORM_ERROR: (debugLevel: any, id: any, error: any) => void;
    readonly CONFIG_RESOLVE_ERROR: (debugLevel: any, path: any, error: any) => void;
    readonly CONFIG_BUILD_ERROR: (debugLevel: any, error: any) => void;
    readonly SELECTOR_CONFLICT: (debugLevel: any, selector: any) => void;
    readonly UTIL_NAME_CONFLICT: (debugLevel: any, name: any) => void;
    readonly WRONG_TOKEN_NAMING: (debugLevel: any, token: any) => void;
    /**
     * Warnings (debugLevel >= 1)
     */
    readonly CONFIG_RESOLVED: (debugLevel: any, resolvedConfig: any) => void;
    readonly TOKEN_NOT_FOUND: (debugLevel: any, path: any, options: any) => void;
    readonly SCHEMA_BUILD_ERROR: (debugLevel: any, _: any) => void;
    readonly RUNTIME_FEATURES_CONFLICT: (debugLevel: any, id: any) => void;
}[T]>>) => any;

/**
 * Options merging function built with defu.
 */
declare const merger: <Source extends {
    [x: string]: any;
    [x: number]: any;
    [x: symbol]: any;
}, Defaults extends ((number | boolean | any[] | Record<never, any>) | {
    [x: string]: any;
    [x: number]: any;
    [x: symbol]: any;
})[]>(source: Source, ...defaults: Defaults) => defu.Defu<Source, Defaults>;

declare function registerAliases(config: UserConfig, options: PinceauOptions): void;
declare function registerPostCssPlugins(config: UserConfig, options: PinceauOptions): void;

declare const STYLES_EXTENSIONS: string[];
declare const JS_EXTENSIONS: string[];
declare const SUPPORTED_EXTENSIONS: string[];
/**
 * Vue SFC Query, forked from the below:
 * - original repository url: https://github.com/vitejs/vite/tree/main/packages/plugin-vue
 * - code url: https://github.com/vitejs/vite/blob/main/packages/plugin-vue/src/utils/query.ts
 * - author: Evan You (https://github.com/yyx990803)
 * - license: MIT
 *
 * - Copied from: https://github.com/intlify/bundle-tools/blob/37ae3acde9e65bf55f5e820b1653b5fddb7ff0cc/packages/unplugin-vue-i18n/src/query.ts#L1
 */
declare function parsePinceauQuery(id: string): PinceauQuery;

declare const referencesRegex: RegExp;
declare const keyRegex: RegExp;
declare const mqPlainRegex: RegExp;
declare const mqCssRegex: RegExp;
declare const darkRegex: RegExp;
declare const lightRegex: RegExp;
declare const DARK = "@dark";
declare const LIGHT = "@light";
declare const INITIAL = "@initial";
declare const dtRegex: RegExp;
declare const variantsRegex: RegExp;
declare const responsiveMediaQueryRegex: RegExp;
declare const outputFileNames: string[];

/**
 * Make a list of `get()` compatible paths for any object.
 */
declare const objectPaths: (data: any) => any;
/**
 * Flatten tokens object for runtime usage.
 */
declare const flattenTokens: (data: any, toValue?: boolean, raw?: boolean) => Record<string, any>;

/**
 * Will load and transform a Vue <style> query.
 */
declare const loadVueStyle: (query: PinceauQuery, ctx: PinceauContext) => string;

export { DARK, INITIAL, JS_EXTENSIONS, LIGHT, STYLES_EXTENSIONS, SUPPORTED_EXTENSIONS, astTypes, darkRegex, debugMarker, defaultExport, dtRegex, errorMessage, expressionToAst, fileLink, findLineColumn, flattenTokens, get, getDebugContext, isSafeConstName, keyRegex, lightRegex, loadVueStyle, merger, message, mqCssRegex, mqPlainRegex, normalizeConfig, objectPaths, outputFileNames, parseAst, parsePinceauQuery, parseVueComponent, printAst, referencesRegex, registerAliases, registerPostCssPlugins, responsiveMediaQueryRegex, set, index as theme, index$1 as transforms, updateDebugContext, useDebugPerformance, variantsRegex, visitAst, walkTokens };
