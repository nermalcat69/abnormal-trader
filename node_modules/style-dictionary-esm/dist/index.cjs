'use strict';

var path4 = require('pathe');
var Color = require('tinycolor2');
var _ChangeCase = require('change-case');
var fs4 = require('fs');
var _template = require('lodash.template');
var jiti = require('jiti');
var consola = require('consola');
var chalk = require('chalk');
var JSON5 = require('json5');
var jsoncParser = require('jsonc-parser');
var glob = require('glob');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var path4__namespace = /*#__PURE__*/_interopNamespace(path4);
var Color__default = /*#__PURE__*/_interopDefault(Color);
var _ChangeCase__namespace = /*#__PURE__*/_interopNamespace(_ChangeCase);
var fs4__default = /*#__PURE__*/_interopDefault(fs4);
var _template__default = /*#__PURE__*/_interopDefault(_template);
var jiti__default = /*#__PURE__*/_interopDefault(jiti);
var consola__default = /*#__PURE__*/_interopDefault(consola);
var chalk__default = /*#__PURE__*/_interopDefault(chalk);
var JSON5__default = /*#__PURE__*/_interopDefault(JSON5);
var glob__default = /*#__PURE__*/_interopDefault(glob);

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// package.json
var version = "1.3.6";
var ChangeCase = _ChangeCase__namespace;
function reduce(obj, f, accumulator_init) {
  return Object.keys(obj || {}).reduce((accumulator, key) => {
    const value = obj[key];
    return f(accumulator, value, key, obj);
  }, accumulator_init);
}
function clone(object) {
  return Object.assign(new object.constructor(), object);
}
function cloneDeep(obj) {
  if (obj === null || obj === void 0 || typeof obj !== "object")
    return obj;
  if (Array.isArray(obj)) {
    return obj.reduce((arr, item, i) => {
      arr[i] = cloneDeep(item);
      return arr;
    }, []);
  }
  if (obj instanceof Object) {
    return Object.keys(obj || {}).reduce((cpObj, key) => {
      cpObj[key] = cloneDeep(obj[key]);
      return cpObj;
    }, {});
  }
}
function isObject(value) {
  const type = typeof value;
  return value != null && (type === "object" || type === "function");
}
function isString(obj) {
  return typeof obj === "string" || obj instanceof String;
}
function isArray(obj) {
  return Array.isArray(obj);
}
function isEmpty(obj) {
  return [Object, Array].includes((obj || {}).constructor) && !Object.entries(obj || {}).length;
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  if (Object.getPrototypeOf(value) === null)
    return true;
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null)
    proto = Object.getPrototypeOf(proto);
  return Object.getPrototypeOf(value) === proto;
}
function filter(arr, filter2) {
  if (typeof filter2 !== "function")
    throw new Error("filter is not a function");
  if (typeof arr === "undefined")
    return [];
  return arr.filter(filter2);
}
function assign(...props) {
  return Object.assign({}, ...props);
}
function pull(arr, ...removeList) {
  const removeSet = new Set(removeList);
  for (let i = arr.length - 1; i >= 0; i--) {
    if (removeSet.has(arr[i]))
      arr.splice(i, 1);
  }
}
function unique(arr) {
  return [...new Set(arr)];
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.substr(1) : "";
}
function matchFn(inputObj, testObj) {
  if (isObject(testObj))
    return Object.keys(testObj).every((key) => matchFn(inputObj[key], testObj[key]));
  else
    return inputObj === testObj;
}
function matches(matchObj) {
  const cloneObj = cloneDeep(matchObj);
  const matchesFn = (inputObj) => matchFn(inputObj, cloneObj);
  return matchesFn;
}
var DEFAULT_OPTIONS = {
  transform: ChangeCase.camelCaseTransformMerge
};
function changeDefaultCaseTransform(caseFunction, default_options) {
  return (caseToChange, options2) => caseFunction(caseToChange, Object.assign({}, DEFAULT_OPTIONS, default_options, options2));
}
var camelCase = changeDefaultCaseTransform(ChangeCase.camelCase);
var snakeCase = ChangeCase.snakeCase;
var kebabCase = ChangeCase.paramCase;
function convertToBase64(filePath) {
  if (typeof filePath !== "string")
    throw new Error("filePath name must be a string");
  const body = fs4__default.default.readFileSync(filePath, "binary");
  return Buffer.from(body, "binary").toString("base64");
}
var convertToBase64_default = convertToBase64;

// src/common/transforms.js
var UNICODE_PATTERN = /&#x([^;]+);/g;
function isColor(token) {
  return token.attributes.category === "color";
}
function isSize(token) {
  return token.attributes.category === "size";
}
function isFontSize(token) {
  return token.attributes.category === "size" && (token.attributes.type === "font" || token.attributes.type === "icon");
}
function isNotFontSize(token) {
  return token.attributes.category === "size" && token.attributes.type !== "font" && token.attributes.type !== "icon";
}
function isAsset(token) {
  return token.attributes.category === "asset";
}
function isContent(token) {
  return token.attributes.category === "content";
}
function wrapValueWith(character, token) {
  return `${character}${token.value}${character}`;
}
function wrapValueWithDoubleQuote(token) {
  return wrapValueWith('"', token);
}
function throwSizeError(name, value, unitType) {
  throw new Error(`Invalid Number: '${name}: ${value}' is not a valid number, cannot transform to '${unitType}' 
`);
}
function getBasePxFontSize(options2) {
  return options2 && options2.basePxFontSize || 16;
}
var transforms_default = {
  /**
   * Adds: category, type, item, subitem, and state on the attributes object based on the location in the style dictionary.
   *
   * ```js
   * // Matches: all
   * // Returns:
   * {
   *   "category": "color",
   *   "type": "background",
   *   "item": "button",
   *   "subitem": "primary",
   *   "state": "active"
   * }
   * ```
   *
   * @memberof Transforms
   */
  "attribute/cti": {
    type: "attribute",
    transformer(token) {
      const attrNames = ["category", "type", "item", "subitem", "state"];
      const originalAttrs = token.attributes || {};
      const generatedAttrs = {};
      for (let i = 0; i < token.path.length && i < attrNames.length; i++)
        generatedAttrs[attrNames[i]] = token.path[i];
      return Object.assign(generatedAttrs, originalAttrs);
    }
  },
  /**
   * Adds: hex, hsl, hsv, rgb, red, blue, green.
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns
   * {
   *   "hex": "009688",
   *   "rgb": {"r": 0, "g": 150, "b": 136, "a": 1},
   *   "hsl": {"h": 174.4, "s": 1, "l": 0.294, "a": 1},
   *   "hsv": {"h": 174.4, "s": 1, "l": 0.588, "a": 1},
   * }
   * ```
   *
   * @memberof Transforms
   */
  "attribute/color": {
    type: "attribute",
    matcher: isColor,
    transformer(token) {
      const color = Color__default.default(token.value);
      return {
        hex: color.toHex(),
        rgb: color.toRgb(),
        hsl: color.toHsl(),
        hsv: color.toHsv()
      };
    }
  },
  /**
   * Creates a human-friendly name
   *
   * ```js
   * // Matches: All
   * // Returns:
   * "button primary"
   * ```
   *
   * @memberof Transforms
   */
  "name/human": {
    type: "name",
    transformer(token) {
      return [
        token.attributes.item,
        token.attributes.subitem
      ].join(" ");
    }
  },
  /**
   * Creates a camel case name. If you define a prefix on the platform in your config, it will prepend with your prefix
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "colorBackgroundButtonPrimaryActive"
   * "prefixColorBackgroundButtonPrimaryActive"
   * ```
   *
   * @memberof Transforms
   */
  "name/cti/camel": {
    type: "name",
    transformer(token, options2) {
      return camelCase([options2.prefix].concat(token.path).join(" "));
    }
  },
  /**
   * Creates a camel case name without the category at the front.  This is most useful when there is a class, struct, enum, etc.
   * that already has the category in it (e.g., StyleDictionaryColors.baseDarkRed instad of StyleDictionaryColors.colorBaseDarkRed).
   * If you define a prefix on the platform in your config, it will prepend with your prefix
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "backgroundButtonPrimaryActive"
   * "prefixBackgroundButtonPrimaryActive"
   * ```
   *
   * @memberof Transforms
   */
  "name/ti/camel": {
    type: "name",
    transformer(token, options2) {
      return camelCase([options2.prefix].concat(token.path.slice(1, token.path.length)).join(" "));
    }
  },
  /**
   * Creates a kebab case name. If you define a prefix on the platform in your config, it will prepend with your prefix
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "color-background-button-primary-active"
   * "prefix-color-background-button-primary-active"
   * ```
   *
   * @memberof Transforms
   */
  "name/cti/kebab": {
    type: "name",
    transformer(token, options2) {
      return kebabCase([options2.prefix].concat(token.path).join(" "));
    }
  },
  /**
   * Creates a snake case name. If you define a prefix on the platform in your config, it will prepend with your prefix
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "color_background_button_primary_active"
   * "prefix_color_background_button_primary_active"
   * ```
   *
   * @memberof Transforms
   */
  "name/cti/snake": {
    type: "name",
    transformer(token, options2) {
      return snakeCase([options2.prefix].concat(token.path).join(" "));
    }
  },
  /**
   * Creates a constant-style name based on the full CTI of the token. If you define a prefix on the platform in your config, it will prepend with your prefix
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "COLOR_BACKGROUND_BUTTON_PRIMARY_ACTIVE"
   * "PREFIX_COLOR_BACKGROUND_BUTTON_PRIMARY_ACTIVE"
   * ```
   *
   * @memberof Transforms
   */
  "name/cti/constant": {
    type: "name",
    transformer(token, options2) {
      return snakeCase([options2.prefix].concat(token.path).join(" ")).toUpperCase();
    }
  },
  /**
   * Creates a constant-style name on the type and item of the token. This is useful if you want to create different static classes/files for categories like `Color.BACKGROUND_BASE`. If you define a prefix on the platform in your config, it will prepend with your prefix.
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "BACKGROUND_BUTTON_PRIMARY_ACTIVE"
   * "PREFIX_BACKGROUND_BUTTON_PRIMARY_ACTIVE"
   * ```
   *
   * @memberof Transforms
   */
  "name/ti/constant": {
    type: "name",
    transformer(token, options2) {
      const path5 = token.path.slice(1);
      return snakeCase([options2.prefix].concat(path5).join(" ")).toUpperCase();
    }
  },
  /**
   * Creates a Pascal case name. If you define a prefix on the platform in your config, it will prepend with your prefix
   *
   * ```js
   * // Matches: all
   * // Returns:
   * "ColorBackgroundButtonPrimaryActive"
   * "PrefixColorBackgroundButtonPrimaryActive"
   * ```
   *
   * @memberof Transforms
   */
  "name/cti/pascal": {
    type: "name",
    transformer(token, options2) {
      return upperFirst(camelCase([options2.prefix].concat(token.path).join(" ")));
    }
  },
  /**
   * Transforms the value into an RGB string
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * "rgb(0, 150, 136)"
   * ```
   *
   * @memberof Transforms
   */
  "color/rgb": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      return Color__default.default(token.value).toRgbString();
    }
  },
  /**
   * Transforms the value into an HSL string or HSLA if alpha is present. Better browser support than color/hsl-4
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * "hsl(174, 100%, 29%)"
   * "hsl(174, 100%, 29%, .5)"
   * ```
   *
   * @memberof Transforms
   */
  "color/hsl": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      return Color__default.default(token.value).toHslString();
    }
  },
  /**
   * Transforms the value into an HSL string, using fourth argument if alpha is present.
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * "hsl(174 100% 29%)"
   * "hsl(174 100% 29% / .5)"
   * ```
   *
   * @memberof Transforms
   */
  "color/hsl-4": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const color = Color__default.default(token.value);
      const o = color.toHsl();
      const vals = `${Math.round(o.h)} ${Math.round(o.s * 100)}% ${Math.round(o.l * 100)}%`;
      if (color.getAlpha() === 1)
        return `hsl(${vals})`;
      else
        return `hsl(${vals} / ${o.a})`;
    }
  },
  /**
   * Transforms the value into an 6-digit hex string
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * "#009688"
   * ```
   *
   * @memberof Transforms
   */
  "color/hex": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      return Color__default.default(token.value).toHexString();
    }
  },
  /**
   * Transforms the value into an 8-digit hex string
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * "#009688ff"
   * ```
   *
   * @memberof Transforms
   */
  "color/hex8": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      return Color__default.default(token.value).toHex8String();
    }
  },
  /**
   * Transforms the value into an 8-digit hex string for Android because they put the alpha channel first
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * "#ff009688"
   * ```
   *
   * @memberof Transforms
   */
  "color/hex8android": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const str = Color__default.default(token.value).toHex8();
      return `#${str.slice(6)}${str.slice(0, 6)}`;
    }
  },
  /**
   * Transforms the value into a Color class for Compose
   *
   * ```kotlin
   * // Matches: prop.attributes.category === 'color'
   * // Returns:
   * Color(0xFF009688)
   * ```
   *
   * @memberof Transforms
   */
  "color/composeColor": {
    type: "value",
    matcher: isColor,
    transformer(prop) {
      const str = Color__default.default(prop.value).toHex8();
      return `Color(0x${str.slice(6)}${str.slice(0, 6)})`;
    }
  },
  /**
   * Transforms the value into an UIColor class for iOS
   *
   * ```objectivec
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * [UIColor colorWithRed:0.114f green:0.114f blue:0.114f alpha:1.000f]
   * ```
   *
   * @memberof Transforms
   */
  "color/UIColor": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const rgb = Color__default.default(token.value).toRgb();
      return `[UIColor colorWithRed:${(rgb.r / 255).toFixed(3)}f green:${(rgb.g / 255).toFixed(3)}f blue:${(rgb.b / 255).toFixed(3)}f alpha:${rgb.a.toFixed(3)}f]`;
    }
  },
  /**
   * Transforms the value into an UIColor swift class for iOS
   *
   * ```swift
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * UIColor(red: 0.667, green: 0.667, blue: 0.667, alpha: 0.6)
   * ```
   *
   * @memberof Transforms
   */
  "color/UIColorSwift": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const { r, g, b, a } = Color__default.default(token.value).toRgb();
      const rFixed = (r / 255).toFixed(3);
      const gFixed = (g / 255).toFixed(3);
      const bFixed = (b / 255).toFixed(3);
      return `UIColor(red: ${rFixed}, green: ${gFixed}, blue: ${bFixed}, alpha: ${a})`;
    }
  },
  /**
   * Transforms the value into an UIColor swift class for iOS
   *
   * ```swift
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * Color(red: 0.667, green: 0.667, blue: 0.667, opacity: 0.6)
   * ```
   *
   * @memberof Transforms
   */
  "color/ColorSwiftUI": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const { r, g, b, a } = Color__default.default(token.value).toRgb();
      const rFixed = (r / 255).toFixed(3);
      const gFixed = (g / 255).toFixed(3);
      const bFixed = (b / 255).toFixed(3);
      return `Color(red: ${rFixed}, green: ${gFixed}, blue: ${bFixed}, opacity: ${a})`;
    }
  },
  /**
   * Transforms the value into a hex or rgb string depending on if it has transparency
   *
   * ```css
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * #000000
   * rgba(0,0,0,0.5)
   * ```
   *
   * @memberof Transforms
   */
  "color/css": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const color = Color__default.default(token.value);
      if (color.getAlpha() === 1)
        return color.toHexString();
      else
        return color.toRgbString();
    }
  },
  /**
   *
   * Transforms a color into an object with red, green, blue, and alpha
   * attributes that are floats from 0 - 1. This object is how Sketch stores
   * colors.
   *
   * ```js
   * // Matches: token.attributes.category === 'color'
   * // Returns:
   * {
   *   red: 0.5,
   *   green: 0.5,
   *   blue: 0.5,
   *   alpha: 1
   * }
   * ```
   * @memberof Transforms
   */
  "color/sketch": {
    type: "value",
    matcher: (token) => token.attributes.category === "color",
    transformer(token) {
      const color = Color__default.default(token.original.value).toRgb();
      return {
        red: (color.r / 255).toFixed(5),
        green: (color.g / 255).toFixed(5),
        blue: (color.b / 255).toFixed(5),
        alpha: color.a
      };
    }
  },
  /**
   * Transforms the value into a scale-independent pixel (sp) value for font sizes on Android. It will not scale the number.
   *
   * ```js
   * // Matches: token.attributes.category === 'size' && token.attributes.type === 'font'
   * // Returns:
   * "10.0sp"
   * ```
   *
   * @memberof Transforms
   */
  "size/sp": {
    type: "value",
    matcher: isFontSize,
    transformer(token) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "sp");
      return `${val.toFixed(2)}sp`;
    }
  },
  /**
   * Transforms the value into a density-independent pixel (dp) value for non-font sizes on Android. It will not scale the number.
   *
   * ```js
   * // Matches: token.attributes.category === 'size' && token.attributes.type !== 'font'
   * // Returns:
   * "10.0dp"
   * ```
   *
   * @memberof Transforms
   */
  "size/dp": {
    type: "value",
    matcher: isNotFontSize,
    transformer(token) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "dp");
      return `${val.toFixed(2)}dp`;
    }
  },
  /**
   * Transforms the value into a usefull object ( for React Native support )
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns:
   * {
   *  original: "10px",
   *  number: 10,
   *  decimal: 0.1, // 10 divided by 100
   *  scale: 160, // 10 times 16
   * }
   * ```
   *
   * @memberof Transforms
   */
  "size/object": {
    type: "value",
    matcher: isSize,
    transformer(token, options2) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "object");
      return {
        original: token.value,
        number: val,
        decimal: val / 100,
        scale: val * getBasePxFontSize(options2)
      };
    }
  },
  /**
   * Transforms the value from a REM size on web into a scale-independent pixel (sp) value for font sizes on Android. It WILL scale the number by a factor of 16 (or the value of 'basePxFontSize' on the platform in your config).
   *
   * ```js
   * // Matches: token.attributes.category === 'size' && token.attributes.type === 'font'
   * // Returns:
   * "16.0sp"
   * ```
   *
   * @memberof Transforms
   */
  "size/remToSp": {
    type: "value",
    matcher: isFontSize,
    transformer(token, options2) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "sp");
      return `${(val * baseFont).toFixed(2)}sp`;
    }
  },
  /**
   * Transforms the value from a REM size on web into a density-independent pixel (dp) value for font sizes on Android. It WILL scale the number by a factor of 16 (or the value of 'basePxFontSize' on the platform in your config).
   *
   * ```js
   * // Matches: token.attributes.category === 'size' && token.attributes.type !== 'font'
   * // Returns:
   * "16.0dp"
   * ```
   *
   * @memberof Transforms
   */
  "size/remToDp": {
    type: "value",
    matcher: isNotFontSize,
    transformer(token, options2) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "dp");
      return `${(val * baseFont).toFixed(2)}dp`;
    }
  },
  /**
   * Adds 'px' to the end of the number. Does not scale the number
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns:
   * "10px"
   * ```
   *
   * @memberof Transforms
   */
  "size/px": {
    type: "value",
    matcher: isSize,
    transformer(token) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "px");
      return `${val}px`;
    }
  },
  /**
   * Adds 'rem' to the end of the number. Does not scale the number
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns:
   * "10rem"
   * ```
   *
   * @memberof Transforms
   */
  "size/rem": {
    type: "value",
    matcher: isSize,
    transformer(token) {
      const val = parseFloat(token.value);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "rem");
      return `${val}rem`;
    }
  },
  /**
   * Scales the number by 16 (or the value of 'basePxFontSize' on the platform in your config) and adds 'pt' to the end.
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns:
   * "16pt"
   * ```
   *
   * @memberof Transforms
   */
  "size/remToPt": {
    type: "value",
    matcher: isSize,
    transformer(token, options2) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "pt");
      return `${(val * baseFont).toFixed(2)}f`;
    }
  },
  /**
   * Transforms the value from a REM size on web into a scale-independent pixel (sp) value for font sizes in Compose. It WILL scale the number by a factor of 16 (or the value of 'basePxFontSize' on the platform in your config).
   *
   * ```kotlin
   * // Matches: prop.attributes.category === 'size' && prop.attributes.type === 'font'
   * // Returns:
   * "16.0.sp"
   * ```
   *
   * @memberof Transforms
   */
  "size/compose/remToSp": {
    type: "value",
    matcher: isFontSize,
    transformer(prop, options2) {
      const val = parseFloat(prop.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(prop.name, prop.value, "sp");
      return `${(val * baseFont).toFixed(2)}.sp`;
    }
  },
  /**
   * Transforms the value from a REM size on web into a density-independent pixel (dp) value for font sizes in Compose. It WILL scale the number by a factor of 16 (or the value of 'basePxFontSize' on the platform in your config).
   *
   * ```kotlin
   * // Matches: prop.attributes.category === 'size' && prop.attributes.type !== 'font'
   * // Returns:
   * "16.0.dp"
   * ```
   *
   * @memberof Transforms
   */
  "size/compose/remToDp": {
    type: "value",
    matcher: isNotFontSize,
    transformer(prop, options2) {
      const val = parseFloat(prop.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(prop.name, prop.value, "dp");
      return `${(val * baseFont).toFixed(2)}.dp`;
    }
  },
  /**
   * Adds the .em Compose extension to the end of a number. Does not scale the value
   *
   * ```kotlin
   * // Matches: prop.attributes.category === 'size' && prop.attributes.type === 'font'
   * // Returns:
   * "16.0em"
   * ```
   *
   * @memberof Transforms
   */
  "size/compose/em": {
    type: "value",
    matcher: isFontSize,
    transformer(prop) {
      const val = parseFloat(prop.value);
      if (isNaN(val))
        throwSizeError(prop.name, prop.value, "em");
      return `${val}.em`;
    }
  },
  /**
   * Scales the number by 16 (or the value of 'basePxFontSize' on the platform in your config) to get to points for Swift and initializes a CGFloat
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns: "CGFloat(16.00)""
   * ```
   *
   * @memberof Transforms
   */
  "size/swift/remToCGFloat": {
    type: "value",
    matcher: isSize,
    transformer(token, options2) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "CGFloat");
      return `CGFloat(${(val * baseFont).toFixed(2)})`;
    }
  },
  /**
   * Scales the number by 16 (or the value of 'basePxFontSize' on the platform in your config) and adds 'px' to the end.
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns:
   * "16px"
   * ```
   *
   * @memberof Transforms
   */
  "size/remToPx": {
    type: "value",
    matcher: isSize,
    transformer(token, options2) {
      const val = parseFloat(token.value);
      const baseFont = getBasePxFontSize(options2);
      if (isNaN(val))
        throwSizeError(token.name, token.value, "px");
      return `${(val * baseFont).toFixed(0)}px`;
    }
  },
  /**
   * Scales non-zero numbers to rem, and adds 'rem' to the end. If you define a "basePxFontSize" on the platform in your config, it will be used to scale the value, otherwise 16 (default web font size) will be used.
   *
   * ```js
   * // Matches: token.attributes.category === 'size'
   * // Returns:
   * "0"
   * "1rem"
   * ```
   *
   * @memberof Transforms
   */
  "size/pxToRem": {
    type: "value",
    matcher: isSize,
    transformer: (token, options2) => {
      const baseFont = getBasePxFontSize(options2);
      const floatVal = parseFloat(token.value);
      if (isNaN(floatVal))
        throwSizeError(token.name, token.value, "rem");
      if (floatVal === 0)
        return "0";
      return `${floatVal / baseFont}rem`;
    }
  },
  /**
   * Takes a unicode point and transforms it into a form CSS can use.
   *
   * ```js
   * // Matches: token.attributes.category === 'content' && token.attributes.type === 'icon'
   * // Returns:
   * "'\\E001'"
   * ```
   *
   * @memberof Transforms
   */
  "content/icon": {
    type: "value",
    matcher(token) {
      return token.attributes.category === "content" && token.attributes.type === "icon";
    },
    transformer(token) {
      return token.value.replace(UNICODE_PATTERN, (match, variable) => {
        return `'\\${variable}'`;
      });
    }
  },
  /**
   * Wraps the value in a single quoted string
   *
   * ```js
   * // Matches: token.attributes.category === 'content'
   * // Returns:
   * "'string'"
   * ```
   *
   * @memberof Transforms
   */
  "content/quote": {
    type: "value",
    matcher: isContent,
    transformer(token) {
      return wrapValueWith("'", token);
    }
  },
  /**
   * Wraps the value in a double-quoted string and prepends an '@' to make a string literal.
   *
   * ```objectivec
   * // Matches: token.attributes.category === 'content'
   * // Returns:
   * @"string"
   * ```
   *
   * @memberof Transforms
   */
  "content/objC/literal": {
    type: "value",
    matcher: isContent,
    transformer(token) {
      return `@${wrapValueWithDoubleQuote(token)}`;
    }
  },
  /**
   * Wraps the value in a double-quoted string to make a string literal.
   *
   * ```swift
   * // Matches: token.attributes.category === 'content'
   * // Returns:
   * "string"
   * ```
   *
   * @memberof Transforms
   */
  "content/swift/literal": {
    type: "value",
    matcher: isContent,
    transformer: wrapValueWithDoubleQuote
  },
  /**
   * Wraps the value in a double-quoted string and prepends an '@' to make a string literal.
   *
   * ```objectivec
   * // Matches: token.attributes.category === 'font'
   * // Returns: @"string"
   * ```
   *
   * @memberof Transforms
   */
  "font/objC/literal": {
    type: "value",
    matcher(token) {
      return token.attributes.category === "font";
    },
    transformer(token) {
      return `@${wrapValueWithDoubleQuote(token)}`;
    }
  },
  /**
   * Wraps the value in a double-quoted string to make a string literal.
   *
   * ```swift
   * // Matches: token.attributes.category === 'font'
   * // Returns: "string"
   * ```
   *
   * @memberof Transforms
   */
  "font/swift/literal": {
    type: "value",
    matcher(token) {
      return token.attributes.category === "font";
    },
    transformer: wrapValueWithDoubleQuote
  },
  /**
   * Assumes a time in miliseconds and transforms it into a decimal
   *
   * ```js
   * // Matches: token.attributes.category === 'time'
   * // Returns:
   * "0.5s"
   * ```
   *
   * @memberof Transforms
   */
  "time/seconds": {
    type: "value",
    matcher(token) {
      return token.attributes.category === "time";
    },
    transformer(token) {
      return `${(parseFloat(token.value) / 1e3).toFixed(2)}s`;
    }
  },
  /**
   * Wraps the value in a double-quoted string and prepends an '@' to make a string literal.
   *
   * ```js
   * // Matches: token.attributes.category === 'asset'
   * // Returns:
   * 'IyBlZGl0b3Jjb25maWcub3JnCnJvb3QgPSB0cnVlCgpbKl0KaW5kZW50X3N0eWxlID0gc3BhY2UKaW5kZW50X3NpemUgPSAyCmVuZF9vZl9saW5lID0gbGYKY2hhcnNldCA9IHV0Zi04CnRyaW1fdHJhaWxpbmdfd2hpdGVzcGFjZSA9IHRydWUKaW5zZXJ0X2ZpbmFsX25ld2xpbmUgPSB0cnVlCgpbKi5tZF0KdHJpbV90cmFpbGluZ193aGl0ZXNwYWNlID0gZmFsc2U='
   * ```
   *
   * @memberof Transforms
   */
  "asset/base64": {
    type: "value",
    matcher: isAsset,
    transformer(token) {
      return convertToBase64_default(token.value);
    }
  },
  /**
   * Prepends the local file path
   *
   * ```js
   * // Matches: token.attributes.category === 'asset'
   * // Returns:
   * "path/to/file/asset.png"
   * ```
   *
   * @memberof Transforms
   */
  "asset/path": {
    type: "value",
    matcher: isAsset,
    transformer(token) {
      return path4__namespace.join(process.cwd(), token.value);
    }
  },
  /**
   * Wraps the value in a double-quoted string and prepends an '@' to make a string literal.
   *
   * ```objectivec
   * // Matches: token.attributes.category === 'asset'
   * // Returns: @"string"
   * ```
   *
   * @memberof Transforms
   */
  "asset/objC/literal": {
    type: "value",
    matcher: isAsset,
    transformer(token) {
      return `@${wrapValueWithDoubleQuote(token)}`;
    }
  },
  /**
   * Wraps the value in a double-quoted string to make a string literal.
   *
   * ```swift
   * // Matches: token.attributes.category === 'asset'
   * // Returns: "string"
   * ```
   *
   * @memberof Transforms
   */
  "asset/swift/literal": {
    type: "value",
    matcher: isAsset,
    transformer: wrapValueWithDoubleQuote
  },
  /**
   * Transforms the value into a Flutter Color object using 8-digit hex with the alpha chanel on start
   *  ```js
   *  // Matches: token.attributes.category === 'color'
   *  // Returns:
   *  Color(0xFF00FF5F)
   *  ```
   *  @memberof Transforms
   *
   */
  "color/hex8flutter": {
    type: "value",
    matcher: isColor,
    transformer(token) {
      const str = Color__default.default(token.value).toHex8().toUpperCase();
      return `Color(0x${str.slice(6)}${str.slice(0, 6)})`;
    }
  },
  /**
   * Wraps the value in a double-quoted string to make a string literal.
   *
   * ```dart
   * // Matches: token.attributes.category === 'content'
   * // Returns: "string"
   * ```
   *
   * @memberof Transforms
   */
  "content/flutter/literal": {
    type: "value",
    matcher: isContent,
    transformer: wrapValueWithDoubleQuote
  },
  /**
   * Wraps the value in a double-quoted string to make a string literal.
   *
   * ```dart
   * // Matches: token.attributes.category === 'asset'
   * // Returns: "string"
   * ```
   *
   * @memberof Transforms
   */
  "asset/flutter/literal": {
    type: "value",
    matcher: isAsset,
    transformer: wrapValueWithDoubleQuote
  },
  /**
  * Wraps the value in a double-quoted string to make a string literal.
  *
  * ```dart
  * // Matches: token.attributes.category === 'font'
  * // Returns: "string"
  * ```
  *
  * @memberof Transforms
  */
  "font/flutter/literal": {
    type: "value",
    matcher(token) {
      return token.attributes.category === "font";
    },
    transformer: wrapValueWithDoubleQuote
  },
  /**
   * Scales the number by 16 (or the value of 'basePxFontSize' on the platform in your config) to get to points for Flutter
   *
   * ```dart
   * // Matches: token.attributes.category === 'size'
   * // Returns: 16.00
   * ```
   *
   * @memberof Transforms
   */
  "size/flutter/remToDouble": {
    type: "value",
    matcher: isSize,
    transformer(token, options2) {
      const baseFont = getBasePxFontSize(options2);
      return (parseFloat(token.value, 10) * baseFont).toFixed(2);
    }
  }
};

// src/common/transformGroups.js
var transformGroups_default = {
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/kebab](transforms.md#namectikebab)
   * [size/px](transforms.md#sizepx)
   * [color/css](transforms.md#colorcss)
   *
   * @memberof TransformGroups
   */
  "web": [
    "attribute/cti",
    "name/cti/kebab",
    "size/px",
    "color/css"
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/pascal](transforms.md#namectipascal)
   * [size/rem](transforms.md#sizerem)
   * [color/hex](transforms.md#colorhex)
   *
   * @memberof TransformGroups
   */
  "js": [
    "attribute/cti",
    "name/cti/pascal",
    "size/rem",
    "color/hex"
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/kebab](transforms.md#namectikebab)
   * [time/seconds](transforms.md#timeseconds)
   * [content/icon](transforms.md#contenticon)
   * [size/rem](transforms.md#sizerem)
   * [color/css](transforms.md#colorcss)
   *
   * @memberof TransformGroups
   */
  "scss": [
    "attribute/cti",
    "name/cti/kebab",
    "time/seconds",
    "content/icon",
    "size/rem",
    "color/css"
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/kebab](transforms.md#namectikebab)
   * [time/seconds](transforms.md#timeseconds)
   * [content/icon](transforms.md#contenticon)
   * [size/rem](transforms.md#sizerem)
   * [color/css](transforms.md#colorcss)
   *
   * @memberof TransformGroups
   */
  "css": [
    "attribute/cti",
    "name/cti/kebab",
    "time/seconds",
    "content/icon",
    "size/rem",
    "color/css"
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/kebab](transforms.md#namectikebab)
   * [time/seconds](transforms.md#timeseconds)
   * [content/icon](transforms.md#contenticon)
   * [size/rem](transforms.md#sizerem)
   * [color/hex](transforms.md#colorhex)
   *
   * @memberof TransformGroups
   */
  "less": [
    "attribute/cti",
    "name/cti/kebab",
    "time/seconds",
    "content/icon",
    "size/rem",
    "color/hex"
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [attribute/color](transforms.md#attributecolor)
   * [name/human](transforms.md#namehuman)
   *
   * @memberof TransformGroups
   */
  "html": [
    "attribute/cti",
    "attribute/color",
    "name/human"
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/snake](transforms.md#namectisnake)
   * [color/hex8android](transforms.md#colorhex8android)
   * [size/remToSp](transforms.md#sizeremtosp)
   * [size/remToDp](transforms.md#sizeremtodp)
   *
   * @memberof TransformGroups
   */
  "android": [
    "attribute/cti",
    "name/cti/snake",
    "color/hex8android",
    "size/remToSp",
    "size/remToDp"
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/camel](transforms.md#namecticamel)
   * [color/composeColor](transforms.md#colorcomposecolor)
   * [size/compose/em](transforms.md#sizecomposeem)
   * [size/compose/remToSp](transforms.md#sizecomposeremtosp)
   * [size/compose/remToDp](transforms.md#sizecomposeremtodp)
   *
   * @memberof TransformGroups
   */
  "compose": [
    "attribute/cti",
    "name/cti/camel",
    "color/composeColor",
    "size/compose/em",
    "size/compose/remToSp",
    "size/compose/remToDp"
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/pascal](transforms.md#namectipascal)
   * [color/UIColor](transforms.md#coloruicolor)
   * [content/objC/literal](transforms.md#contentobjcliteral)
   * [asset/objC/literal](transforms.md#assetobjcliteral)
   * [size/remToPt](transforms.md#sizeremtopt)
   * [font/objC/literal](transforms.md#fontobjcliteral)
   *
   * @memberof TransformGroups
   */
  "ios": [
    "attribute/cti",
    "name/cti/pascal",
    "color/UIColor",
    "content/objC/literal",
    "asset/objC/literal",
    "size/remToPt",
    "font/objC/literal"
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/camel](transforms.md#namecticamel)
   * [color/UIColorSwift](transforms.md#coloruicolorswift)
   * [content/swift/literal](transforms.md#contentswiftliteral)
   * [asset/swift/literal](transforms.md#assetswiftliteral)
   * [size/swift/remToCGFloat](transforms.md#sizeswiftremtocgfloat)
   * [font/swift/literal](transforms.md#fontswiftliteral)
   *
   * @memberof TransformGroups
   */
  "ios-swift": [
    "attribute/cti",
    "name/cti/camel",
    "color/UIColorSwift",
    "content/swift/literal",
    "asset/swift/literal",
    "size/swift/remToCGFloat",
    "font/swift/literal"
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/ti/camel](transforms.md#nameticamel)
   * [color/UIColorSwift](transforms.md#coloruicolorswift)
   * [content/swift/literal](transforms.md#contentswiftliteral)
   * [asset/swift/literal](transforms.md#assetswiftliteral)
   * [size/swift/remToCGFloat](transforms.md#sizeswiftremtocgfloat)
   * [font/swift/literal](transforms.md#fontswiftliteral)
   *
   * This is to be used if you want to have separate files per category and you don't want the category (e.g., color) as the lead value in the name of the token (e.g., StyleDictionaryColor.baseText instead of StyleDictionary.colorBaseText).
   *
   * @memberof TransformGroups
   */
  "ios-swift-separate": [
    "attribute/cti",
    "name/ti/camel",
    "color/UIColorSwift",
    "content/swift/literal",
    "asset/swift/literal",
    "size/swift/remToCGFloat",
    "font/swift/literal"
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   *
   * @memberof TransformGroups
   */
  "assets": [
    "attribute/cti"
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/cti/camel](transforms.md#namecticamel)
   * [color/hex8flutter](transforms.md#colorhex8flutter)
   * [size/flutter/remToDouble](transforms.md#sizeflutterremToDouble)
   * [content/flutter/literal](transforms.md#contentflutterliteral)
   * [asset/flutter/literal](transforms.md#assetflutterliteral)
   * [font/flutter/literal](transforms.md#fontflutterliteral)
   *
   * @memberof TransformGroups
   */
  "flutter": [
    "attribute/cti",
    "name/cti/camel",
    "color/hex8flutter",
    "size/flutter/remToDouble",
    "content/flutter/literal",
    "asset/flutter/literal",
    "font/flutter/literal"
  ],
  /**
   * Transforms:
   *
   * [attribute/cti](transforms.md#attributecti)
   * [name/ti/camel](transforms.md#nameticamel)
   * [color/hex8flutter](transforms.md#colorhex8flutter)
   * [size/flutter/remToDouble](transforms.md#sizeflutterremToDouble)
   * [content/flutter/literal](transforms.md#contentflutterliteral)
   * [asset/flutter/literal](transforms.md#assetflutterliteral)
   * [font/flutter/literal](transforms.md#fontflutterliteral)
   *
   * This is to be used if you want to have separate files per category and you don't want the category (e.g., color) as the lead value in the name of the token (e.g., StyleDictionaryColor.baseText instead of StyleDictionary.colorBaseText).
   *
   * @memberof TransformGroups
   */
  "flutter-separate": [
    "attribute/cti",
    "name/ti/camel",
    "color/hex8flutter",
    "size/flutter/remToDouble",
    "content/flutter/literal",
    "asset/flutter/literal",
    "font/flutter/literal"
  ],
  /**
   * Transforms:
   *
   * [name/cti/camel](transforms.md#namecticamel)
   * [size/object](transforms.md#sizeobject)
   * [color/css](transforms.md#colorcss)
   *
   * @memberof TransformGroups
   */
  "react-native": [
    "name/cti/camel",
    "color/css",
    "size/object"
  ]
};
function fileURLToPath(fileUrl) {
  if (typeof window !== "undefined" && window.URL && typeof window.URL === "function") {
    return new URL(fileUrl).pathname;
  } else {
    const { URL: URL2 } = jiti__default.default()("url");
    return new URL2(fileUrl).pathname;
  }
}

// src/resolveTemplate.js
var resolveTemplate = (_path) => {
  const _dir = path4.resolve(path4.dirname(fileURLToPath((typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('out.js', document.baseURI).href)))), "../templates");
  return fs4__default.default.readFileSync(path4.join(_dir, _path));
};

// src/utils/groupMessages.js
var groupedMessages = {};
var GroupMessages = {
  GROUP: {
    PropertyReferenceWarnings: "Property Reference Errors",
    PropertyValueCollisions: "Property Value Collisions",
    TemplateDeprecationWarnings: "Template Deprecation Warnings",
    SassMapFormatDeprecationWarnings: "Sass Map Format Deprecation Warnings",
    MissingRegisterTransformErrors: "Missing Register Transform Errors",
    PropertyNameCollisionWarnings: "Property Name Collision Warnings",
    FilteredOutputReferences: "Filtered Output Reference Warnings"
  },
  flush(messageGroup) {
    const messages = GroupMessages.fetchMessages(messageGroup);
    GroupMessages.clear(messageGroup);
    return messages;
  },
  add(messageGroup, message) {
    if (messageGroup) {
      if (!groupedMessages[messageGroup])
        groupedMessages[messageGroup] = [];
      if (!groupedMessages[messageGroup].includes(message))
        groupedMessages[messageGroup].push(message);
    }
  },
  count(messageGroup) {
    return groupedMessages[messageGroup] ? groupedMessages[messageGroup].length : 0;
  },
  fetchMessages(messageGroup) {
    return messageGroup && groupedMessages[messageGroup] || [];
  },
  clear(messageGroup) {
    messageGroup && groupedMessages[messageGroup] && delete groupedMessages[messageGroup];
  }
};
var groupMessages_default = GroupMessages;

// src/common/formatHelpers/index.js
var formatHelpers_exports = {};
__export(formatHelpers_exports, {
  createPropertyFormatter: () => createPropertyFormatter_default,
  fileHeader: () => fileHeader_default,
  formattedVariables: () => formattedVariables_default,
  getTypeScriptType: () => getTypeScriptType_default,
  iconsWithPrefix: () => iconsWithPrefix_default,
  minifyDictionary: () => minifyDictionary_default,
  setSwiftFileProperties: () => setSwiftFileProperties_default,
  sortByName: () => sortByName_default,
  sortByReference: () => sortByReference_default
});

// src/common/formatHelpers/createPropertyFormatter.js
var defaultFormatting = {
  prefix: "",
  commentStyle: "long",
  indentation: "",
  separator: " =",
  suffix: ";"
};
function createPropertyFormatter({
  outputReferences = false,
  outputReferenceFallbacks = false,
  dictionary,
  format,
  formatting = {},
  themeable = false
}) {
  let { prefix, commentStyle, indentation, separator, suffix } = Object.assign({}, defaultFormatting, formatting);
  switch (format) {
    case "css":
      prefix = "--";
      indentation = "  ";
      separator = ":";
      break;
    case "sass":
      prefix = "$";
      commentStyle = "short";
      indentation = "";
      separator = ":";
      break;
    case "less":
      prefix = "@";
      commentStyle = "short";
      indentation = "";
      separator = ":";
      break;
    case "stylus":
      prefix = "$";
      commentStyle = "short";
      indentation = "";
      separator = "=";
      break;
  }
  return function(prop) {
    let to_ret_prop = `${indentation}${prefix}${prop.name}${separator} `;
    let value = prop.value;
    if (outputReferences && dictionary.usesReference(prop.original.value)) {
      if (typeof value === "string") {
        const refs = dictionary.getReferences(prop.original.value);
        refs.forEach((ref) => {
          if (ref.value && ref.name) {
            const media = prop.attributes?.media;
            value = value.replace(ref.value?.[media] || ref.value, () => {
              if (format === "css") {
                if (outputReferenceFallbacks)
                  return `var(${prefix}${ref.name}, ${ref.value})`;
                else
                  return `var(${prefix}${ref.name})`;
              } else {
                return `${prefix}${ref.name}`;
              }
            });
          }
        });
      }
    }
    to_ret_prop += prop.attributes.category === "asset" ? `"${value}"` : value;
    const themeable_prop = typeof prop.themeable === "boolean" ? prop.themeable : themeable;
    if (format === "sass" && themeable_prop)
      to_ret_prop += " !default";
    to_ret_prop += suffix;
    if (prop.comment && commentStyle !== "none") {
      if (commentStyle === "short")
        to_ret_prop = to_ret_prop.concat(` // ${prop.comment}`);
      else
        to_ret_prop = to_ret_prop.concat(` /* ${prop.comment} */`);
    }
    return to_ret_prop;
  };
}
var createPropertyFormatter_default = createPropertyFormatter;

// src/common/formatHelpers/fileHeader.js
var defaultFileHeader = (arr) => arr;
var lineSeparator = "\n";
var defaultFormatting2 = {
  lineSeparator,
  prefix: " * ",
  header: `/**${lineSeparator}`,
  footer: `${lineSeparator} */${lineSeparator}${lineSeparator}`
};
function fileHeader({ file = {}, commentStyle, formatting = {} }) {
  let showFileHeader = true;
  if (file.options && typeof file.options.showFileHeader !== "undefined")
    showFileHeader = file.options.showFileHeader;
  if (!showFileHeader)
    return "";
  let fn = defaultFileHeader;
  if (file.options && typeof file.options.fileHeader === "function")
    fn = file.options.fileHeader;
  const defaultHeader = [
    "Do not edit directly",
    `Generated on ${( new Date()).toUTCString()}`
  ];
  let { prefix, lineSeparator: lineSeparator2, header, footer } = Object.assign({}, defaultFormatting2, formatting);
  if (commentStyle === "short") {
    prefix = "// ";
    header = `${lineSeparator2}`;
    footer = `${lineSeparator2}${lineSeparator2}`;
  } else if (commentStyle === "xml") {
    prefix = "  ";
    header = `<!--${lineSeparator2}`;
    footer = `${lineSeparator2}-->`;
  }
  return `${header}${fn(defaultHeader).map((line) => `${prefix}${line}`).join(lineSeparator2)}${footer}`;
}
var fileHeader_default = fileHeader;

// src/common/formatHelpers/sortByReference.js
function sortByReference(dictionary) {
  function sorter(a, b) {
    const aComesFirst = -1;
    const bComesFirst = 1;
    if (typeof a === "undefined")
      return aComesFirst;
    else if (typeof b === "undefined")
      return bComesFirst;
    if (a.original && dictionary.usesReference(a.original.value)) {
      if (b.original && dictionary.usesReference(b.original.value)) {
        const aRefs = dictionary.getReferences(a.original.value);
        const bRefs = dictionary.getReferences(b.original.value);
        aRefs.forEach((aRef) => {
          if (aRef.name === b.name)
            return bComesFirst;
        });
        bRefs.forEach((bRef) => {
          if (bRef.name === a.name)
            return aComesFirst;
        });
        return sorter(aRefs[0], bRefs[0]);
      } else {
        return bComesFirst;
      }
    } else {
      return aComesFirst;
    }
  }
  return sorter;
}
var sortByReference_default = sortByReference;

// src/common/formatHelpers/formattedVariables.js
var defaultFormatting3 = {
  lineSeparator: "\n"
};
function formattedVariables({ format, dictionary, outputReferences = false, formatting = {}, themeable = false }) {
  let { allTokens } = dictionary;
  const { lineSeparator: lineSeparator2 } = Object.assign({}, defaultFormatting3, formatting);
  if (outputReferences) {
    allTokens = [...allTokens].sort(sortByReference_default(dictionary));
  }
  return allTokens.map(createPropertyFormatter_default({ outputReferences, dictionary, format, formatting, themeable })).filter((strVal) => {
    return !!strVal;
  }).join(lineSeparator2);
}
var formattedVariables_default = formattedVariables;

// src/common/formatHelpers/getTypeScriptType.js
function getTypeScriptType(value, options2 = {}) {
  const { outputStringLiterals = false } = options2;
  if (Array.isArray(value))
    return getArrayType(value);
  if (typeof value === "object")
    return getObjectType(value);
  if (outputStringLiterals && typeof value === "string")
    return `"${value}"`;
  if (["string", "number", "boolean"].includes(typeof value))
    return typeof value;
  return "any";
}
function getObjectType(value) {
  const entries = Object.entries(value);
  return `{ ${entries.map(([key, property], index) => {
    const isLast = entries.length === index + 1;
    return `${key}: ${getTypeScriptType(property)}${!isLast ? ", " : ""}`;
  }).join("")} }`;
}
function getArrayType(passedArray) {
  if (passedArray.length > 0) {
    const firstValueType = getTypeScriptType(passedArray[0]);
    if (passedArray.every((v) => getTypeScriptType(v) === firstValueType)) {
      return `${firstValueType}[]`;
    } else {
      return `(${unique(passedArray.map((item, index) => {
        const isLast = passedArray.length === index + 1;
        return `${getTypeScriptType(item)}${!isLast ? " | " : ""}`;
      })).join("")})[]`;
    }
  }
  return "any[]";
}
var getTypeScriptType_default = getTypeScriptType;

// src/common/formatHelpers/iconsWithPrefix.js
function iconsWithPrefix(prefix, allTokens, options2) {
  return allTokens.filter((token) => {
    return token.attributes.category === "content" && token.attributes.type === "icon";
  }).map((token) => {
    const varName = `${prefix + token.name}: ${token.value};`;
    const className = `.${options2.prefix}-icon.${token.attributes.item}:before `;
    const declaration = `{ content: ${prefix}${token.name}; }`;
    return `${varName}
${className}${declaration}`;
  }).join("\n");
}
var iconsWithPrefix_default = iconsWithPrefix;

// src/common/formatHelpers/sortByName.js
function sortByName(a, b) {
  if (b.name > a.name)
    return -1;
  else
    return 1;
}
var sortByName_default = sortByName;

// src/common/formatHelpers/minifyDictionary.js
function minifyDictionary(obj) {
  if (typeof obj !== "object" || Array.isArray(obj))
    return obj;
  const toRet = {};
  if (obj.hasOwnProperty("value")) {
    return obj.value;
  } else {
    for (const name in obj) {
      if (obj.hasOwnProperty(name))
        toRet[name] = minifyDictionary(obj[name]);
    }
  }
  return toRet;
}
var minifyDictionary_default = minifyDictionary;

// src/common/formatHelpers/setSwiftFileProperties.js
function setSwiftFileProperties(options2, objectType, transformGroup) {
  if (typeof options2.objectType === "undefined") {
    if (typeof objectType === "undefined")
      options2.objectType = "class";
    else
      options2.objectType = objectType;
  }
  if (typeof options2.import === "undefined") {
    if (typeof transformGroup === "undefined") {
      options2.import = ["UIKit"];
    } else if (["ios-swift", "ios-swift-separate"].includes(transformGroup)) {
      options2.import = ["UIKit"];
    } else {
      options2.import = ["SwiftUI"];
    }
  } else if (typeof options2.import === "string") {
    options2.import = [options2.import];
  }
  if (typeof options2.accessControl === "undefined") {
    options2.accessControl = "public ";
  } else {
    if (options2.accessControl !== "")
      options2.accessControl = `${options2.accessControl} `;
  }
  return options2;
}
var setSwiftFileProperties_default = setSwiftFileProperties;

// src/common/formats.js
var SASS_MAP_FORMAT_DEPRECATION_WARNINGS = groupMessages_default.GROUP.SassMapFormatDeprecationWarnings;
var formats = {
  /**
   * Creates a CSS file with variable definitions based on the style dictionary
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @param {string} [options.selector] - Override the root css selector
   * @example
   * ```css
   * :root {
   *   --color-background-base: #f0f0f0;
   *   --color-background-alt: #eeeeee;
   * }
   * ```
   */
  "css/variables": function({ dictionary, options: options2 = {}, file }) {
    const selector = options2.selector ? options2.selector : ":root";
    const { outputReferences } = options2;
    return `${fileHeader_default({ file })}${selector} {
${formattedVariables_default({ format: "css", dictionary, outputReferences })}
}
`;
  },
  /**
   * Creates a SCSS file with a flat map based on the style dictionary
   *
   * Name the map by adding a 'mapName' attribute on the file object in your config.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```scss
   * $tokens: (
   *   'color-background-base': #f0f0f0;
   *   'color-background-alt': #eeeeee;
   * )
   * ```
   */
  "scss/map-flat": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("scss/map-flat.template"));
    const { allTokens } = dictionary;
    return template({ allTokens, file, options: options2, fileHeader: fileHeader_default });
  },
  // This will soon be removed, is left here only for backwards compatibility
  "sass/map-flat": function({ dictionary, options: options2, file }) {
    groupMessages_default.add(SASS_MAP_FORMAT_DEPRECATION_WARNINGS, "sass/map-flat");
    return formats["scss/map-flat"]({ dictionary, options: options2, file });
  },
  /**
   * Creates a SCSS file with a deep map based on the style dictionary.
   *
   * Name the map by adding a 'mapName' attribute on the file object in your config.
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @param {Boolean} [options.themeable=true] - Whether or not tokens should default to being themeable, if not otherwise specified per token.
   * @example
   * ```scss
   * $color-background-base: #f0f0f0 !default;
   * $color-background-alt: #eeeeee !default;
   *
   * $tokens: {
   *   'color': (
   *     'background': (
   *       'base': $color-background-base,
   *       'alt': $color-background-alt
   *     )
   *   )
   * )
   * ```
   */
  "scss/map-deep": function({ dictionary, options: options2, file }) {
    const mapTemplate = _template__default.default(resolveTemplate("scss/map-deep.template"));
    const { outputReferences, themeable = true } = options2;
    return `
${fileHeader_default({ file, commentStyle: "long" })}${formattedVariables_default({ format: "sass", dictionary, outputReferences, themeable })}
${mapTemplate({ dictionary, file })}`;
  },
  // This will soon be removed, is left here only for backwards compatibility
  "sass/map-deep": function({ dictionary, options: options2, file }) {
    groupMessages_default.add(SASS_MAP_FORMAT_DEPRECATION_WARNINGS, "sass/map-deep");
    return formats["scss/map-deep"]({ dictionary, options: options2, file });
  },
  /**
   * Creates a SCSS file with variable definitions based on the style dictionary.
   *
   * Add `!default` to any variable by setting a `themeable: true` attribute in the token's definition.
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @param {Boolean} [options.themeable=false] - Whether or not tokens should default to being themeable, if not otherwise specified per token.
   * @example
   * ```scss
   * $color-background-base: #f0f0f0;
   * $color-background-alt: #eeeeee !default;
   * ```
   */
  "scss/variables": function({ dictionary, options: options2, file }) {
    const { outputReferences, themeable = false } = options2;
    return fileHeader_default({ file, commentStyle: "short" }) + formattedVariables_default({ format: "sass", dictionary, outputReferences, themeable });
  },
  /**
   * Creates a SCSS file with variable definitions and helper classes for icons
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```scss
   * $content-icon-email: '\E001';
   * .icon.email:before { content:$content-icon-email; }
   * ```
   */
  "scss/icons": function({ dictionary, options: options2, file }) {
    return fileHeader_default({ file, commentStyle: "short" }) + iconsWithPrefix_default("$", dictionary.allTokens, options2);
  },
  /**
   * Creates a LESS file with variable definitions based on the style dictionary
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```less
   * \@color-background-base: #f0f0f0;
   * \@color-background-alt: #eeeeee;
   * ```
   */
  "less/variables": function({ dictionary, options: options2, file }) {
    const { outputReferences } = options2;
    return fileHeader_default({ file, commentStyle: "short" }) + formattedVariables_default({ format: "less", dictionary, outputReferences });
  },
  /**
   * Creates a LESS file with variable definitions and helper classes for icons
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```less
   * \@content-icon-email: '\E001';
   * .icon.email:before { content:\@content-icon-email; }
   * ```
   */
  "less/icons": function({ dictionary, options: options2, file }) {
    return fileHeader_default({ file, commentStyle: "short" }) + iconsWithPrefix_default("@", dictionary.allTokens, options2);
  },
  /**
   * Creates a Stylus file with variable definitions based on the style dictionary
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```stylus
   * $color-background-base= #f0f0f0;
   * $color-background-alt= #eeeeee;
   * ```
   */
  "stylus/variables": function({ dictionary, options: options2, file }) {
    const { outputReferences } = options2;
    return fileHeader_default({ file, commentStyle: "short" }) + formattedVariables_default({ format: "stylus", dictionary, outputReferences });
  },
  /**
   * Creates a CommonJS module with the whole style dictionary
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```js
   * export default {
   *   color: {
   *     base: {
   *        red: {
   *          value: '#ff0000'
   *        }
   *     }
   *   }
   * }
   * ```
   */
  "javascript/module": function({ dictionary, file }) {
    return `${fileHeader_default({ file })}export default ${JSON.stringify(dictionary.tokens, null, 2)};`;
  },
  /**
   * Creates a CommonJS module with the whole style dictionary flattened to a single level.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```js
   * export default {
   *  "ColorBaseRed": "#ff0000"
   *}
   *```
   */
  "javascript/module-flat": function({ dictionary, file }) {
    return `${fileHeader_default({ file })}export default ${formats["json/flat"]({ dictionary })};`;
  },
  /**
   * Creates a JS file a global var that is a plain javascript object of the style dictionary.
   * Name the variable by adding a 'name' attribute on the file object in your config.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```js
   * var StyleDictionary = {
   *   color: {
   *     base: {
   *        red: {
   *          value: '#ff0000'
   *        }
   *     }
   *   }
   * }
   * ```
   */
  "javascript/object": function({ dictionary, file }) {
    return `${fileHeader_default({ file })}var ${file.name || "_styleDictionary"} = ${JSON.stringify(dictionary.tokens, null, 2)};`;
  },
  /**
   * Creates a [UMD](https://github.com/umdjs/umd) module of the style
   * dictionary. Name the module by adding a 'name' attribute on the file object
   * in your config.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```js
   * (function(root, factory) {
   *   if (typeof module === "object" && module.exports) {
   *     export default factory();
   *   } else if (typeof exports === "object") {
   *     exports["_styleDictionary"] = factory();
   *   } else if (typeof define === "function" && define.amd) {
   *     define([], factory);
   *   } else {
   *     root["_styleDictionary"] = factory();
   *   }
   * }(this, function() {
   *   return {
   *     "color": {
   *       "red": {
   *         "value": "#FF0000"
   *       }
   *     }
   *   };
   * }))
   * ```
   */
  "javascript/umd": function({ dictionary, file }) {
    const name = file.name || "_styleDictionary";
    return `${fileHeader_default({ file })}(function(root, factory) {
  if (typeof module === "object" && module.exports) {
    export default factory();
  } else if (typeof exports === "object") {
    exports["${name}"] = factory();
  } else if (typeof define === "function" && define.amd) {
    define([], factory);
  } else {
    root["${name}"] = factory();
  }
}(this, function() {
  return ${JSON.stringify(dictionary.tokens, null, 2)};
}))
`;
  },
  /**
   * Creates a ES6 module of the style dictionary.
   *
   * ```json
   * {
   *   "platforms": {
   *     "js": {
   *       "transformGroup": "js",
   *       "files": [
   *         {
   *           "format": "javascript/es6",
   *           "destination": "colors.js",
   *           "filter": {
   *             "attributes": {
   *               "category": "color"
   *             }
   *           }
   *         }
   *       ]
   *     }
   *   }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```js
   * export const ColorBackgroundBase = '#ffffff';
   * export const ColorBackgroundAlt = '#fcfcfcfc';
   * ```
   */
  "javascript/es6": function({ dictionary, file }) {
    return fileHeader_default({ file }) + dictionary.allTokens.map((token) => {
      let to_ret = `export const ${token.name} = ${JSON.stringify(token.value)};`;
      if (token.comment)
        to_ret = to_ret.concat(` // ${token.comment}`);
      return to_ret;
    }).join("\n");
  },
  // TypeScript declarations
  /**
   * Creates TypeScript declarations for ES6 modules
   *
   * ```json
   * {
   *   "platforms": {
   *     "ts": {
   *       "transformGroup": "js",
   *       "files": [
   *         {
   *           "format": "javascript/es6",
   *           "destination": "colors.js"
   *         },
   *         {
   *           "format": "typescript/es6-declarations",
   *           "destination": "colors.d.ts"
   *         }
   *       ]
   *     }
   *   }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {Boolean} [options.outputStringLiterals=false] - Whether or not to output literal types for string values
   * @example
   * ```typescript
   * export const ColorBackgroundBase : string;
   * export const ColorBackgroundAlt : string;
   * ```
   */
  "typescript/es6-declarations": function({ dictionary, file, options: options2 }) {
    return fileHeader_default({ file }) + dictionary.allProperties.map((prop) => {
      let to_ret_prop = `export const ${prop.name} : ${getTypeScriptType_default(prop.value, options2)};`;
      if (prop.comment)
        to_ret_prop = to_ret_prop.concat(` // ${prop.comment}`);
      return to_ret_prop;
    }).join("\n");
  },
  /**
   * Creates TypeScript declarations for CommonJS module
   *
   * ```json
   * {
   *   "platforms": {
   *     "ts": {
   *       "transformGroup": "js",
   *       "files": [
   *         {
   *           "format": "javascript/module",
   *           "destination": "colors.js"
   *         },
   *         {
   *           "format": "typescript/module-declarations",
   *           "destination": "colors.d.ts"
   *         }
   *       ]
   *     }
   *   }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```typescript
   * export default tokens;
   * declare interface DesignToken { value: string; name?: string; path?: string[]; comment?: string; attributes?: any; original?: any; }
   * declare const tokens: {
   *  "color": {
   *    "red": DesignToken
   *  }
   * }
   * ```
   *
   * As you can see above example output this does not generate 100% accurate d.ts.
   * This is a compromise between of what style-dictionary can do to help and not bloating the library with rarely used dependencies.
   *
   * Thankfully you can extend style-dictionary very easily:
   *
   * ```js
   * import JsonToTS from 'json-to-ts';
   * StyleDictionaryPackage.registerFormat({
   *   name: 'typescript/accurate-module-declarations',
   *   formatter: function({ dictionary }) {
   *     return 'declare const root: RootObject\n' +
   *     'export default root\n' +
   *     JsonToTS(dictionary.properties).join('\n');
   *   },
   * });
   * ```
   */
  "typescript/module-declarations": function({ dictionary, file, options: options2 }) {
    const { moduleName = "tokens" } = options2;
    function treeWalker(obj) {
      let type = /* @__PURE__ */ Object.create(null);
      const has = Object.prototype.hasOwnProperty.bind(obj);
      if (has("value")) {
        type = "DesignToken";
      } else {
        for (const k in obj) {
          if (has(k)) {
            switch (typeof obj[k]) {
              case "object":
                type[k] = treeWalker(obj[k]);
            }
          }
        }
      }
      return type;
    }
    const _dir = path4.resolve(path4.dirname(fileURLToPath((typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('out.js', document.baseURI).href)))), "../templates");
    const designTokenInterface = fs4__default.default.readFileSync(path4.resolve(_dir, "../../types/DesignToken.d.ts"), { encoding: "UTF-8" });
    const lines = designTokenInterface.split("\n");
    const firstLine = lines.indexOf("//start") + 1;
    const lastLine = lines.indexOf("//end");
    const output = `${fileHeader_default({ file })}export default ${moduleName};

declare ${lines.slice(firstLine, lastLine).join("\n")}

declare const ${moduleName}: ${JSON.stringify(treeWalker(dictionary.tokens), null, 2)}`;
    return output.replace(/"DesignToken"/g, "DesignToken");
  },
  // Android templates
  /**
   * Creates a [resource](https://developer.android.com/guide/topics/resources/providing-resources) xml file. It is recommended to use a filter with this format
   * as it is generally best practice in Android development to have resource files
   * organized by type (color, dimension, string, etc.). However, a resource file
   * with mixed resources will still work.
   *
   * This format will try to use the proper resource type for each token based on
   * the category (color => color, size => dimen, etc.). However if you want to
   * force a particular resource type you can provide a 'resourceType' attribute
   * on the file configuration. You can also provide a 'resourceMap' if you
   * don't use Style Dictionary's built-in CTI structure.
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```xml
   * <?xml version="1.0" encoding="UTF-8"?>
   * <resources>
   *  <color name="color_base_red_5">#fffaf3f2</color>
   *  <color name="color_base_red_30">#fff0cccc</color>
   *  <dimen name="size_font_base">14sp</color>
   * ```
   */
  "android/resources": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("android/resources.template"));
    return template({ dictionary, file, options: options2, fileHeader: fileHeader_default });
  },
  /**
   * Creates a color resource xml file with all the colors in your style dictionary.
   *
   * It is recommended to use the 'android/resources' format with a custom filter
   * instead of this format:
   *
   * ```javascript
   * format: 'android/resources',
   * filter: {
   *   attributes: { category: 'color' }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```xml
   * <?xml version="1.0" encoding="UTF-8"?>
   * <resources>
   *  <color name="color_base_red_5">#fffaf3f2</color>
   *  <color name="color_base_red_30">#fff0cccc</color>
   *  <color name="color_base_red_60">#ffe19d9c</color>
   * ```
   */
  "android/colors": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("android/colors.template"));
    return template({ dictionary, file, options: options2, fileHeader: fileHeader_default });
  },
  /**
   * Creates a dimen resource xml file with all the sizes in your style dictionary.
   *
   * It is recommended to use the 'android/resources' format with a custom filter
   * instead of this format:
   *
   * ```javascript
   * format: 'android/resources',
   * filter: {
   *   attributes: { category: 'size' }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```xml
   * <?xml version="1.0" encoding="UTF-8"?>
   * <resources>
   *  <dimen name="size_padding_tiny">5.00dp</dimen>
   *  <dimen name="size_padding_small">10.00dp</dimen>
   *  <dimen name="size_padding_medium">15.00dp</dimen>
   * ```
   */
  "android/dimens": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("android/dimens.template"));
    return template({ dictionary, file, options: options2, fileHeader: fileHeader_default });
  },
  /**
   * Creates a dimen resource xml file with all the font sizes in your style dictionary.
   *
   * It is recommended to use the 'android/resources' format with a custom filter
   * instead of this format:
   *
   * ```javascript
   * format: 'android/resources',
   * filter: {
   *   attributes: { category: 'size' }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```xml
   * <?xml version="1.0" encoding="UTF-8"?>
   * <resources>
   *  <dimen name="size_font_tiny">10.00sp</dimen>
   *  <dimen name="size_font_small">13.00sp</dimen>
   *  <dimen name="size_font_medium">15.00sp</dimen>
   * ```
   */
  "android/fontDimens": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("android/fontDimens.template"));
    return template({ dictionary, file, options: options2, fileHeader: fileHeader_default });
  },
  /**
   * Creates a resource xml file with all the integers in your style dictionary. It filters your
   * design tokens by `token.attributes.category === 'time'`
   *
   * It is recommended to use the 'android/resources' format with a custom filter
   * instead of this format:
   *
   * ```javascript
   * format: 'android/resources',
   * filter: {
   *   attributes: { category: 'time' }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @todo Update the filter on this.
   * @example
   * ```xml
   * <?xml version="1.0" encoding="UTF-8"?>
   * <resources>
   *   <integer name="time_duration_short">1000</integer>
   *   <integer name="time_duration_medium">2000</integer>
   *   <integer name="time_duration_long">4000</integer>
   * ```
   */
  "android/integers": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("android/integers.template"));
    return template({ dictionary, file, options: options2, fileHeader: fileHeader_default });
  },
  /**
   * Creates a resource xml file with all the strings in your style dictionary. Filters your
   * design tokens by `token.attributes.category === 'content'`
   *
   * It is recommended to use the 'android/resources' format with a custom filter
   * instead of this format:
   *
   * ```javascript
   * format: 'android/resources',
   * filter: {
   *   attributes: { category: 'content' }
   * }
   * ```
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```xml
   * <?xml version="1.0" encoding="UTF-8"?>
   * <resources>
   *   <string name="content_icon_email">&#xE001;</string>
   *   <string name="content_icon_chevron_down">&#xE002;</string>
   *   <string name="content_icon_chevron_up">&#xE003;</string>
   * ```
   */
  "android/strings": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("android/strings.template"));
    return template({ dictionary, file, options: options2, fileHeader: fileHeader_default });
  },
  // Compose templates
  /**
   * Creates a Kotlin file for Compose containing an object with a `val` for each property.
   *
   * @memberof Formats
   * @kind member
   * @param {String} className The name of the generated Kotlin object
   * @param {String} packageName The package for the generated Kotlin object
   * @param {Object} options
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```kotlin
   * package com.example.tokens;
   *
   * import androidx.compose.ui.graphics.Color
   *
   * object StyleDictionary {
   *  val colorBaseRed5 = Color(0xFFFAF3F2)
   * }
   * ```
   */
  "compose/object": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("compose/object.kt.template"));
    let allProperties;
    const { outputReferences } = options2;
    const formatProperty = createPropertyFormatter_default({
      outputReferences,
      dictionary,
      formatting: {
        suffix: "",
        commentStyle: "none"
        // We will add the comment in the format template
      }
    });
    if (outputReferences)
      allProperties = [...dictionary.allProperties].sort(sortByReference_default(dictionary));
    else
      allProperties = [...dictionary.allProperties].sort(sortByName_default);
    return template({ allProperties, file, options: options2, formatProperty, fileHeader: fileHeader_default });
  },
  // iOS templates
  /**
   * Creates an Objective-C header file with macros for design tokens
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```objectivec
   * #import <Foundation/Foundation.h>
   * #import <UIKit/UIKit.h>
   *
   * #define ColorFontLink [UIColor colorWithRed:0.00f green:0.47f blue:0.80f alpha:1.00f]
   * #define SizeFontTiny 176.00f
   * ```
   */
  "ios/macros": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("ios/macros.template"));
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  /**
   * Creates an Objective-C plist file
   *
   * @memberof Formats
   * @kind member
   * @todo Fix this template and add example and usage
   */
  "ios/plist": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("ios/plist.template"));
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  /**
   * Creates an Objective-C implementation file of a style dictionary singleton class
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  "ios/singleton.m": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("ios/singleton.m.template"));
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  /**
   * Creates an Objective-C header file of a style dictionary singleton class
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  "ios/singleton.h": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("ios/singleton.h.template"));
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  /**
   * Creates an Objective-C header file of a static style dictionary class
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  "ios/static.h": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("ios/static.h.template"));
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  /**
   * Creates an Objective-C implementation file of a static style dictionary class
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  "ios/static.m": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("ios/static.m.template"));
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  /**
   * Creates an Objective-C header file of a color class
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  "ios/colors.h": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("ios/colors.h.template"));
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  /**
   * Creates an Objective-C implementation file of a color class
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  "ios/colors.m": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("ios/colors.m.template"));
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  /**
   * Creates an Objective-C header file of strings
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  "ios/strings.h": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("ios/strings.h.template"));
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  /**
   * Creates an Objective-C implementation file of strings
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  "ios/strings.m": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("ios/strings.m.template"));
    return template({ dictionary, options: options2, file, fileHeader: fileHeader_default });
  },
  /**
   * Creates a Swift implementation file of a class with values. It adds default `class` object type, `public` access control and `UIKit` import.
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {String} [options.accessControl=public] - Level of [access](https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html) of the generated swift object
   * @param {String[]} [options.import=UIKit] - Modules to import. Can be a string or array of string
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```swift
   * public class StyleDictionary {
   *   public static let colorBackgroundDanger = UIColor(red: 1.000, green: 0.918, blue: 0.914, alpha: 1)
   * }
   * ```
   */
  "ios-swift/class.swift": function({ dictionary, options: options2, file, platform }) {
    const template = _template__default.default(resolveTemplate("ios-swift/any.swift.template"));
    let allTokens;
    const { outputReferences } = options2;
    options2 = setSwiftFileProperties_default(options2, "class", platform.transformGroup);
    const formatProperty = createPropertyFormatter_default({
      outputReferences,
      dictionary,
      formatting: {
        suffix: ""
      }
    });
    if (outputReferences)
      allTokens = [...dictionary.allTokens].sort(sortByReference_default(dictionary));
    else
      allTokens = [...dictionary.allTokens].sort(sortByName_default);
    return template({ allTokens, file, options: options2, formatProperty, fileHeader: fileHeader_default });
  },
  /**
   * Creates a Swift implementation file of an enum with values. It adds default `enum` object type, `public` access control and `UIKit` import.
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {String} [options.accessControl=public] - Level of [access](https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html) of the generated swift object
   * @param {String[]} [options.import=UIKit] - Modules to import. Can be a string or array of string
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```swift
   * public enum StyleDictionary {
   *   public static let colorBackgroundDanger = UIColor(red: 1.000, green: 0.918, blue: 0.914, alpha: 1)
   * }
   * ```
   */
  "ios-swift/enum.swift": function({ dictionary, options: options2, file, platform }) {
    const template = _template__default.default(resolveTemplate("ios-swift/any.swift.template"));
    let allTokens;
    const { outputReferences } = options2;
    options2 = setSwiftFileProperties_default(options2, "enum", platform.transformGroup);
    const formatProperty = createPropertyFormatter_default({
      outputReferences,
      dictionary,
      formatting: {
        suffix: ""
      }
    });
    if (outputReferences)
      allTokens = [...dictionary.allTokens].sort(sortByReference_default(dictionary));
    else
      allTokens = [...dictionary.allTokens].sort(sortByName_default);
    return template({ allTokens, file, options: options2, formatProperty, fileHeader: fileHeader_default });
  },
  /**
   * Creates a Swift implementation file of any given type with values. It has by default `class` object type, `public` access control and `UIKit` import.
   *
   * ```javascript
   * format: 'ios-swift/any.swift',
   * import: ['UIKit', 'AnotherModule'],
   * objectType: 'struct',
   * accessControl: 'internal',
   * ```
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {String} [options.accessControl=public] - Level of [access](https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html) of the generated swift object
   * @param {String[]} [options.import=UIKit] - Modules to import. Can be a string or array of strings
   * @param {String} [options.objectType=class] - The type of the generated Swift object
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```swift
   * import UIKit
   * import AnotherModule
   *
   * internal struct StyleDictionary {
   *   internal static let colorBackgroundDanger = UIColor(red: 1.000, green: 0.918, blue: 0.914, alpha: 1)
   * }
   * ```
   */
  "ios-swift/any.swift": function({ dictionary, options: options2, file, platform }) {
    const template = _template__default.default(resolveTemplate("ios-swift/any.swift.template"));
    let allTokens;
    const { outputReferences } = options2;
    options2 = setSwiftFileProperties_default(options2, options2.objectType, platform.transformGroup);
    const formatProperty = createPropertyFormatter_default({
      outputReferences,
      dictionary,
      formatting: {
        suffix: ""
      }
    });
    if (outputReferences)
      allTokens = [...dictionary.allTokens].sort(sortByReference_default(dictionary));
    else
      allTokens = [...dictionary.allTokens].sort(sortByName_default);
    return template({ allTokens, file, options: options2, formatProperty, fileHeader: fileHeader_default });
  },
  // Css templates
  /**
   * Creates CSS file with @font-face declarations
   *
   * @memberof Formats
   * @kind member
   * @todo Add example and usage
   */
  "css/fonts.css": function(ctx) {
    const template = _template__default.default(resolveTemplate("css/fonts.css.template"));
    return template(ctx);
  },
  // Web templates
  /**
   * Creates a JSON file of the style dictionary.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```json
   * {
   *   "color": {
   *     "base": {
   *        "red": {
   *          "value": "#ff0000"
   *        }
   *     }
   *   }
   * }
   * ```
   */
  "json": function({ dictionary }) {
    return JSON.stringify(dictionary.tokens, null, 2);
  },
  /**
   * Creates a JSON file of the assets defined in the style dictionary.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```js
   * {
   *   "asset": {
   *     "image": {
   *        "logo": {
   *          "value": "assets/logo.png"
   *        }
   *     }
   *   }
   * }
   * ```
   */
  "json/asset": function({ dictionary }) {
    return JSON.stringify({ asset: dictionary.tokens.asset }, null, 2);
  },
  /**
   * Creates a JSON nested file of the style dictionary.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```json
   * {
   *   "color": {
   *     "base": {
   *        "red": "#ff0000"
   *     }
   *   }
   * }
   * ```
   */
  "json/nested": function({ dictionary }) {
    return JSON.stringify(minifyDictionary_default(dictionary.tokens), null, 2);
  },
  /**
   * Creates a JSON flat file of the style dictionary.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```json
   * {
   *   "color-base-red": "#ff0000"
   * }
   * ```
   */
  "json/flat": function({ dictionary }) {
    return `{
${dictionary.allTokens.map((token) => {
      return `  "${token.name}": ${JSON.stringify(token.value)}`;
    }).join(",\n")}
}`;
  },
  /**
   * Creates a sketchpalette file of all the base colors
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```json
   * {
   *   "compatibleVersion": "1.0",
   *   "pluginVersion": "1.1",
   *   "colors": [
   *     "#ffffff",
   *     "#ff0000",
   *     "#fcfcfc"
   *   ]
   * }
   * ```
   */
  "sketch/palette": function({ dictionary }) {
    const to_ret = {
      compatibleVersion: "1.0",
      pluginVersion: "1.1"
    };
    to_ret.colors = dictionary.allTokens.filter((token) => {
      return token.attributes.category === "color" && token.attributes.type === "base";
    }).map((token) => {
      return token.value;
    });
    return JSON.stringify(to_ret, null, 2);
  },
  /**
   * Creates a sketchpalette file compatible with version 2 of
   * the sketchpalette plugin. To use this you should use the
   * 'color/sketch' transform to get the correct value for the colors.
   *
   * @memberof Formats
   * @kind member
   * @example
   * ```json
   * {
   *   "compatibleVersion": "2.0",
   *   "pluginVersion": "2.2",
   *   "colors": [
   *     {name: "red", r: 1.0, g: 0.0, b: 0.0, a: 1.0},
   *     {name: "green", r: 0.0, g: 1.0, b: 0.0, a: 1.0},
   *     {name: "blue", r: 0.0, g: 0.0, b: 1.0, a: 1.0}
   *   ]
   * }
   * ```
   */
  "sketch/palette/v2": function({ dictionary }) {
    const to_ret = {
      compatibleVersion: "2.0",
      pluginVersion: "2.2",
      colors: dictionary.allTokens.map((token) => {
        return Object.assign({
          name: token.name
        }, token.value);
      })
    };
    return JSON.stringify(to_ret, null, 2);
  },
  // Flutter templates
  /**
   *  Creates a Dart implementation file of a class with values
   *
   * @memberof Formats
   * @kind member
   * @param {Object} options
   * @param {Boolean} [options.showFileHeader=true] - Whether or not to include a comment that has the build date
   * @param {Boolean} [options.outputReferences=false] - Whether or not to keep [references](/#/formats?id=references-in-output-files) (a -> b -> c) in the output.
   * @example
   * ```dart
   * import 'package:flutter/material.dart';
   *
   * class StyleDictionary {
   *   StyleDictionary._();
   *
   *     static const colorBrandPrimary = Color(0x00ff5fff);
   *     static const sizeFontSizeMedium = 16.00;
   *     static const contentFontFamily1 = "NewJune";
   * ```
   */
  "flutter/class.dart": function({ dictionary, options: options2, file }) {
    const template = _template__default.default(resolveTemplate("flutter/class.dart.template"));
    let allTokens;
    const { outputReferences } = options2;
    const formatProperty = createPropertyFormatter_default({
      outputReferences,
      dictionary
    });
    if (outputReferences)
      allTokens = [...dictionary.allTokens].sort(sortByReference_default(dictionary));
    else
      allTokens = [...dictionary.allTokens].sort(sortByName_default);
    return template({ allTokens, file, options: options2, formatProperty, fileHeader: fileHeader_default });
  }
};
formats["json/nested"].nested = true;
formats["javascript/module"].nested = true;
formats["javascript/object"].nested = true;
var formats_default = formats;
var _logger;
var logger = () => {
  if (!_logger)
    _logger = consola__default.default.create().withDefaults().withScope("style-dictionary");
  return _logger;
};
var logger_default = logger;

// src/common/actions.js
var actions_default = {
  /**
   * Action to copy images into appropriate android directories.
   *
   * @type {Action}
   * @memberof Actions
   */
  "android/copyImages": {
    do(dictionary, config) {
      const imagesDir = `${config.buildPath}android/main/res/drawable-`;
      dictionary.allTokens.forEach((token) => {
        if (token.attributes.category === "asset" && token.attributes.type === "image") {
          const name = token.path.slice(2, 4).join("_");
          fs4__default.default.cpSync(token.value, `${imagesDir + token.attributes.state}/${name}.png`);
        }
      });
    },
    undo(dictionary, config) {
      const imagesDir = `${config.buildPath}android/main/res/drawable-`;
      dictionary.allTokens.forEach((token) => {
        if (token.attributes.category === "asset" && token.attributes.type === "image") {
          const name = token.path.slice(2, 4).join("_");
          fs4__default.default.rmSync(`${imagesDir + token.attributes.state}/${name}.png`);
        }
      });
    }
  },
  /**
   * Action that copies everything in the assets directory to a new assets directory in the build path of the platform.
   *
   * @type {Action}
   * @memberof Actions
   */
  "copy_assets": {
    do(dictionary, config) {
      logger_default().log(`Copying assets directory to ${config.buildPath}assets`);
      fs4__default.default.cpSync("assets", `${config.buildPath}assets`);
    },
    undo(dictionary, config) {
      logger_default().log(`Removing assets directory from ${config.buildPath}assets`);
      fs4__default.default.rmSync(`${config.buildPath}assets`);
    }
  }
};

// src/common/filters.js
var filters_default = {
  /**
   * Remove a token from the ditribution output if it contains a key `private` set to true
   *
   * @memberof Filters
   *
   * @param {Object} token
   * @returns {Boolean}
   */
  removePrivate(token) {
    return !(token && token.private);
  }
};

// src/register/transform.js
var transformTypes = ["name", "value", "attribute"];
function registerTransform(options2) {
  if (typeof options2.type !== "string")
    throw new Error("type must be a string");
  if (!transformTypes.includes(options2.type))
    throw new Error(`${options2.type} type is not one of: ${transformTypes.join(", ")}`);
  if (typeof options2.name !== "string")
    throw new Error("name must be a string");
  if (options2.matcher && typeof options2.matcher !== "function")
    throw new Error("matcher must be a function");
  if (typeof options2.transformer !== "function")
    throw new Error("transformer must be a function");
  this.transform[options2.name] = {
    type: options2.type,
    matcher: options2.matcher,
    transitive: !!options2.transitive,
    transformer: options2.transformer
  };
  return this;
}
var transform_default = registerTransform;

// src/register/transformGroup.js
function registerTransformGroup(options2) {
  if (typeof options2.name !== "string")
    throw new Error("transform name must be a string");
  if (!isArray(options2.transforms))
    throw new Error("transforms must be an array of registered value transforms");
  options2.transforms.forEach((t) => {
    if (!(t in this.transform))
      throw new Error("transforms must be an array of registered value transforms");
  });
  this.transformGroup[options2.name] = options2.transforms;
  return this;
}
var transformGroup_default = registerTransformGroup;

// src/register/format.js
function registerFormat(options2) {
  if (typeof options2.name !== "string")
    throw new Error("Can't register format; format.name must be a string");
  if (typeof options2.formatter !== "function")
    throw new Error("Can't register format; format.formatter must be a function");
  this.format[options2.name] = options2.formatter;
  return this;
}
var format_default = registerFormat;

// src/register/action.js
function registerAction(options2) {
  if (typeof options2.name !== "string")
    throw new Error("name must be a string");
  if (typeof options2.do !== "function")
    throw new Error("do must be a function");
  this.action[options2.name] = {
    do: options2.do,
    undo: options2.undo
  };
  return this;
}
var action_default = registerAction;

// src/register/filter.js
function registerFilter(options2) {
  if (typeof options2.name !== "string")
    throw new Error("Can't register filter; filter.name must be a string");
  if (typeof options2.matcher !== "function")
    throw new Error("Can't register filter; filter.matcher must be a function");
  this.filter[options2.name] = options2.matcher;
  return this;
}
var filter_default = registerFilter;

// src/register/parser.js
function registerParser(options2) {
  if (!(options2.pattern instanceof RegExp))
    throw new Error("Can't register parser; parser.pattern must be a regular expression");
  if (typeof options2.parse !== "function")
    throw new Error("Can't register parser; parser.parse must be a function");
  this.parsers.push(options2);
  return this;
}
var parser_default = registerParser;

// src/register/fileHeader.js
function registerFileHeader(options2) {
  if (typeof options2.name !== "string")
    throw new Error("Can't register file header; options.name must be a string");
  if (typeof options2.fileHeader !== "function")
    throw new Error("Can't register file header; options.fileHeader must be a function");
  this.fileHeader[options2.name] = options2.fileHeader;
  return this;
}
var fileHeader_default2 = registerFileHeader;

// src/utils/references/defaults.js
var defaults = {
  opening_character: "{",
  closing_character: "}",
  separator: "."
};
var defaults_default = defaults;

// src/utils/references/createReferenceRegex.js
function createReferenceRegex(opts = {}) {
  const options2 = Object.assign({}, defaults_default, opts);
  return new RegExp(
    `\\${options2.opening_character}([^${options2.closing_character}]+)\\${options2.closing_character}`,
    "g"
  );
}
var createReferenceRegex_default = createReferenceRegex;

// src/utils/references/usesReference.js
function usesReference(value, regexOrOptions = {}) {
  const regex2 = regexOrOptions instanceof RegExp ? regexOrOptions : createReferenceRegex_default(regexOrOptions);
  if (typeof value === "string")
    return regex2.test(value);
  if (typeof value === "object") {
    let hasReference = false;
    for (const key in value) {
      if (value.hasOwnProperty(key)) {
        const element = value[key];
        const reference = usesReference(element, regexOrOptions);
        if (reference) {
          hasReference = true;
          break;
        }
      }
    }
    return hasReference;
  }
  return false;
}
var usesReference_default = usesReference;

// src/utils/references/getName.js
function getName(path5, opts = {}) {
  const options2 = Object.assign({}, defaults_default, opts);
  if (!path5 || !Array.isArray(path5))
    throw new Error("Getting name for path failed. Path must be an array");
  return path5.join(options2.separator);
}
var getName_default = getName;

// src/utils/references/getPathFromName.js
function getPathFromName(pathName, opts = {}) {
  const options2 = Object.assign({}, defaults_default, opts);
  if (typeof pathName !== "string")
    throw new Error("Getting path from name failed. Name must be a string");
  return pathName.split(options2.separator);
}
var getPathFromName_default = getPathFromName;

// src/utils/references/resolveReference.js
function resolveReference(path5, obj) {
  let i;
  let ref = obj;
  if (!Array.isArray(path5))
    return;
  for (i = 0; i < path5.length; i++) {
    if (typeof ref[path5[i]] !== "undefined") {
      ref = ref[path5[i]];
    } else {
      ref = void 0;
      break;
    }
  }
  return ref;
}
var resolveReference_default = resolveReference;

// src/utils/resolveObject.js
var PROPERTY_REFERENCE_WARNINGS = groupMessages_default.GROUP.PropertyReferenceWarnings;
var current_context = [];
var defaults2 = {
  ignoreKeys: ["original"],
  ignorePaths: []
};
var updated_object;
var regex;
var options;
function resolveObject(object, opts) {
  options = Object.assign({}, defaults2, opts);
  updated_object = cloneDeep(object);
  regex = createReferenceRegex_default(options);
  if (typeof object === "object") {
    current_context = [];
    return traverseObj(updated_object);
  } else {
    throw new TypeError("Please pass an object in");
  }
}
function traverseObj(obj) {
  let key;
  for (key in obj) {
    if (!obj.hasOwnProperty(key))
      continue;
    if (options.ignoreKeys && options.ignoreKeys.includes(key))
      continue;
    current_context.push(key);
    if (typeof obj[key] === "object") {
      traverseObj(obj[key]);
    } else {
      if (typeof obj[key] === "string" && obj[key].includes("{"))
        obj[key] = compile_value(obj[key], [getName_default(current_context)]);
    }
    current_context.pop();
  }
  return obj;
}
var foundCirc = {};
function compile_value(value, stack) {
  let to_ret = value;
  let ref;
  value.replace(regex, (match, variable) => {
    variable = variable.trim();
    const pathName = getPathFromName_default(variable, options);
    const context = getName_default(current_context, options);
    const refHasValue = pathName[pathName.length - 1] === "value";
    if (refHasValue && options.ignorePaths.includes(variable))
      return value;
    else if (!refHasValue && options.ignorePaths.includes(`${variable}.value`))
      return value;
    stack.push(variable);
    ref = resolveReference_default(pathName, updated_object);
    if (ref?.attributes?.variable)
      ref = ref?.attributes?.variable;
    else if (!refHasValue && ref && ref.hasOwnProperty("value"))
      ref = ref.value;
    if (typeof ref !== "undefined") {
      if (typeof ref === "string" || typeof ref === "number") {
        to_ret = value.replace(match, ref);
        if (usesReference_default(to_ret, regex)) {
          const reference = to_ret.slice(1, -1);
          if (foundCirc.hasOwnProperty(reference)) ; else if (stack.includes(reference)) {
            const stackIndexReference = stack.indexOf(reference);
            const circStack = stack.slice(stackIndexReference);
            circStack.forEach((key) => {
              foundCirc[key] = true;
            });
            circStack.push(reference);
            groupMessages_default.add(
              PROPERTY_REFERENCE_WARNINGS,
              `Circular definition cycle:  ${circStack.join(", ")}`
            );
          } else {
            to_ret = compile_value(to_ret, stack);
          }
        }
        if (typeof ref === "number" && ref.toString() === to_ret)
          to_ret = ref;
      } else {
        to_ret = ref;
      }
    } else {
      groupMessages_default.add(
        PROPERTY_REFERENCE_WARNINGS,
        `Reference doesn't exist: ${context} tries to reference ${variable}, which is not defined`
      );
      to_ret = ref;
    }
    stack.pop(variable);
    return to_ret;
  });
  return to_ret;
}
var resolveObject_default = resolveObject;

// src/transform/property.js
function transformProperty(property, options2) {
  const to_ret = clone(property);
  const transforms = options2.transforms;
  for (let i = 0; i < transforms.length; i++) {
    const transform = transforms[i];
    if (!transform.matcher || transform.matcher(to_ret)) {
      if (transform.type === "name")
        to_ret.name = transform.transformer(to_ret, options2);
      if (transform.type === "value" && !usesReference_default(property.value, options2)) {
        if (!usesReference_default(property.original.value, options2) || transform.transitive)
          to_ret.value = transform.transformer(to_ret, options2);
      }
      if (transform.type === "attribute")
        to_ret.attributes = Object.assign({}, to_ret.attributes, transform.transformer(to_ret, options2));
    }
  }
  return to_ret;
}
var property_default = transformProperty;

// src/utils/deepExtend.js
function deepExtend(objects, collision, path5) {
  if (objects == null)
    return {};
  let src;
  let copyIsArray;
  let copy;
  let name;
  let options2;
  let clone2;
  let target = objects[0] || {};
  let i = 1;
  const length = objects.length;
  path5 = path5 || [];
  if (typeof target !== "object")
    target = {};
  for (; i < length; i++) {
    options2 = objects[i];
    if (options2 != null) {
      for (name in options2) {
        if (!options2.hasOwnProperty(name))
          continue;
        if (name === "__proto__")
          continue;
        src = target[name];
        copy = options2[name];
        if (target === copy)
          continue;
        copyIsArray = isArray(copy);
        if (copy && (isPlainObject(copy) || copyIsArray)) {
          if (copyIsArray) {
            copyIsArray = false;
            clone2 = src && isArray(src) ? src : [];
          } else {
            clone2 = src && isPlainObject(src) ? src : {};
          }
          const nextPath = path5.slice(0);
          nextPath.push(name);
          target[name] = deepExtend([clone2, copy], collision, nextPath);
        } else if (copy !== void 0) {
          if (src != null && typeof collision == "function")
            collision({ target, copy: options2, path: path5, key: name });
          target[name] = copy;
        }
      }
    }
  }
  return target;
}
var deepExtend_default = deepExtend;

// src/transform/propertySetup.js
function propertySetup(property, name, path5) {
  if (!property && !isPlainObject(property))
    throw new Error("Property object must be an object");
  if (!name || !isString(name))
    throw new Error("Name must be a string");
  if (!path5 || !isArray(path5))
    throw new Error("Path must be an array");
  let to_ret = property;
  if (!property.original) {
    to_ret = deepExtend_default([{}, property]);
    const to_ret_original = deepExtend_default([{}, property]);
    delete to_ret_original.filePath;
    delete to_ret_original.isSource;
    to_ret.original = to_ret_original;
    to_ret.name = to_ret.name || name || "";
    to_ret.attributes = to_ret.attributes || {};
    to_ret.path = clone(path5);
  }
  return to_ret;
}
var propertySetup_default = propertySetup;

// src/transform/object.js
function transformObject(obj, options2, transformationContext = {}, path5, transformedObj) {
  transformedObj = transformedObj || {};
  path5 = path5 || [];
  const { transformedPropRefs = [], deferredPropValueTransforms = [] } = transformationContext;
  for (const name in obj) {
    if (!obj.hasOwnProperty(name))
      continue;
    path5.push(name);
    const objProp = obj[name];
    const isPlainObject2 = isPlainObject(objProp);
    if (isPlainObject2 && "value" in objProp) {
      const pathName = getName_default(path5);
      const alreadyTransformed = transformedPropRefs.includes(pathName);
      if (alreadyTransformed) {
        transformedObj[name] = objProp;
        path5.pop();
        continue;
      }
      const setupProperty = propertySetup_default(objProp, name, path5);
      if (usesReference_default(setupProperty.value, options2)) {
        if (!deferredPropValueTransforms.includes(pathName))
          deferredPropValueTransforms.push(pathName);
        transformedObj[name] = setupProperty;
        path5.pop();
        continue;
      }
      transformedObj[name] = property_default(setupProperty, options2);
      pull(deferredPropValueTransforms, pathName);
      transformedPropRefs.push(pathName);
    } else if (isPlainObject2) {
      transformedObj[name] = transformObject(objProp, options2, transformationContext, path5, transformedObj[name]);
    } else {
      transformedObj[name] = objProp;
    }
    path5.pop();
  }
  return transformedObj;
}
var object_default = transformObject;

// src/transform/config.js
var TEMPLATE_DEPRECATION_WARNINGS = groupMessages_default.GROUP.TemplateDeprecationWarnings;
var MISSING_TRANSFORM_ERRORS = groupMessages_default.GROUP.MissingRegisterTransformErrors;
function transformConfig(config, dictionary, platformName) {
  const to_ret = clone(config);
  let transforms = [];
  if (to_ret.transforms) {
    transforms = to_ret.transforms.filter(Boolean);
  } else if (to_ret.transformGroup) {
    if (dictionary.transformGroup[to_ret.transformGroup]) {
      transforms = dictionary.transformGroup[to_ret.transformGroup];
    } else {
      const err = `Unknown transformGroup "${to_ret.transformGroup}" found in platform "${platformName}":
"${to_ret.transformGroup}" does not match the name of a registered transformGroup.
`;
      throw new Error(err);
    }
  }
  to_ret.transforms = transforms.map((name) => {
    if (!dictionary.transform[name]) {
      groupMessages_default.add(
        MISSING_TRANSFORM_ERRORS,
        `"${name}"`
      );
    }
    return dictionary.transform[name];
  });
  const missingTransformCount = groupMessages_default.count(MISSING_TRANSFORM_ERRORS);
  if (missingTransformCount > 0) {
    const transform_warnings = groupMessages_default.flush(MISSING_TRANSFORM_ERRORS).join(", ");
    const err = `Unknown transforms ${transform_warnings} found in platform "${platformName}":
None of ${transform_warnings} match the name of a registered transform.`;
    throw new Error(err);
  }
  if (config.options && config.options.fileHeader) {
    const fileHeader2 = config.options.fileHeader;
    if (typeof fileHeader2 === "string") {
      if (dictionary.fileHeader[fileHeader2])
        to_ret.options.fileHeader = dictionary.fileHeader[fileHeader2];
      else
        throw new Error(`Can't find fileHeader: ${fileHeader2}`);
    } else if (typeof fileHeader2 !== "function") {
      throw new TypeError("fileHeader must be a string or a function");
    } else {
      to_ret.options.fileHeader = fileHeader2;
    }
  }
  to_ret.files = (config.files || []).map((file) => {
    const ext = { options: {} };
    if (file.options && file.options.fileHeader) {
      const fileHeader2 = file.options.fileHeader;
      if (typeof fileHeader2 === "string") {
        if (dictionary.fileHeader[fileHeader2])
          ext.options.fileHeader = dictionary.fileHeader[fileHeader2];
        else
          throw new Error(`Can't find fileHeader: ${fileHeader2}`);
      } else if (typeof fileHeader2 !== "function") {
        throw new TypeError("fileHeader must be a string or a function");
      } else {
        ext.options.fileHeader = fileHeader2;
      }
    }
    if (file.filter) {
      if (typeof file.filter === "string") {
        if (dictionary.filter[file.filter])
          ext.filter = dictionary.filter[file.filter];
        else
          throw new Error(`Can't find filter: ${file.filter}`);
      } else if (typeof file.filter === "object") {
        ext.filter = matches(file.filter);
      } else if (typeof file.filter === "function") {
        ext.filter = file.filter;
      } else {
        throw new TypeError(`Filter format not valid: ${typeof file.filter}`);
      }
    }
    if (file.template) {
      if (dictionary.format[file.template]) {
        groupMessages_default.add(
          TEMPLATE_DEPRECATION_WARNINGS,
          `${file.destination} (template: ${file.template})`
        );
        ext.format = dictionary.format[file.template];
      } else {
        throw new Error(`Can't find template: ${file.template}`);
      }
    } else if (file.format) {
      if (dictionary.format[file.format])
        ext.format = dictionary.format[file.format];
      else
        throw new Error(`Can't find format: ${file.format}`);
    } else {
      throw new Error(`Please supply a format for file: ${JSON.stringify(file)}`);
    }
    return deepExtend_default([{}, file, ext]);
  });
  to_ret.actions = (config.actions || []).map((action) => {
    if (typeof dictionary.action[action].undo !== "function")
      logger_default().warn(`${action} action does not have a clean function!`);
    return dictionary.action[action];
  });
  return to_ret;
}
var config_default = transformConfig;

// src/exportPlatform.js
var PROPERTY_REFERENCE_WARNINGS2 = groupMessages_default.GROUP.PropertyReferenceWarnings;
function exportPlatform(platform) {
  if (!platform || !this.options.platforms[platform])
    throw new Error("Please supply a valid platform");
  const platformConfig = config_default(this.options.platforms[platform], this);
  let exportableResult = this.properties;
  const transformedPropRefs = [];
  const deferredPropValueTransforms = [];
  const transformationContext = {
    transformedPropRefs,
    deferredPropValueTransforms
  };
  let deferredPropCount = 0;
  let finished;
  while (typeof finished === "undefined") {
    const transformed = object_default(exportableResult, platformConfig, transformationContext);
    const ignorePathsToResolve = deferredPropValueTransforms.map((p) => getName_default([p, "value"]));
    exportableResult = resolveObject_default(transformed, { ignorePaths: ignorePathsToResolve });
    const newDeferredPropCount = deferredPropValueTransforms.length;
    if (newDeferredPropCount === 0) {
      finished = true;
    } else if (deferredPropCount === newDeferredPropCount) {
      resolveObject_default(transformed);
      finished = true;
    } else {
      deferredPropCount = newDeferredPropCount;
    }
  }
  if (groupMessages_default.count(PROPERTY_REFERENCE_WARNINGS2) > 0) {
    const warnings = groupMessages_default.flush(PROPERTY_REFERENCE_WARNINGS2).join("\n");
    logger_default().log(`
${PROPERTY_REFERENCE_WARNINGS2}:
${warnings}

`);
    throw new Error("Problems were found when trying to resolve property references");
  }
  return exportableResult;
}
var exportPlatform_default = exportPlatform;

// src/filterProperties.js
function filterPropertyObject(properties, filter2) {
  return reduce(properties, (result, value, key) => {
    if (!isObject(value)) {
      return result;
    } else if (typeof value.value !== "undefined") {
      return filter2(value) ? assign(result, { [key]: value }) : result;
    } else {
      const filtered = filterPropertyObject(value, filter2);
      return isEmpty(filtered) ? result : assign(result, { [key]: filtered });
    }
  }, {});
}
function filterPropertyArray(properties, filter2) {
  return filter(properties, filter2);
}
function filterProperties(dictionary, filter2) {
  if (!filter2) {
    return dictionary;
  } else {
    return {
      allProperties: filterPropertyArray(dictionary.allProperties, filter2),
      properties: filterPropertyObject(dictionary.properties, filter2)
    };
  }
}
var filterProperties_default = filterProperties;

// src/utils/createFormatArgs.js
function createFormatArgs({ dictionary, platform, file = {} }) {
  const { allProperties, properties, allTokens, tokens, usesReference: usesReference2, getReferences: getReferences2 } = dictionary;
  const { options: options2 } = platform;
  file = deepExtend_default([{}, { options: options2 }, file]);
  return {
    dictionary,
    usesReference: usesReference2,
    getReferences: getReferences2,
    allProperties,
    properties,
    // adding tokens and allTokens as the new way starting in v3,
    // keeping properties and allProperties around for backwards-compatibility
    allTokens,
    tokens,
    platform,
    file,
    options: file.options || {}
  };
}
var createFormatArgs_default = createFormatArgs;

// src/buildFile.js
function buildFile(file = {}, platform = {}, dictionary = {}) {
  const { destination, filter: filter2 } = file || {};
  let { format } = file || {};
  const silent = file?.silent || platform?.silent || false;
  if (typeof format !== "function")
    throw new Error("Please enter a valid file format");
  const nested = format.nested;
  format = format.bind(file);
  let fullDestination = destination;
  const id = `${file?.format || ""}-${Date.now()}`;
  if (typeof destination === "string" && platform.buildPath)
    fullDestination = platform.buildPath + fullDestination;
  if (fullDestination && platform.write !== false) {
    const dirname5 = path4__namespace.dirname(fullDestination);
    if (!fs4__default.default.existsSync(dirname5))
      fs4__default.default.mkdirSync(dirname5, { recursive: true });
  }
  const filteredProperties = filterProperties_default(dictionary, filter2);
  const filteredDictionary = Object.assign({}, dictionary, {
    properties: filteredProperties.properties,
    allProperties: filteredProperties.allProperties,
    tokens: filteredProperties.properties,
    allTokens: filteredProperties.allProperties,
    // keep the unfiltered properties object for reference resolution
    _properties: dictionary.properties
  });
  if (filteredProperties.hasOwnProperty("properties") && Object.keys(filteredProperties.properties).length === 0 && filteredProperties.properties.constructor === Object) {
    const warnNoFile = `No properties for ${destination || id}. File not created.`;
    !silent && logger_default().log(chalk__default.default.red(warnNoFile));
    return null;
  }
  const nameCollisionObj = {};
  filteredProperties.allProperties && filteredProperties.allProperties.forEach((propertyData) => {
    const propertyName = propertyData.name;
    if (!nameCollisionObj[propertyName])
      nameCollisionObj[propertyName] = [];
    nameCollisionObj[propertyName].push(propertyData);
  });
  const PROPERTY_NAME_COLLISION_WARNINGS = `${groupMessages_default.GROUP.PropertyNameCollisionWarnings}:${destination || id}`;
  groupMessages_default.clear(PROPERTY_NAME_COLLISION_WARNINGS);
  Object.keys(nameCollisionObj).forEach((propertyName) => {
    if (nameCollisionObj[propertyName].length > 1) {
      const collisions = nameCollisionObj[propertyName].map((properties) => {
        const propertyPathText = chalk__default.default.red(properties.path.join("."));
        const valueText = chalk__default.default.red(properties.value);
        return `${propertyPathText}   ${valueText}`;
      }).join("\n        ");
      groupMessages_default.add(
        PROPERTY_NAME_COLLISION_WARNINGS,
        `Output name ${chalk__default.default.red.bold(propertyName)} was generated by:
        ${collisions}`
      );
    }
  });
  const propertyNamesCollisionCount = groupMessages_default.count(PROPERTY_NAME_COLLISION_WARNINGS);
  const result = format(createFormatArgs_default({
    dictionary: filteredDictionary,
    platform,
    file
  }), platform, file);
  if (platform?.write !== false && file?.write !== false) {
    fs4__default.default.writeFileSync(
      fullDestination,
      result
    );
  }
  if (platform?.done && typeof platform?.done === "function")
    platform?.done({ file, platform, dictionary, result });
  if (file?.done && typeof file?.done === "function")
    file?.done({ file, platform, dictionary, result });
  const filteredReferencesCount = groupMessages_default.count(groupMessages_default.GROUP.FilteredOutputReferences);
  if (!silent) {
    if ((nested || propertyNamesCollisionCount === 0) && filteredReferencesCount === 0) {
      logger_default().log(chalk__default.default.bold.green(`\u2714\uFE0E ${fullDestination}`));
    } else {
      logger_default().log(`\u26A0\uFE0F ${fullDestination}`);
      if (propertyNamesCollisionCount > 0) {
        const propertyNamesCollisionWarnings = groupMessages_default.fetchMessages(PROPERTY_NAME_COLLISION_WARNINGS).join("\n    ");
        const title = `While building ${chalk__default.default.red.bold(destination || id)}, token collisions were found; output may be unexpected.`;
        const help = chalk__default.default.red([
          "This many-to-one issue is usually caused by some combination of:",
          "* conflicting or similar paths/names in property definitions",
          "* platform transforms/transformGroups affecting names, especially when removing specificity",
          "* overly inclusive file filters"
        ].join("\n    "));
        const warn = `${title}
    ${propertyNamesCollisionWarnings}
${help}`;
        logger_default().log(chalk__default.default.red.bold(warn));
      }
      if (filteredReferencesCount > 0) {
        const filteredReferencesWarnings = groupMessages_default.flush(groupMessages_default.GROUP.FilteredOutputReferences).join("\n    ");
        const title = `While building ${chalk__default.default.red.bold(destination || id)}, filtered out token references were found; output may be unexpected. Here are the references that are used but not defined in the file`;
        const help = chalk__default.default.red([
          "This is caused when combining a filter and `outputReferences`."
        ].join("\n    "));
        const warn = `${title}
    ${filteredReferencesWarnings}
${help}`;
        logger_default().log(chalk__default.default.red.bold(warn));
      }
    }
  }
}
var buildFile_default = buildFile;

// src/buildFiles.js
function buildFiles(dictionary, platform) {
  if (platform.buildPath && (platform.buildPath.slice(-1) !== "/" && platform.buildPath.slice(-1) !== "\\"))
    throw new Error("Build path must end in a trailing slash or you will get weird file names.");
  platform.files.forEach((file) => {
    if (file.format)
      buildFile_default(file, platform, dictionary);
    else
      throw new Error("Please supply a format");
  });
}
var buildFiles_default = buildFiles;

// src/performActions.js
function performActions(dictionary, platform) {
  if (platform.actions) {
    platform.actions.forEach((action) => {
      action.do(dictionary, platform);
    });
  }
}
var performActions_default = performActions;

// src/utils/flattenProperties.js
function flattenProperties(properties, to_ret) {
  to_ret = to_ret || [];
  for (const name in properties) {
    if (properties.hasOwnProperty(name)) {
      if (isPlainObject(properties[name]) && "value" in properties[name])
        to_ret.push(properties[name]);
      else if (isPlainObject(properties[name]))
        flattenProperties(properties[name], to_ret);
    }
  }
  return to_ret;
}
var flattenProperties_default = flattenProperties;

// src/utils/references/getReferences.js
function getReferences(value, references = []) {
  const self = this;
  const regex2 = createReferenceRegex_default({});
  function findReference(match, variable) {
    variable = variable.trim().replace(".value", "");
    const pathName = getPathFromName_default(variable);
    let ref = resolveReference_default(pathName, self.properties);
    if (!ref) {
      ref = resolveReference_default(pathName, self._properties);
      groupMessages_default.add(groupMessages_default.GROUP.FilteredOutputReferences, variable);
    }
    references.push(ref);
  }
  if (typeof value === "string") {
    value.replace(regex2, findReference);
  }
  if (typeof value === "object") {
    for (const key in value) {
      if (value.hasOwnProperty(key) && typeof value[key] === "string")
        value[key].replace(regex2, findReference);
      if (value.hasOwnProperty(key) && typeof value[key] === "object")
        self.getReferences(value[key], references);
    }
  }
  return references;
}
var getReferences_default = getReferences;

// src/utils/createDictionary.js
function createDictionary({ properties }) {
  const allProperties = flattenProperties_default(properties);
  return {
    properties,
    allProperties,
    // adding tokens and allTokens as the new way starting in v3,
    // keeping properties and allProperties around for backwards-compatibility
    tokens: properties,
    allTokens: allProperties,
    getReferences: getReferences_default,
    usesReference: usesReference_default
  };
}
var createDictionary_default = createDictionary;

// src/buildPlatform.js
function buildPlatform(platform) {
  if (!this.options || !(platform in (this.options.platforms || {})))
    throw new Error(`Platform "${platform}" does not exist`);
  let properties;
  const platformConfig = config_default(this.options.platforms[platform], this, platform);
  if (!platformConfig?.silent)
    logger_default().log(`
${platform}`);
  properties = this.exportPlatform(platform);
  const dictionary = createDictionary_default({ properties });
  buildFiles_default(dictionary, platformConfig);
  performActions_default(dictionary, platformConfig);
  return this;
}
var buildPlatform_default = buildPlatform;

// src/buildAllPlatforms.js
function buildAllPlatforms() {
  const self = this;
  Object.keys(this.options.platforms).forEach((key) => {
    self.buildPlatform(key);
  });
  return this;
}
var buildAllPlatforms_default = buildAllPlatforms;
function cleanFile(file = {}, platform = {}) {
  let { destination } = file;
  const silent = file?.silent || platform?.silent || false;
  if (typeof destination !== "string" || platform.write === false)
    return;
  if (platform.buildPath)
    destination = platform.buildPath + destination;
  if (!fs4__default.default.existsSync(destination)) {
    !silent && logger_default().log(`${chalk__default.default.bold.red("!")} ${destination}, does not exist`);
    return;
  }
  fs4__default.default.unlinkSync(destination);
  !silent && logger_default().log(`${chalk__default.default.bold.red("-")} ${destination}`);
}
var cleanFile_default = cleanFile;

// src/cleanFiles.js
function cleanFiles(dictionary, platform) {
  if (platform.buildPath && platform.buildPath.slice(-1) !== "/")
    throw new Error("Build path must end in a trailing slash or you will get weird file names.");
  platform.files.forEach((file) => {
    if (file.format)
      cleanFile_default(file, platform);
    else
      throw new Error("Please supply a template or formatter");
  });
}
var cleanFiles_default = cleanFiles;
function cleanDir(file = {}, platform = {}) {
  let { destination } = file;
  const silent = file?.silent || platform?.silent || false;
  if (typeof destination !== "string" || platform.write === false)
    return;
  if (platform.buildPath)
    destination = platform.buildPath + destination;
  let dirname5 = path4__namespace.dirname(destination);
  while (dirname5) {
    if (fs4__default.default.existsSync(dirname5)) {
      if (fs4__default.default.readdirSync(dirname5).length === 0) {
        !silent && logger_default().log(`${chalk__default.default.bold.red("-")} ${dirname5}`);
        fs4__default.default.rmdirSync(dirname5);
      } else {
        break;
      }
    }
    dirname5 = dirname5.split("/");
    dirname5.pop();
    dirname5 = dirname5.join("/");
  }
}
var cleanDir_default = cleanDir;

// src/cleanDirs.js
function cleanDirs(dictionary, platform) {
  if (platform.buildPath && platform.buildPath.slice(-1) !== "/")
    throw new Error("Build path must end in a trailing slash or you will get weird file names.");
  platform.files.forEach((file) => {
    if (file.format)
      cleanDir_default(file, platform);
    else
      throw new Error("Please supply a format");
  });
}
var cleanDirs_default = cleanDirs;

// src/cleanActions.js
function cleanActions(dictionary, platform) {
  if (platform.actions) {
    platform.actions.forEach((action) => {
      if (typeof action.undo === "function")
        action.undo(dictionary, platform);
    });
  }
}
var cleanActions_default = cleanActions;

// src/cleanPlatform.js
function cleanPlatform(platform) {
  if (!this.options || !(platform in (this.options.platforms || {})))
    throw new Error(`Platform ${platform} doesn't exist`);
  let properties;
  const platformConfig = config_default(this.options.platforms[platform], this, platform);
  if (!platformConfig?.silent)
    logger_default().log(`
${platform}`);
  properties = this.exportPlatform(platform);
  const dictionary = createDictionary_default({ properties });
  cleanFiles_default(dictionary, platformConfig);
  cleanActions_default(dictionary, platformConfig);
  cleanDirs_default(dictionary, platformConfig);
  return this;
}
var cleanPlatform_default = cleanPlatform;

// src/cleanAllPlatforms.js
function cleanAllPlatforms() {
  const self = this;
  Object.keys(this.options.platforms).forEach((key) => {
    self.cleanPlatform(key);
  });
  return this;
}
var cleanAllPlatforms_default = cleanAllPlatforms;
function resolveFileContent_default(resolvedPath) {
  let _content;
  if (resolvedPath.match(/.json5$/)) {
    const source = fs4__default.default.readFileSync(resolvedPath, { encoding: "UTF-8" });
    _content = JSON5__default.default.parse(source);
  } else if (resolvedPath.match(/.jsonc$/)) {
    const source = fs4__default.default.readFileSync(resolvedPath, { encoding: "UTF-8" });
    _content = jsoncParser.parse(source);
  } else if (resolvedPath.match(/.json$/)) {
    const source = fs4__default.default.readFileSync(resolvedPath, { encoding: "UTF-8" });
    _content = JSON.parse(source);
  } else {
    _content = jiti__default.default((typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('out.js', document.baseURI).href)), { interopDefault: true, cache: false, v8cache: false, requireCache: false })(resolvedPath);
  }
  return _content;
}
function traverseObj2(obj, fn) {
  for (const key in obj) {
    fn.apply(null, [obj, key, obj[key]]);
    if (obj[key] && typeof obj[key] === "object")
      traverseObj2(obj[key], fn);
  }
}
function combineJSON(arr, deep, collision, source, parsers = []) {
  let i;
  let files = [];
  const to_ret = {};
  for (i = 0; i < arr.length; i++) {
    const new_files = glob__default.default.sync(arr[i], {});
    files = files.concat(new_files);
  }
  for (i = 0; i < files.length; i++) {
    const filePath = files[i];
    const resolvedPath = path4__namespace.isAbsolute(files[i]) ? files[i] : path4__namespace.resolve(process.cwd(), files[i]);
    let file_content = null;
    try {
      parsers.forEach(({ pattern, parse }) => {
        if (resolvedPath.match(pattern)) {
          file_content = parse({
            contents: fs4__default.default.readFileSync(resolvedPath, { encoding: "UTF-8" }),
            filePath: resolvedPath
          });
        }
      });
      if (!file_content) {
        const _content = resolveFileContent_default(resolvedPath);
        file_content = deepExtend_default([file_content, _content]);
      }
    } catch (e) {
      e.message = `Failed to load or parse JSON or JS Object: ${e.message}`;
      throw e;
    }
    traverseObj2(file_content, (obj) => {
      if (obj.hasOwnProperty("value") && !obj.filePath) {
        obj.filePath = filePath;
        obj.isSource = !!(source || source === void 0);
      }
    });
    if (deep)
      deepExtend_default([to_ret, file_content], collision);
    else
      Object.assign(to_ret, file_content);
  }
  return to_ret;
}
var combineJSON_default = combineJSON;

// src/extend.js
var PROPERTY_VALUE_COLLISIONS = groupMessages_default.GROUP.PropertyValueCollisions;
function extend(opts) {
  let options2, to_ret;
  let inlineTokens = {};
  let includeTokens = {};
  let sourceTokens = {};
  if (isString(opts))
    options2 = resolveFileContent_default(opts);
  else
    options2 = opts;
  to_ret = deepExtend_default([{}, this, { options: options2 }, options2]);
  inlineTokens = deepExtend_default([{}, to_ret.tokens || {}, to_ret.properties || {}]);
  if (options2.include) {
    if (!isArray(options2.include))
      throw new Error("include must be an array");
    includeTokens = combineJSON_default(options2.include, true, null, false, to_ret.parsers);
    to_ret.include = null;
  }
  if (options2.source) {
    if (!isArray(options2.source))
      throw new Error("source must be an array");
    sourceTokens = combineJSON_default(options2.source, true, (prop) => {
      groupMessages_default.add(
        PROPERTY_VALUE_COLLISIONS,
        `Collision detected at: ${prop.path.join(".")}! Original value: ${prop.target[prop.key]}, New value: ${prop.copy[prop.key]}`
      );
    }, true, to_ret.parsers);
    if (groupMessages_default.count(PROPERTY_VALUE_COLLISIONS) > 0) {
      const collisions = groupMessages_default.flush(PROPERTY_VALUE_COLLISIONS).join("\n");
      logger_default().log(`
${PROPERTY_VALUE_COLLISIONS}:
${collisions}

`);
      if (options2.log === "error")
        throw new Error("Collisions detected");
    }
    to_ret.source = null;
  }
  const tokens = deepExtend_default([{}, inlineTokens, includeTokens, sourceTokens]);
  to_ret.tokens = tokens;
  to_ret.properties = tokens;
  return to_ret;
}
var extend_default = extend;

// src/index.js
var StyleDictionary = {
  VERSION: version,
  tokens: {},
  allTokens: [],
  options: {},
  parsers: [],
  fileHeader: {},
  transform: transforms_default,
  transformGroup: transformGroups_default,
  format: formats_default,
  action: actions_default,
  formatHelpers: formatHelpers_exports,
  filter: filters_default,
  logger: logger_default,
  registerTransform: transform_default,
  registerTransformGroup: transformGroup_default,
  registerFormat: format_default,
  registerAction: action_default,
  registerFilter: filter_default,
  registerParser: parser_default,
  registerFileHeader: fileHeader_default2,
  exportPlatform: exportPlatform_default,
  buildPlatform: buildPlatform_default,
  buildAllPlatforms: buildAllPlatforms_default,
  cleanPlatform: cleanPlatform_default,
  cleanAllPlatforms: cleanAllPlatforms_default,
  extend: extend_default
};
var src_default = StyleDictionary;

module.exports = src_default;
